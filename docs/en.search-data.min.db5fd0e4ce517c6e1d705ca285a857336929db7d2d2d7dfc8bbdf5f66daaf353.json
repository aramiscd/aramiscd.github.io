[{"id":0,"href":"/docs/weblog/2023-07-07/","title":"ADTs, GADTS, Typklassen","section":"Docs","content":"2023-07-07\nADTs, GADTs, Typklassen # Ich habe vor Kurzem funktionale Abh√§ngigkeiten kennengelernt und hatte gleich den Impuls, dar√ºber zu schreiben. Das ist eine gute Gelegenheit, um etwas ausf√ºhrlicher auf Konzepte der Typebene in Sprachen wie Haskell, Purescript, Elm und Ocaml einzugehen.\nEinfache Datentypen # Die meisten Sprachen bringen einen Vorrat an einfachen Datentypen mit: numerische Datentypen f√ºr ganze Zahlen und Gleitkommazahlen, Datentypen f√ºr einzelne Buchstaben und andere Schriftzeichen, einen Datentyp mit den zwei Wahrheitswerten \u0026ldquo;falsch\u0026rdquo; und \u0026ldquo;wahr\u0026rdquo;.\nIn den Details gibt es gro√üe Unterschiede zwischen den Sprachen, je nachdem, wo sie ihre Schwerpunkte setzen und welche Form der Programmierung sie unterst√ºtzen. Beispielsweise hat C keinen speziellen Datentyp f√ºr Wahrheitswerte, Python und Javascript unterscheiden nicht streng zwischen einzelnen Schriftzeichen und Zeichenketten, Javascript unterscheidet nicht zwischen ganzen Zahlen und Gleitkommazahlen, TCL kennt nur Zeichenketten, \u0026hellip;\nEin paar einfache Datentypen in Haskell:\nInt: ganze Zahlen wie -3, 0, 123, 999999999, \u0026hellip; Float: Gleitkommazahlen wie -123.45, 1.0, 3.141592653, \u0026hellip; Char: Zeichen wie 'a', 'Œ≤', '7', '+', '?', 'üôÇ', \u0026hellip; Bool: die Wahrheitswerte True und False. Die Gr√∂√üe einfacher Datentypen # Man kann einen Datentyp auffassen als die Menge seiner Werte. Hier als Beispiel der Datentyp Bool in Mengenschreibweise:\nBool = { False , True } Die Gr√∂√üe eines Datentyps ist die Anzahl seiner Werte. Der Datentyp Bool enth√§lt genau zwei Werte. Damit ist seine Gr√∂√üe 2.\nDas gleiche Spiel kann man mit allen einfachen Datentypen spielen. Der kleinste Int Wert auf meinem Rechner ist die ganze Zahl -9223372036854775808 und der gr√∂√üte Int Wert die ganze Zahl 9223372036854775807. Daraus ergibt sich f√ºr den Datentyp Int die Gr√∂√üe 2^64.\nDie Gr√∂√üe eines einfachen Datentyps h√§ngt letztlich auch damit zusammen, wie viele Bits mindestens ben√∂tigt werden um einen seiner Werte zu codieren. Ein Int Wert ist auf meinem Rechner in 64 Bits codiert. Daraus ergibt sich, dass 2^64 verschiedene Int Werte codiert werden k√∂nnen. In Sprachen wie C, die daf√ºr gemacht sind, m√∂glichst effiziente Programme zu schreiben und verh√§ltnism√§√üig nah an der Hardware zu programmieren, bedeutet ein Datentyp im Grunde nicht mehr als die Anzahl von Bits, die einer seiner Werte im Speicher mindestens ben√∂tigt.\nBei Char und Float ist die Berechnung der Gr√∂√üe etwas komplizierter. vom Datentyp Char gibt es insgesamt 1114112 Werte. F√ºr Float wei√ü ich es nicht, aber es l√§sst sich grunds√§tzlich ausrechnen.\nZusammengesetzte Datentypen # Zusammengesetzte Datentypen sind bspw. Arrays, Listen, Strings, Tupel, Records und Structs. Das sind allesamt Datentypen, die sich \u0026ndash; wie der Name sagt \u0026ndash; auf irgendeine Art aus anderen Datentypen zusammensetzen.\nEin Record-Datentyp f√ºr ganzzahlige Punkte in der Ebene k√∂nnte so aussehen:\n-- Purescript type Point = { x :: Int , y :: Int } Ein Tupel-Datentyp f√ºr den selben Zweck:\n-- Haskell (Int,Int) Der Record-Datentyp hat den Vorteil, dass die Felder mit x und y bezeichnet sind. Dadurch ist es vermutlich etwas schwerer, sie zu verwechseln. Au√üerdem k√∂nnen wir direkt √ºber die Feldnamen auf ihre Werte zugreifen. Beim Tupel-Datentyp verlassen wir uns auf die Position der Felder f√ºr ihre Unterscheidung. Der Zugriff auf die Felder erfolgt √ºber Pattern-Matching in Case Expressions oder √ºber spezielle Zugriffsfunktionen wie fst und snd. Daf√ºr deckt sich die Tupel-Schreibweise mit der Schreibweise f√ºr Punkte in der Ebene, die auch sonst √ºblich ist. Das sind aber rein ergonomische Unterschiede. Strukturell unterscheiden sich diese beiden Datentypen nicht voneinander: in beiden F√§llen besteht ein Punkt aus zwei Int Werten.\nDie Gr√∂√üe zusammengesetzter Datentypen # Es gibt auf meinem Rechner 2^64 Werte vom Datentyp Int. F√ºr den Datentyp Point ergeben sich damit 2^64 * 2^64 also 2^128 Werte. Das selbe gilt f√ºr den Datentyp (Int,Int). Solche Datentypen, die sich aus anderen Datentypen zusammensetzen, so dass ihre Gr√∂√üe das Produkt der Gr√∂√üen der beteiligten Datentypen ist, hei√üen Produkttypen. Array-Datentypen und C-Structs sind auch Produkttypen. Ein bisschen komplexer ist es bei Listen und Strings. Mehr dazu weiter unten.\nIn allen herk√∂mmlichen Sprachen kann man Produkttypen definieren, aber oft fehlt die M√∂glichkeit, Summentypen zu definieren. Das sind Datentypen, die sich aus anderen Datentypen zusammensetzen, so dass ihre Gr√∂√üe die Summe der Gr√∂√üen der beteiligten Datentypen ist.\nAlgebraische Datentypen # Algebraische Datentypen (ADTs) vereinen in sich Produkttypen und Summentypen: jeder ADT ist eine Summe von Produkten.\nSummen\nEiner der einfachsten ADTs ist der Datentyp Bool in Haskell:\n-- Haskell data Bool = False | True False und True sind sogenannte Wertekonstruktoren (oder einfach nur Werte). Den Balken m√ºssen wir lesen wie ein exklusives Oder: jeder Wert vom Datentyp Bool ist entweder False oder True. Andere als diese zwei Bool Werte gibt es nicht.\nADTs k√∂nnen beliebig viele Wertekonstruktoren haben:\n-- Haskell data Ampel = Gr√ºn | Gelb | Rot data K√§se = Gouda | Cheddar | Brie | Camembert | Gruy√®re data T = A | B | C | D | E | F | G | H | I | J | K Wir k√∂nnen auch einen ADT mit genau einem Wertekonstruktor definieren:\n-- Haskell data Eindeutig = Einheit Hier hat nur der Wert Einheit den Datentyp Eindeutig. Damit besteht zwischen dem Datentyp und dem Wert eine Eins-zu-eins-Beziehung. Sogar der Spezialfall eines ADT mit keinen Wertekonstruktoren ist m√∂glich. Wir geben einfach keine Wertekonstruktoren an:\n-- Haskell data Nichts Damit hat der Datentyp Nichts keine Werte. Wir haben daher keine M√∂glichkeit, einen Wert vom Datentyp Nichts zu erzeugen oder eine Funktion anzuwenden, die auf Nichts operiert. Leere Datentypen sind nicht nutzlos, aber darauf werde ich hier nicht weiter eingehen. Stattdessen m√∂chte ich auf eine Sache hinweisen, die Verwirrung stiften kann. Betrachte daf√ºr die folgende Typdefinition:\n-- Haskell data Tasche = T√ºte | Beutel | Rucksack | G√ºrteltasche | Tasche Hier definieren wir den Datentyp Tasche mit den Werten T√ºte, Beutel, Rucksack, G√ºrteltasche und Tasche. Es sticht ins Auge, dass der Name Tasche zweimal auftaucht: einmal als der Datentyp Tasche, einmal als der Wertekonstruktor Tasche. F√ºr den Compiler ist das kein Problem. Er unterscheidet streng zwischen Datentypen und Wertekonstruktoren und kann sie nicht verwechseln, auch wenn sie den selben Namen haben. Das Beispiel ist zwar an den Haaren herbeigezogen, aber es ist tats√§chlich manchmal sinnvoll, einem Datentyp und einem seiner Wertekonstruktoren den selben Namen zu geben. Weiter unten wird uns so etwas begegnen.\nWertekonstruktoren mit Feldern\nBisher haben wir einfache Wertekonstruktoren wie False, Gouda, Rucksack, A usw. gesehen. Wertekonstruktoren k√∂nnen aber typisierte Felder haben. Hier ein Beispiel:\n-- Haskell data Lampe = Leuchtet Bool Der Datentyp Lampe hat den Wertekonstruktor Leuchtet mit einem Feld vom Datentyp Bool. Bisher haben wir die Begriffe Wert und Wertekonstruktor als Synonyme behandelt. Das √§ndert sich sobald Felder ins Spiel kommen. Der Wertekonstruktor Leuchtet ist allein noch kein Wert vom Datentyp Lampe. Wir m√ºssen ihn um einen Bool Wert erg√§nzen, um einen Wert vom Datentyp Lampe zu erzeugen.\n-- Haskell Repl \u0026gt; data Lampe = Leuchtet Bool \u0026gt; :type Leuchtet Leuchtet :: Bool -\u0026gt; Lampe \u0026gt; lampeAn = Leuchtet True \u0026gt; :type lampeAn lampeAn :: Lampe Produkte\nWertekonstruktoren k√∂nnen mehr als ein Feld haben. Hier ein Beispiel:\n-- Haskell data Datum = Datum Int Int Int -- Tag Monat Jahr Der Datentyp Datum hat einen Wertekonstruktor Datum mit drei Feldern vom Datentyp Int. So ein Datentyp entspricht den normalen Produkttypen, die wir oben schon kennengelernt haben.\nSummen von Produkten\nIn einem ADT lassen sich Produkte und Summen kombinieren. Hier ein Datentyp mit drei Wertekonstruktoren, die jeweils ein Feld vom Datentyp Bool haben:\n-- Haskell data MyType = X Bool | Y Bool | Z Bool Daraus ergeben sich die folgenden konkreten Werte:\nX False X True Y False Y True Z False Z True Hier ein Datentyp mit f√ºnf Wertekonstruktoren und unterschiedlichen Anzahlen von Feldern:\n-- Haskell data Zubrot = K√§se Bool -- vegan ja/nein | Wurst Bool -- vegan ja/nein | Marmelade Int Int -- Frucht- und Zuckergehalt in % | Margarine | Butter Die Gr√∂√üe algebraischer Datentypen # Die Gr√∂√üe eines ADT ist die Summe der Gr√∂√üen seiner Wertekonstruktoren. Die Gr√∂√üe eines Wertekonstruktors ist das Produkt der Gr√∂√üen seiner Feldtypen. Ein Wertekonstruktor ohne Felder hat die Gr√∂√üe 1. Ein Datentyp ohne Wertekonstruktoren hat die Gr√∂√üe 0.\nWir berechnen die Gr√∂√üe f√ºr ein paar ADTs:\n|Nichts| == 0 |Eindeutig| == |Einheit| == 1 |Bool| == |False| + |True| == 1 + 1 == 2 |Ampel| == |Gr√ºn| + |Gelb| + |Rot| == 1 + 1 + 1 == 3 |Lampe| == |Leuchtet Bool| == |Bool| == 2 |Datum| == |Datum Int Int Int| == |Int| * |Int| * |Int| == 3^64 * 3^64 * 3^64 == 3^192 |MyType| == |X Bool| + |Y Bool| + |Z Bool| == |Bool| + |Bool| + |Bool| == 2 + 2 + 2 == 6 |Zubrot| == |K√§se Bool| + |Wurst Bool| + |Marmelade Int Int| + |Margarine| + |Butter| == |Bool| + |Bool| + |Int| * |Int| + 1 + 1 == 2 + 2 + 2^64 * 2^64 + 1 + 1 == 2^128 + 6 Weiter unten werden wir auch unendlich gro√üe ADTs sehen.\nDer Mehrwert algebraischer Datentypen # Mit ADTs k√∂nnen wir neue Datentypen jeder beliebigen Gr√∂√üe erzeugen und die Datentypen, die wir schon vorliegen haben, sowohl additiv als auch multiplikativ zu neuen Datentypen verkn√ºpfen. F√ºr jede Datenstruktur, die sich so beschreiben l√§sst, k√∂nnen wir einen ADT definieren. Ich m√∂chte an zwei Beispielen zeigen, welchen Mehrwert das hat.\nBeispiel 1: Verkehrsampel\nEin Datentyp f√ºr die drei Zust√§nde einer aktiven Ampel k√∂nnte so definiert sein:\n--Haskell data Ampel = Gr√ºn | Gelb | Rot Viele herk√∂mmliche Sprachen scheitern schon daran, einen genau dreiwertigen Datentyp zu erzeugen.\nWenn wir entscheiden m√ºssen, ob jemand f√ºr das √úberfahren einer Ampel im Stra√üenverkehr einen Bu√ügeldbescheid erhalten soll oder nicht, k√∂nnen wir das wie folgt modellieren:\n-- Haskell bu√ügeldbescheid :: Ampel -\u0026gt; Bool bu√ügeldbescheid ampel = case ampel of Gr√ºn -\u0026gt; False Gelb -\u0026gt; False Rot -\u0026gt; True Hier ist bu√ügeldbescheid eine Funktion von Ampel nach Bool. Die drei Werte des Datentyps Ampel entsprechen den drei Zust√§nden einer aktiven Ampel. Mit anderen als diesen drei Werten m√ºssen wir uns beim Implementieren nicht auseinandersetzen. Stattdessen k√∂nnen wir uns voll und ganz auf das Wesentliche konzentrieren: die Zuordnung der tats√§chlichen Ampelzust√§nde nach Bool. Auch beim Verwenden der Funktion ohne Kenntnis ihrer Implementierung m√ºssen wir uns keine Gedanken √ºber andere als diese drei Werte machen, denn die Funktion akzeptiert nur diese drei und der Compiler sichert das f√ºr uns ab.\nGanz anders sieht das aus, wenn wir bei der Modellierung des selben Sachverhaltes ohne ADTs bzw. ohne Summentypen auskommen m√ºssen. Wir sind dann gezwungen, auf bestehende Datentypen zur√ºckzugreifen. Zum Beispiel so:\n-- Haskell gr√ºn = 0 gelb = 1 rot = 2 bu√ügeldbescheid :: Int -\u0026gt; Bool bu√ügeldbescheid ampel = ampel /= gr√ºn \u0026amp;\u0026amp; ampel /= gelb Man kann so programmieren, aber die Funktion hat jetzt f√ºr den Compiler einen Definitionsbereich aus 2^64 Werten. Drei davon k√ºmmern uns: n√§mlich 0, 1 und 2 bzw. gr√ºn, gelb und rot. Die √ºbrigen 18446744073709551613 Werte sind f√ºr den modellierten Sachverhalt √ºberfl√ºssig. Aber k√∂nnen wir uns darauf verlassen, dass kein anderer Wert an die Funktion √ºbergeben wird? So wie sie jetzt implementiert ist, werden die 18446744073709551613 √ºberfl√ºssigen Werte auf True abgebildet. Das k√∂nnte zur Folge haben, dass Bu√ügeldbescheide an Personen versendet werden, die nicht bei Rot gefahren sind, weil jemand den Aufruf der Funktion vermasselt hat, oder weil jemand die Dokumentation nicht richtig gelesen hat, oder weil die Implementierung sich zwischenzeitlich ge√§ndert hat: bei einem Refactoring wurde der R√ºckgabewert f√ºr die 18446744073709551613 √ºberfl√ºssigen Werte ver√§ndert und schon tritt ein Fehler auf, den es vorher nicht gab.\nHier liegt ein Fehlerpotenzial vor, das es nicht gibt wenn man ADTs verwendet um die Definitions- und Wertebereiche der Funktionen, Prozeduren und Methoden so festzulegen, dass sie genau zum modellierten Sachverhalt passen.\nBeispiel 2: unbekanntes Alter\nStellen wir uns vor, dass wir einen Datentyp f√ºr das Alter von Personen als ganze Zahl in Jahren ben√∂tigen. Es liegt auf der Hand, daf√ºr den Datentyp Int zu verwenden. Noch besser w√§re ein Datentyp f√ºr nat√ºrliche Zahlen, aber darum k√ºmmern wir uns jetzt nicht.\nKomplizierter ist es, wenn wir ber√ºcksichtigen m√ºssen, dass das Alter einer Person unbekannt sein kann. Wie bilden wir das ab? Ich zeige erst, wie hier ein ADT helfen kann. Dann kritisiere ich, wie das in Sprachen ohne ADTs gel√∂st wird. Also, hier mein Vorschlag f√ºr einen passenden Datentyp:\n-- Haskell data Alter = AlterUnbekannt | Alter Int Ein Wert vom Datentyp Alter ist entweder AlterUnbekannt oder Alter mit einem Int Feld. Stellen wir uns die drei Personen Marit, Marta und Max vor. Marit ist 30, Marta ist 11 und von Max kennen wir das Alter nicht.\n-- Haskell maritAlter :: Alter maritAlter = Alter 30 martaAlter :: Alter martaAlter = Alter 11 maxAlter :: Alter maxAlter = AlterUnbekannt Auf diese Weise unterscheiden wir sauber zwischen einem bekannten und einem unbekannten Alter. Eine Funktion, die Altersklassen bestimmt, k√∂nnte so aussehen:\n-- Haskell data Altersklasse = Minderj√§hrig | Vollj√§hrig | AltersklasseUnbekannt altersklasse :: Alter -\u0026gt; Altersklasse altersklasse Alter = case alter of Alter n -\u0026gt; if n \u0026lt; 18 then Minderj√§hrig else Vollj√§hrig AlterUnbekannt -\u0026gt; AltersklasseUnbekannt Schauen wir uns die Altersklassen von Marit, Marta und Max an:\n-- Haskell Repl \u0026gt; altersklasse maritAlter Vollj√§hrig \u0026gt; altersklasse martaAlter Minderj√§hrig \u0026gt; altersklasse maxAlter AltersklasseUnbekannt Dadurch, dass unser Datentyp Alter ganz ausdr√ºcklich auch den Wert AlterUnbekannt hat, m√ºssten wir uns schon besondere M√ºhe geben, um diesen Fall bei der Berechnung der Altersklasse unter den Tisch fallen zu lassen.\nAber wie w√ºrden wir das ohne ADTs modellieren? Hier noch mal der zu modellierende Sachverhalt: wir m√ºssen das Alter von Personen codieren und dabei ber√ºcksichtigen, dass ein Alter unbekannt sein kann. In Sprachen ohne ADTs gibt es f√ºr die Codierung solcher Sonderf√§lle zwei verschiedene L√∂sungsans√§tze.\nAnsatz 1 ohne ADTs: Numerische Fehlercodes\nBilde Sonderf√§lle wie Fehlercodes auf Werte ab, die zum selben Datentyp geh√∂ren wie die modellierte Gr√∂√üe, aber offensichtlich kein Wert der modellierten Gr√∂√üe sind. Das setzt voraus, dass der Datentyp zus√§tzlichen Platz daf√ºr bietet. Ein gutes Beispiel daf√ºr ist die Java String-Methode indexOf, die man verwendet um nach Substrings zu suchen. Wenn der Substring gefunden wurde, wertet indexOf zu dem Index aus, bei dem der Substring beginnt. Wenn der Substring nicht gefunden wurde, wertet indexOf zu -1 aus:\n// Java \u0026quot;abc\u0026quot;.indexof(\u0026quot;c\u0026quot;) // Wertet aus zu: 2 \u0026quot;abc\u0026quot;.indexOf(\u0026quot;d\u0026quot;) // Wertet aus zu: -1 Die Idee dahinter ist, dass Indizes nat√ºrliche Zahlen sind und dass daher mit dem R√ºckgabewert -1 offensichtlich kein Index gemeint sein kann. In unserem Fall k√∂nnte der Ansatz so aussehen:\n-- Haskell maritAlter :: Int maritAlter = 30 martaAlter :: Int martaAlter = 11 maxAlter :: Int maxAlter = -1 Wenn wir jetzt die Altersklassen berechnen und dabei nicht genau aufpassen, k√∂nnte die folgende Funktion zustande kommen:\n-- Haskell data Altersklasse = Minderj√§hrig | Vollj√§hrig altersklasse :: Int -\u0026gt; Altersklasse altersklasse alter = if alter \u0026lt; 18 then Minderj√§hrig else Vollj√§hrig Die Altersklassen f√ºr Marit, Marta und Max sehen dann wie folgt aus:\n-- Haskell Repl \u0026gt; altersklasse maritAlter Vollj√§hrig \u0026gt; altersklasse martaAlter Minderj√§hrig \u0026gt; altersklasse maxAlter Minderj√§hrig Das ist nat√ºrlich Murks. Wir wissen gar nicht, ob Max minderj√§hrig ist, weil wir sein Alter nicht kennen. Der Fehler ist aber nachvollziehbar: bei der Implementierung von altersklasse legen wir fest, dass Personen minderj√§hrig sind wenn ihr Alter in Jahren kleiner als 18 ist, denn genau so ist Minderj√§hrigkeit definiert. Um den Fehler zu vermeiden, m√ºssen wir wissen, dass hier auch negative Zahlen zu ber√ºcksichtigen sind und dass -1 das Fehlen der Altersinformation repr√§sentiert:\n-- Haskell data Altersklasse = Minderj√§hrig | Vollj√§hrig | AltersklasseUnbekannt altersklasse :: Int -\u0026gt; Altersklasse altersklasse alter = if alter \u0026lt; 0 then AltersklasseUnbekannt else if alter \u0026lt; 18 then Minderj√§hrig else Vollj√§hrig Wir gehen hier noch einen Schritt weiter und bilden alle negativen Zahlen auf AltersklasseUnbekannt ab. Dadurch sind wir schon auf der sicheren Seite wenn weitere Fehlercodes dazukommen. Die Altersklassen f√ºr Marit, Marta und Max stimmen jetzt wieder:\n-- Haskell Repl \u0026gt; altersklasse maritAlter Vollj√§hrig \u0026gt; altersklasse martaAlter Minderj√§hrig \u0026gt; altersklasse maxAlter AltersklasseUnbekannt Javas indexOf Methode hat die gleiche Schw√§che. Wenn wir bspw. in vielen Strings den gleichen Substring suchen, um seinen durchschnittlichen Index zu berechnen, d√ºrfen wir nicht vergessen, den Wert -1 gesondert zu verarbeiten. Sonst berechnen wir ein falsches Ergebnis. Besser ist es, wenn wir zwischen der erfolgreichen und der gescheiterten Suche so unterscheiden, dass auch der Compiler diese Unterscheidung absichert. Andernfalls liegt die volle Verantwortung f√ºr diese Unterscheidung bei der Person, die programmiert.\nAnsatz 2 ohne ADTs: Nullreferenzen\nVerwende Referenzdatentypen und stelle fehlende Werte dar als Nullreferenzen. Ein gutes Beispiel daf√ºr ist die Prozedur strstr aus der C-Standard-Bibliothek:\n// C char *result = strstr(myString, mySubstr); Wenn mySubstr in myString enthalten ist, dann enth√§lt result jetzt eine Referenz auf die Speicheradresse der Anfangsposition von mySubstr innerhalb von myString. Andernfalls enth√§lt result jetzt die Nullreferenz NULL.\nIn Sprachen, die es erlauben, Nullreferenzen so zu verwenden, muss man h√∂llisch aufpassen: es kann passieren, dass man glaubt, einen Wert zu verarbeiten obwohl man eine Nullreferenz verarbeitet. Das f√ºhrt leicht zu Laufzeitfehlern. In Haskell, Purescript, etc. kann ich das nicht demonstrieren, weil es in diesen Sprachen keine Referenzdatentypen und keine Nullreferenzen gibt. Deswegen hier ein bisschen Java Code:\n// Main.java class Alter { int wert; public Alter(int wert) { this.wert = wert; } public int get() { return this.wert; } } class Person { public Alter alter; enum Altersklasse { minderj√§hrig, vollj√§hrig } public Altersklasse altersklasse() { if (this.alter.get() \u0026lt; 18) { return Altersklasse.minderj√§hrig; } else { return Altersklasse.vollj√§hrig; } } } class Main { public static void main(String[] args) { Person marit = new Person(); Person marta = new Person(); Person max = new Person(); marit.alter = new Alter(30); marta.alter = new Alter(11); System.out.println(marit.altersklasse()); System.out.println(marta.altersklasse()); System.out.println(max.altersklasse()); } } Ich wickle das Alter einer Person hier in einen Datentyp Alter ein, weil Basisdatentypen wie int in Java keine Referenzdatentypen sind. Das passiert wenn wir das Programm compilieren und ausf√ºhren:\n$ javac Main.java $ java Main vollj√§hrig minderj√§hrig Exception in thread \u0026quot;main\u0026quot; java.lang.NullPointerException at Person.altersklasse(Main.java:21) at Main.main(Main.java:14) Wir haben f√ºr Max kein Alter festgelegt. Sobald wir seine Altersklasse abrufen, terminiert das Programm mit einer NullPointerException. Selbstverst√§ndlich l√§sst sich das beheben, indem wir die Aufz√§hlung Altersklasse und die Methode altersklasse anpassen, so wie wir es auch weiter oben gemacht haben. Die volle Verantwortung daf√ºr, solche Laufzeitfehler zu vermeiden, liegt hier wieder bei der Person, die programmiert.\nWelcher dieser beiden Ans√§tze ist besser? Das kommt darauf an, ob uns die Vermeidung von Laufzeitfehlern oder die Vermeidung falscher Ergebnisse wichtiger ist. Bei der Haskell-Funktion altersklasse :: Alter -\u0026gt; Altersklasse, mit der wir begonnen haben, er√ºbrigt sich diese Abw√§gung: Nullreferenzen gibt es nicht und um das numerische Alter mit einem Fehlercode zu erg√§nzen, f√ºhren wir einen neuen Datentyp ein, der durch zwei Wertekonstruktoren sauber unterscheidet zwischen einem bekannten und einem unbekannten Alter.\nParametrische algebraische Datentypen # Parametriche ADTs sind ADTs, die in ihrer Definition einen sogenannten Typparameter enthalten. Das ist ein Platzhalter, der durch einen konkreten Datentyp ersetzt werden muss, damit aus dem parametrischen ADT ein konkreter Datentyp wird. Solche Datentypen, die erst noch konkretisiert werden m√ºssen, nennt man auch generische Datentypen. Um das Konzept zu demonstrieren, schauen wir uns noch mal den oben definierten Datentyp Alter an. Wir steigen an der Stelle von Haskell auf Purescript um, damit wir weiter unten Record-Literale verwenden k√∂nnen:\n-- Purescript data Alter = AlterUnbekannt | Alter Int Wir haben diesen Datentyp eingef√ºhrt, um zu modellieren, dass das Alter einer Person manchmal bekannt und manchmal unbekannt ist. Aber dieses Problem kann auch bei anderen Daten auftreten. Wir k√∂nnten daf√ºr jedes mal einen spezifischen Datentyp einf√ºhren:\n-- Purescript data Name = NameUnbekannt | Name String data Alter = AlterUnbekannt | Alter Int data Wohnort = WohnortUnbekannt | Wohnort String data Beruf = BerufUnbekannt | Beruf String ... Ein beispielhafter Record f√ºr Marta mit diesen Datentypen k√∂nnte so aussehen:\n-- Purescript marta = { name : Name \u0026quot;Marta\u0026quot; , alter : Alter 11 , wohnort : WohnortUnbekannt , beruf : BerufUnbekannt } Wir m√ºssen aber nicht jeden Datentyp separat auf diese Weise erweitern. Stattdessen k√∂nnen wir einen generischen Datentyp festlegen, der jeden existierenden Datentyp um die M√∂glichkeit eines fehlenden Wertes erweitert:\n-- Purescript data Vielleicht a = Unbekannt | Wert a Damit k√∂nnen wir jeden Datentyp so erweitern, dass ein Wert dieses Typs entweder vorhanden oder abhanden ist. Wenn wir das Alter einer Person kennen, sieht das so aus:\n-- Purescript alter :: Vielleicht Int alter = Wert 23 Wenn wir das Alter nicht kennen, sieht das so aus:\n-- Purescript alter :: Vielleicht Int alter = Unbekannt Das gleiche Spiel mit dem Wohnort:\n-- Purescript wohnort :: Vielleicht String wohnort = Wert \u0026quot;Leipzig\u0026quot; Oder wenn der Wohnort unbekannt ist:\n-- Purescript wohnort :: Vielleicht String wohnort = Unbekannt Beachte, dass das Alter den Datentyp Int hat aber der Wohnort den Datentyp String. Trotzdem konnten wir in beiden F√§llen den generischen Datentyp Vielleicht a einsetzen. Wir haben damit den Datentyp Int auf Vielleicht Int und den Datentyp String auf Vielleicht String erweitert. Ein ganzer Record f√ºr Marta k√∂nnte so aussehen:\n-- Purescript marta = { name : Wert \u0026quot;Marta\u0026quot; , alter : Wert 11 , wohnort : Wert \u0026quot;Leipzig\u0026quot; , beruf : Wert \u0026quot;Sch√ºlerin\u0026quot; } Damit sind die vier spezifischen Datentypen, die wir oben definiert haben, √ºberfl√ºssig, weil wir sie ersetzen konnten durch einen einzigen generischen Datentyp, der die selbe Aufgabe erf√ºllt.\nIn der Praxis w√ºrde man einen Datentyp wie Vielleicht a nicht definieren, sondern den Datentyp Maybe a verwenden, der genau f√ºr diesen Zweck schon vordefiniert ist und die selbe Struktur hat. Zum Vergleich hier die beiden Datentypen:\n-- Purescript data Vielleicht a = Unbekannt | Wert a data Maybe a = Nothing | Just a Es geh√∂rt zum guten Programmierstil, die vordefinierten Datentypen zu verwenden wenn die Struktur passt. Das erh√∂ht die Lesbarkeit. Es kann zwar manchmal sinnvoll sein, trotzdem eigene Datentypen zu verwenden, um zu verdeutlichen, worum es geht, aber je mehr man beim Lesen von Code schon kennt, desto verst√§ndlicher ist der Code.\nUnendlich gro√üe Datentypen # Bisher haben wir nur ADTs mit endlicher Gr√∂√üe betrachtet. Es gibt aber auch ADTs, die unendlich gro√ü sind. Das ist zum Beispiel der Fall bei ADTs, die rekursiv √ºber sich selbst definiert sind. Ein gutes Beispiel daf√ºr sind verkettete Listen:\n-- Purescript List a = Nil | Cons a ( List a ) Nil ist der gebr√§uchliche Name f√ºr die leere Liste. Das hat historische Gr√ºnde. Cons nimmt einen Wert und eine Liste und konstruiert daraus wieder eine Liste. Die Idee dabei ist, dass man mit der leeren Liste beginnt und von ihr ausgehend Cons verwendet und durch das sukzessive Hinzuf√ºgen weiterer Werte immer gr√∂√üere Listen konstruiert. Hier demonstrieren wir schrittweise den Aufbau einer Liste mit den ersten Ziffern der Kreiszahl Pi 3,1415\u0026hellip;\n-- Purescript list0 = Nil list1 = Cons 5 Nil list2 = Cons 1 ( Cons 5 Nil ) list3 = Cons 4 ( Cons 1 ( Cons 5 Nil ) ) list4 = Cons 1 ( Cons 4 ( Cons 1 ( Cons 5 Nil ) ) ) list5 = Cons 3 ( Cons 1 ( Cons 4 ( Cons 1 ( Cons 5 Nil ) ) ) ) Haskell unterst√ºtzt f√ºr verkettete Listen eine kompaktere und freundlichere Syntax, mit der man z.B. list5 schreiben kann als [3,1,4,1,5]. Aber letztlich erfolgt die Konstruktion von verketteten Listen auch in Haskell genau so wie oben beschrieben.\nList a ist generisch (bzw. parametrisch). Diese Beispiele haben allesamt den Datentyp List Int. Nat√ºrlich k√∂nnen wir auch Listen von Bools oder Floats oder Strings etc. konstruieren. Die Werte einer Liste m√ºssen aber allesamt den selben Datentyp haben.\nAus der Definition des generischen Listendatentyps folgt, dass man aus einer Liste der Gr√∂√üe n immer eine Liste der Gr√∂√üe n+1 konstruieren kann indem man noch ein Element hinzuf√ºgt. Daraus ergibt sich, dass Listendatentypen unendlich gro√ü sind. Der Datentyp String ist in Standard-Haskell ein Typalias f√ºr List Char und damit auch unendlich gro√ü. In Purescript werden Strings wahrscheinlich irgendwie auf Javascript-Strings abgebildet. Auch davon gibt es unendlich viele, da man sie durch Verkettung beliebig verl√§ngern kann.\nEinfache Datentypen sind ADTs # Ich habe es hier noch nicht erw√§hnt, aber bestimmt ist es schon aufgefallen: die Namen von Datentypen und von Wertekonstruktoren in einer Typdefinition mit dem data Schl√ºsselwort beginnen in Haskell und in Purescript immer mit einem Gro√übuchstaben. In Elm ist es auch so, mit dem Unterschied, dass das Schl√ºsselwort in Elm nicht data sondern type ist.\nW√§hrend f√ºr den Datentyp Bool mit den Werten False und True in Haskell eine normale Typdefinition vordefiniert ist, ist der Datentyp Boolean mit den Werten false und true in Purescript in den Compiler integriert. Purescript ist daf√ºr gemacht, nach Javascript zu compilieren. Um die zu √ºberbr√ºckende Kluft zwischen den Purescript-Datentypen und den Javascript-Datentypen, die nach der Compilation √ºbrigbleiben, m√∂glichst klein zu halten, orientieren sich die vordefinierten Datentypen in Purescript an den Datentypen, die auch in Javascript verf√ºgbar sind. Deswegen gibt es in Purescript statt Bool den Datentyp Boolean mit den Werten false und true, die vom Compiler in die gleichnamigen Javascript-Werte false und true √ºbersetzt werden. Das gleiche macht der Purescript-Compiler mit Zahlenliteralen, Arrays und Records.\nTrotz der Sonderbehandlung durch den Compiler, h√§tte man die Wahrheitswerte auch in Purescript False und True nennen k√∂nnen. Ich vermute, dass man sich bewusst f√ºr die Kleinschreibung entschieden hat, um kenntlich zu machen, dass es sich um keine gew√∂hnlichen Wertekonstruktoren aus einer data Typdefinition handelt.\nEs gibt noch mehr vordefinierte Datentypen \u0026ndash; auch in Haskell \u0026ndash; deren Werte nicht √ºber eine herk√∂mmliche Typdefinition mit Wertekonstruktoren erzeugt worden sind, sondern auf besondere Weise vom Compiler unterst√ºtzt werden. Die numerischen Datentypen sind das beste Beispiel daf√ºr. Eine Sonderbehandlung numerischer Datentypen und Werte durch den Compiler ist schon f√ºr die syntaktische Unterst√ºtzung der gew√∂hnlichen Zahlenliterale wie -123.45, 0.0 und 99999 n√∂tig, aber auch f√ºr die effiziente Arithmetik auf diesen Datentypen.\nIn Haskell kommt noch dazu, dass Zahlenliterale wie 1 und 1.0 √ºberladen sind. 1 kann in Haskell sowohl f√ºr den Int Wert 1 als auch f√ºr den Float wert 1.0 stehen. Es kommen sogar noch weitere Datentypen in Frage:\n-- Haskell Repl \u0026gt; 1 :: Int 1 \u0026gt; 1 :: Integer 1 \u0026gt; 1 :: Float 1.0 \u0026gt; 1 :: Double 1.0 \u0026gt; import Numeric.Natural \u0026gt; 1 :: Natural 1 Integer ist ein Datentyp f√ºr ganze Zahlen, der beliebig gro√üe Zahlen aufnehmen kann, solange der Speicherplatz es zul√§sst. Natural ist ein Datentyp f√ºr nat√ºrliche Zahlen. Zahlenliterale in Gleitkommaschreibweise sind in Haskell ebenso √ºberladen:\n-- Haskell Repl \u0026gt; 1.0 :: Int 1 \u0026gt; 1.0 :: Integer 1 \u0026gt; 1.0 :: Float 1.0 \u0026gt; 1.0 :: Double 1.0 \u0026gt; import Numeric.Natural \u0026gt; 1.0 :: Natural 1 Trotz ihrer Besonderheiten, k√∂nnen wir solche Datentypen auch als ADTs auffassen. Die Wahrheitswerte false und true werden in Purescript zwar klein geschrieben, aber das ist nur Syntax. Davon abgesehen k√∂nnen wir komplett ignorieren, dass der Datentyp Boolean nicht auf einer herk√∂mmlichen data Typdefinition basiert. Es folgt daraus nichts, worauf wir beim Programmieren achtgeben m√ºssten. So ist es auch mit den numerischen Datentypen: Zahlenliterale wie -3.1415 und 42 sind zwar keine gew√∂hnlichen Wertekonstruktoren, aber wir k√∂nnen jeden numerischen Datentyp auffassen als einen Summentyp mit all seinen Werten als Wertekonstruktoren ohne Typfelder:\n-- Pseudo-Haskell data Natural = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | ... Prinzipiell k√∂nnten wir die ganzen numerischen Datentypen und die gesamte Zahlenarithmetik auch aus gew√∂hnlichen data Typdefinitionen nachbauen. Wir m√ºssen uns daf√ºr nur streng an die Konstruktionsregeln halten. F√ºr nat√ºrliche Zahlen sind das die Peano-Axiome. Ein selbstgebauter Datentyp f√ºr nat√ºrliche Zahlen k√∂nnte so aussehen:\n-- Haskell data Nat = Null | Nachfolger Nat plus :: Nat -\u0026gt; Nat -\u0026gt; Nat plus a b = case a of Nachfolger n -\u0026gt; plus n ( Nachfolger b ) Null -\u0026gt; b mal :: Nat -\u0026gt; Nat -\u0026gt; Nat mal a b = case a of Null -\u0026gt; Null Nachfolger Null -\u0026gt; b Nachfolger n -\u0026gt; plus b ( mal n b ) F√ºr fast alle praktischen Anwendungen w√§re das v√∂llig unbrauchbar. Ohne die spezielle Syntax f√ºr Zahlenliterale w√§re es sehr sehr umst√§ndlich und m√ºhsam, Zahlen aufzuschreiben und zu lesen. Die Zahlenarithmetik w√§re damit unendlich langsam. Worum es mir hier geht, ist, dass sich numerische Datentypen, Arrays, Records, Strings usw. zumindest rein formal auch als algebraische Datentypen auffassen lassen. Das verdeutlicht, wie flexibel ADTs sind: jeder Datentyp, der sich als ein Summentyp aus Produkttypen darstellen l√§sst, kann als ADT beschrieben werden.\nIsomorphismen und Aliase # Bisher haben wir neue Datentypen mit dem data Schl√ºsselwort definiert. Wir k√∂nnten es dabei belassen. Es gibt aber noch zwei weitere Schl√ºsselw√∂rter, mit denen sich Datentypen definieren lassen: newtype und type.\nIsomorphismen\nMit dem newtype Schl√ºsselwort lassen sich neue Datentypen definieren, die genau einen Wertekonstruktor mit genau einem Feld haben. Damit ist newtype auf den ersten Blick √ºberfl√ºssig, denn dasselbe k√∂nnen wir auch mit dem data Schl√ºsselwort erledigen:\n-- Haskell data T1 = K1 Bool newtype T2 = K2 Bool Wenn man dasselbe auch mit dem data Schl√ºsselwort machen kann, warum gibt es dann f√ºr diesen Spezialfall ein zus√§tzliches Schl√ºsselwort? Um das beanworten zu k√∂nnen, m√ºssen wir wissen, dass die Verwendung von Datentypen mit gewissen Laufzeitkosten verbunden ist. Beispielsweise einen Int Wert in einen Maybe Kontext zu stecken und an anderer Stelle wieder aus diesem Maybe Kontext zu befreien: das sind Rechenoperationen, die zur Laufzeit des Programms stattfinden und ein kleines bisschen Speicher und Rechenzeit kosten. Wir nehmen das normalerweise gern in Kauf, weil uns ein korrektes Programm ohne Laufzeitfehler in den meisten F√§llen viel wichtiger ist als ein Programm, das m√∂glichst schnell und speichereffizient arbeitet, aber der Sonderfall eines Datentyps T aus genau einem Wertekonstruktor mit genau einem Feld ist hier deswegen interessant, weil bei so einem Datentyp eine Eins-zu-eins-Beziehung zwischen den Werten von T und den Werten des Feldtyps besteht. Hier ein Beispiel:\n-- Haskell data WrapInt = Wrap Int Dann gilt die Eins-zu-eins-Beziehung:\n... Wrap -3 \u0026lt;--\u0026gt; -3 Wrap -2 \u0026lt;--\u0026gt; -2 Wrap -1 \u0026lt;--\u0026gt; -1 Wrap 0 \u0026lt;--\u0026gt; 0 Wrap 1 \u0026lt;--\u0026gt; 1 Wrap 2 \u0026lt;--\u0026gt; 2 Wrap 3 \u0026lt;--\u0026gt; 3 Wrap 4 \u0026lt;--\u0026gt; 4 Wrap 5 \u0026lt;--\u0026gt; 5 Wrap 6 \u0026lt;--\u0026gt; 6 Wrap 7 \u0026lt;--\u0026gt; 7 ... In der Mathematik nennt man so eine Eins-zu-eins-Beziehung einen Isomorphismus. Wenn ein Isomorphismus zwischen Datentypen besteht, ist es schade um den Speicher und die Rechenzeit, die es zur Laufzeit des Programms kostet, Werte zwischen diesen Datentypen zu konvertieren. Hier kommt newtype ins Spiel. Ein Beispiel:\n-- Haskell newtype Password = Password String Es kann sinnvoll sein, f√ºr Passw√∂rter einen eigenen Datentyp einzuf√ºhren. Am Ende ist nat√ºrlich jedes Passwort einfach nur ein String, aber wenn wir auf der Typebene zwischen String und Password streng unterscheiden, k√∂nnen wir z.B. die Erzeugung von schlechen Passw√∂rtern verhindern. Daf√ºr legen wir ein eigenes Modul an, das den Datentyp Password und bspw. eine sorgf√§ltig geschriebene Funktion makePassword : IO Password enth√§lt. Der entscheidende Trick ist, dass wir den Wertekonstruktor Password nicht exportieren. Dadurch ist Code au√üerhalb dieses Moduls gezwungen, die Funktion makePassword zu verwenden, um an einen Password Wert zu kommen.\nWir k√∂nnen semantisch (fast) exakt dasselbe auch mit dem data Schl√ºsselwort erreichen, aber wenn wir das newtype Schl√ºsselwort verwenden, entfernt der Compiler alle Password Wertekonstruktoren, so dass zur Laufzeit des Programms nur noch gew√∂hnliche String Werte √ºbrigbleiben. Dadurch entfallen der Speicher und die Rechenzeit, die es sonst zur Laufzeit des Programms gekostet h√§tte, Werte zwischen diesen Datentypen zu konvertieren.\n√úbrigens gibt es doch einen semantischen Unterschied zwischen data und newtype, der die Auswertungsstrategie betrifft: Wertekonstruktoren werden bei data verz√∂gert ausgewertet und bei newtype strikt ausgewertet. Was das bedeutet, m√∂chte ich hier nicht erl√§utern. Der Text ist schon lang genug und der Unterschied ist ohnehin marginal: beide Auswertungsstrategien f√ºhren auf den gleichen Wert, wenn sie erfolgreich auswerten. Es gibt aber F√§lle in denen die verz√∂gerte Auswertung Erfolg hat aber die strikte Auswertung scheitert. Daher der semantische Unterschied.\nAliase\nDas type Schl√ºsselwort f√ºhrt einen Typalias bzw. ein Typsynonym ein. Das ist einfach nur ein weiterer Name f√ºr einen existierenden Datentyp. Beispielsweise sind herk√∂mmliche Strings in Haskell nichts weiter als verlinkte Listen von Char Werten. Entsprechend ist der Datentyp String wie folgt definiert:\n-- Haskell type String = List Char Das Beispiel stimmt nicht ganz: der Datentyp List Char wird in idiomatischem Haskell als [Char] geschrieben. Darauf m√∂chte ich hier aber nicht n√§her eingehen. Leider gibt es in Haskell ein paar Schrulligkeiten wie diese, die die Sprache unn√∂tig und ohne substaniellen Mehrwert verkomplizieren. Deswegen bin ich wirklich froh, dass es mittlerweile Alternativen wie Purescript gibt.\nTypklassen # Typklassen werden unterst√ºtzt in Haskell und in Purescript. Sie haben nichts zu tun mit Klassen in der OOP. Ein Konzept aus anderen Sprachen, das mit Typklassen vergleichbar ist, sind Interfaces. Jede Typklasse benennt eine Reihe von Funktionen. Ein Datentyp kann zu einer Typklasse hinzugef√ºgt werden, wenn er alle Funktionen der Typklasse implementiert. Hier ein Beispiel f√ºr eine Typklasse mit einer zu implementierenden Funktion:\n-- Purscript class Eq a where eq :: a -\u0026gt; a -\u0026gt; Boolean Ein Datentyp a der Klasse Eq muss also die Funktion eq implementieren, die zwei Werte vom Datentyp a aufnimmt und einen Boolean Wert berechnet. Eq (f√ºr equality) ist sowohl in Purescript als auch in Haskell eine vordefinierte Typklasse f√ºr die Datentypen, auf denen die Gleichheitsfunktion eq bzw. der Gleichheitsoperator == gegeben sein soll.\nEine Funktion, die wie eq auf mehreren Datentypen operieren kann, nennt man eine polymorphe Funktion. Wenn der Polymorphismus √ºber Typklassen hergestellt wird, spricht man von Typklassenpolymorphismus. Generisch, parametrisch und polymorph sind hier eng verwandte Begriffe. Wenn es um Datentypen geht, spricht man von generischen oder parametrischen Datentypen. Bei Funktionen spricht man von generischen oder polymorphen Funktionen.\nDen Code f√ºr die Eq Typklasse im Purescript Prelude k√∂nnen wir hier nachlesen:\nhttps://github.com/purescript/purescript-prelude/blob/v6.0.1/src/Data/Eq.purs#L35-L36\nEr stimmt mit der oben angegebenen Definition √ºberein. Direkt darunter befindet sich die Definition f√ºr den Gleichheitsoperator:\ninfix 4 eq as == Die Zeile legt fest, dass der Infix-Operator == ein Alias f√ºr die Funktion eq ist und in der Operatorrangfolge an vierter Stelle steht. Wenn == ein Alias f√ºr eq ist und eq eine Funktion der Typklasse Eq ist, dann muss ein Datentyp die Klasse Eq implementieren, damit der Operator == f√ºr seine Werte verf√ºgbar ist. Probieren wir das aus:\n-- Purescript Repl \u0026gt; 123 == 123 true \u0026gt; 123 == 124 false \u0026gt; \u0026quot;abc\u0026quot; == \u0026quot;abc\u0026quot; true \u0026gt; \u0026quot;abc\u0026quot; == \u0026quot;bcd\u0026quot; false \u0026gt; false == false true \u0026gt; false == true false Demnach implementieren die Datentypen Int, String und Boolean die Typklasse Eq. Unser selbst definierter Datentyp Bool implementiert Eq noch nicht:\n-- Purescript Repl \u0026gt; data Bool = False | True \u0026gt; False == False ... No type class instance was found for Data.Eq.Eq Bool ... Das k√∂nnen wir aber mit einer Instanzdeklaration nachholen. Mit einer Instanzdeklaration f√ºgt man einen Datentyp zu einer Typklasse hinzu. Anschlie√üend kann man die Funktionen und Operatoren der Typklasse auf Werte von diesem Datentyp anwenden:\n-- Purescript instance Eq Bool where eq a b = case [a,b] of [False,False] -\u0026gt; true [True,True] -\u0026gt; true _ -\u0026gt;false -- Purescript Repl \u0026gt; False == False true Damit ist gekl√§rt, was Typklassen sind: ein Formalismus um polymorphe Funktionen zu beschreiben. Oft h√§ngt an den Funktionen einer Typklasse eine bestimmte Erwartungshaltung hinsichtlich ihrer Semantik, die vom Typsystem nicht erfasst wird. Beispielsweise h√§tten wir eq auch so angeben k√∂nnen:\n-- Purescript eq a b = case [a,b] of [False,False] -\u0026gt; False [True,True] -\u0026gt; False _ -\u0026gt;True Damit w√ºrde eq nicht mehr auf Gleichheit pr√ºfen sondern auf Ungleichheit. Der Compiler w√ºrde die Definition trotzdem akzeptieren, weil der Datentyp passt. Aber der Gleichheitsoperator == w√ºrde sich f√ºr diesen Datentyp anders verhalten als erwartet und damit f√ºr reichlich Verwirrung sorgen.\nMan kann zwischen Typklassen auch Abh√§ngigkeiten definieren:\n-- Purescript class (A T, B T, C T) \u0026lt;= D T ... Das bedeutet, dass ein Datentyp T nur dann zur Typklasse D geh√∂ren kann, wenn er auch zu den Typklassen A, B und C geh√∂rt. In Haskell sind solche Abh√§ngigkeiten auch m√∂glich. Die Syntax ist fast identisch. Nur der Doppelpfeil wird in Haskell umgekehrt notiert: =\u0026gt;. Wenn links vom Pfeil nur eine Typklasse steht, k√∂nnen die Klammern entfallen.\nElm unterst√ºtzt keine Typklassen. In Haskell und Purescript sind zum Beispiel die arithmetischen Operatoren auf den verschiedenen numerischen Datentypen √ºber Typklassen implementiert:\n-- Purescript Repl \u0026gt; :type (+) forall (a :: Type). Semiring a =\u0026gt; a -\u0026gt; a -\u0026gt; a \u0026gt; :type (-) forall (a :: Type). Ring a =\u0026gt; a -\u0026gt; a -\u0026gt; a \u0026gt; :type (*) forall (a :: Type). Semiring a =\u0026gt; a -\u0026gt; a -\u0026gt; a \u0026gt; :type (/) forall (a :: Type). EuclideanRing a =\u0026gt; a -\u0026gt; a -\u0026gt; a Demnach ist der Operator + in Purescript auf den Datentypen gegeben, die zur Typklasse Semiring geh√∂ren, der Operator - auf den Datentypen, die zur Typklasse Ring geh√∂ren, usw. Sowohl Haskell als auch Purescript haben eine mathematisch interessante Typklassenhierarchie, aber wenn man sich f√ºr Begriffe wie Halbring, Ring und euklidischer Ring nicht interessiert, kann man sie ignorieren: sich mit diesen Begriffen herumzuschlagen, ist keine Voraussetzung daf√ºr, in diesen Sprachen zu programmieren!!!\nTypische Idiome der funktionalen Programmierung, wie map, foldr, foldl, traverse, oder der monadische bind Operator \u0026gt;\u0026gt;= sind ebenfalls √ºber entsprechende Typklassen als polymorphe Funktionen definiert. Hier operiert map auf zwei verschiedenen Datentypen:\n-- Purescript Repl \u0026gt; map (_*2) [1,2,3] [2,4,6] \u0026gt; import Data.Maybe \u0026gt; map (_*2) (Just 3) (Just 6) Es kommt selten vor, dass ich eigene Typklassen schreibe, weil es mir produktiver erscheint, konkreten Code zu schreiben und dabei nicht dar√ºber nachzudenken, wo sich strukturelle √úbereinstimmungen verbergen k√∂nnten, aus denen sich vielleicht polymorphe Funktionen ableiten lassen. Probleme, bei denen ich Typklassen vielleicht einsetzen w√ºrde, sind Serialisierung und Persistenz. Beispielsweise k√∂nnte die Serialisierung und Deserialisierung zwischen einem Datentyp a und Json √ºber zwei polymorphe Funktionen ablaufen:\n-- Purescript class JsonSerializable a where toJson :: a -\u0026gt; String fromJson :: String -\u0026gt; Maybe a Dazu w√ºrde ich noch fordern, dass f√ºr alle Instanzdeklarationen gelten sollte:\nfromJson ( toJson value ) == Just value map toJson ( fromJson string ) == Just string Diese Regeln kann man zwar nicht vom Compiler absichern lassen, aber eine JsonSerializable Instanz, die sie nicht einh√§lt, ist offensichtlich unbrauchbar.\nEine Typklasse f√ºr die Persistenz in einer Datenbank k√∂nnte so aussehen:\n-- Haskell class Db a where insert :: a -\u0026gt; IO String update :: String -\u0026gt; a -\u0026gt; IO () read :: String -\u0026gt; IO ( Maybe a ) Ich muss unbedingt dazusagen, dass ich mir dar√ºber maximal drei Minuten Gedanken gemacht habe. Es ist sehr wahrscheinlich, dass ich hier irgendetwas entscheidendes vergessen oder √ºbersehen habe. Als Beispiel sollte uns das an dieser Stelle trotzdem gen√ºgen. Ich beschreibe kurz die Funktionen:\ninsert persistiert einen Wert vom Datentyp a als neuen Record in der Datenbank und liefert einen String, den wir sp√§ter als Schl√ºssel verwenden k√∂nnen, um diesen Wert zu aktualisieren oder wieder auszulesen. update nimmt einen String als Schl√ºssel entgegen und aktualisiert den entsprechenden Record in der Datenbank mit einem Wert vom Datentyp a. read nimmt einen Schl√ºssel entgegen und liefert den entsprechenden Wert vom Datentyp a aus der Datenbank. Weil wir nicht garantieren k√∂nnen, dass jeder Schl√ºssel auf einen g√ºltigen Record in der Datenbank verweist, ist dieser Wert in einen Maybe Kontext eingeschlossen. Ich h√§tte wirklich Lust, herauszufinden, ob das ein gutes Design oder zu naiv ist, aber erst muss ich diesen Text fertig schreiben.\nIm n√§chsten Abschnitt gehe ich auf Multiparameter-Typklassen ein. Vorher m√∂chte ich noch eine Bemerkung zu Typklassen im Allgemeinen loswerden: Typklassenpolymorphie ist ein produktives Konzept, aber es lohnt sich nicht immer, auf Typklassen und polymorphe Funktionen zu setzen. Wenn die Polymorphie einem formalen Kalk√ºl folgt, so wie es bei der Typklasse Eq und bei den arithmetischen Operationen der Fall ist, oder wenn es darum geht, Datentypen um Funktionalit√§t zu erweitern wie bei der Typklasse JsonSerialize, dann sind Typklassen sinnvoll. Aber man sollte nicht versuchen, Typklassenpolymorphie zu erzwingen: manchmal ist der Code besser ohne Typklassen. Elm kommt ganz ohne Typklassen aus.\nMultiparameter-Typklassen # Eine Vorbemerkung: Man muss bei den Programmierkonzepten der Typebene, die ich hier vorstelle, ein bisschen darauf achten, dass man den Ball flach h√§lt. Wenn man mit einem vordefinierten Datentyp gut auskommt, muss man daf√ºr keinen ADT definieren. Wenn es keinen Grund daf√ºr gibt, einen parametrischen ADT zu definieren, sollte man es bei einem parameterlosen ADT belassen. Wenn man sich nicht ganz sicher ist, ob man eine polymorphe oder mehrere monomorphe Funktionen definieren sollte, ist es besser, auf Polymorphie zu verzichten. Dieser Appell gilt umso mehr f√ºr die Konzepte, die jetzt folgen. Mit einem guten Verst√§ndnis f√ºr ADTs, parametrische ADTs und einfache Typklassen ist man schon sehr gut aufgestellt. Solange man diese Konzepte nicht richtig verinnerlicht hat, muss man sich mit den Konzepten, die jetzt noch folgen, nicht befassen.\nTypklassen k√∂nnen mehr als einen Typparameter haben. Auf die Weise k√∂nnen die polymorphen Funktionen einer Typklasse Beziehungen zwischen Datentypen beschreiben. Die Typklasse Db von gerade eben bietet sich an, um zu zeigen, wof√ºr das n√ºtzlich sein kann. Mich st√∂rt an dieser Typklasse ein bisschen, dass der Datentyp f√ºr die Schl√ºssel auf String festgelegt ist. Warum nicht Int? Oder ein spezieller Datentyp Uuid f√ºr sogenannte Universally Unique Identifiers? Also erweitern wir diese einfache Typklasse zu einer Typklasse mit zwei Typparametern:\n-- Haskell class Db key value where insert :: value -\u0026gt; IO key update :: key -\u0026gt; value -\u0026gt; IO () read :: key -\u0026gt; IO ( Maybe value ) Auf diese Weise sind wir f√ºr die Schl√ºssel nicht auf den Datentyp String festgelegt, sondern k√∂nnen daf√ºr einen Datentyp frei w√§hlen. Hier noch ein Beispiel f√ºr eine Multiparameter-Typklasse aus dem Purescript-Buch:\n-- Purescript class Stream stream element where uncons :: stream -\u0026gt; Maybe { head :: element , tail :: stream } Die Idee dabei ist, dass ein Wert vom Datentyp stream ein Datenstrom aus Werten vom Datentyp element ist. Die Funktion uncons trennt diesen Datenstrom auf in den ersten Wert (head) und den Rest des Datenstroms (tail). Auf die Weise lassen sich die Werte in einem Datenstrom durch wiederholtes Aufrufen von uncons der Reihe nach verarbeiten. Sobald der Datenstrom leer ist, liefert uncons den Wert Nothing. Wir f√ºgen die Datentypen String und Char zur Typklasse Stream hinzu, indem wir eine passende uncons Funktion angeben:\n-- Purescript instance Stream String Char where uncons = String.uncons Dass die Funktion String.uncons hier genau passt, ist g√ºnstig f√ºr uns. Als n√§chstes f√ºgen wir den generischen Datentyp Array a zusammen mit dem entsprechenden Datentyp a zur Typklasse Stream hinzu. Auch hier gibt es wieder eine passende uncons Funktion f√ºr Arrays:\n-- Purescript instance Stream ( Array a ) a where uncons = Array.uncons Jetzt k√∂nnen wir mit der polymorphen uncons Funktion der Stream Typklasse sowohl Char Werte aus String Datenstr√∂men als auch a Werte aus Array a Datenstr√∂men entnehmen.\nFunktionale Abh√§ngigkeiten # Es w√§re jetzt naheliegend, aus uncons eine tail Funktion abzuleiten:\n-- Purescript tail :: String -\u0026gt; Maybe String tail stream = map _.tail ( uncons stream ) Wir wenden erst uncons auf das Argument an. Dann wenden wir die Feldfunktion _.tail auf das Zwischenergebnis an. Das Zwischenergebnis ist in einen Maybe Kontext eingebettet. Deswegen m√ºssen wir map einsetzen, um die Feldfunktion auf den Wert im Kontext anzuwenden. Das ist eine sinnvolle Definition. Trotzdem ist der Compiler nicht mit ihr zufrieden:\nNo type class instance was found for Main.Stream String t Was funktioniert hier nicht? Daf√ºr m√ºssen wir (ganz grob) verstehen, wie der Compiler mit polymorphen Funktionen umgeht. Die beiden Instanzdeklarationen haben wir nicht ohne Grund hinzugef√ºgt. Wenn wir die polymorphe Funktion uncons aufrufen, versucht der Compiler, die passenden Datentypen zu ermitteln, um pr√ºfen zu k√∂nnen, ob ihm f√ºr diese Datentypen eine Instanzdeklaration bekannt ist. Wir wollen hier nat√ºrlich auf die Instanz Stream String Char hinaus. Ein Blick in obige Fehlermeldung verr√§t, dass die Typinferenz bei Stream String t h√§ngen bleibt. Der Compiler ist offenbar nicht in der Lage, f√ºr den Typparameter t zu inferieren, dass es sich um den Datentyp Char handeln muss. Ich wei√ü nicht, wo genau es klemmt, aber es stimmt, dass wir bei der Definition unserer neuen tail Funktion dem Compiler nirgendwo einen Hinweis darauf geben, dass es sich bei t um Char handeln muss.\nWenn wir das polymorphe uncons durch String.uncons ersetzen, ist der Compiler zufrieden, aber dann k√∂nnen wir uns die Typklasse gleich sparen. Wenn wir uncons um eine Typannotation erg√§nzen, die ausdr√ºcklich auf Char hinweist, ist der Compiler ebenfalls zufrieden:\n-- Purescript tail :: String -\u0026gt; Maybe String tail stream = do let f :: String -\u0026gt; Maybe { head :: Char , tail :: _ } f = uncons map _.tail ( f stream ) Aber sch√∂n oder sinnvoll ist das auch nicht. Welchen Wert hat die Typklassenpolymorphie, wenn wir sie erst einf√ºhren und sie dann zur H√§lfte wieder zur√ºcknehmen?\nInteressanterweise k√∂nnen wir den Compiler auch zufriedenstellen, indem wir die Definition der Typklasse Stream wie folgt anpassen:\n-- Purescript class Stream stream element | stream -\u0026gt; element where uncons :: stream -\u0026gt; Maybe { head :: element , tail :: stream } Hinzugekommen ist der Teil | stream -\u0026gt; element vor dem where Schl√ºsselwort. Man nennt das eine funktionale Abh√§ngigkeit. Wir vereinbaren dadurch mit dem Compiler, dass sich aus dem Datentyp f√ºr den Typparameter stream stets eindeutig ergeben muss, welcher Datentyp f√ºr den Typparameter element einzusetzen ist. Das hat bei mir zun√§chst f√ºr Kopfkratzen gesorgt. Dann ist mir aufgefallen, dass wir nur eine einzige Instanzdeklaration der Form Stream String ... angegeben haben, n√§mlich Stream String Char. Damit ist die funktionale Abh√§ngigkeit stets erf√ºllt wenn wir f√ºr stream den Datentyp String einsetzen: f√ºr element kommt dann nur der Datentyp Char in Frage. Die andere Instanzdeklaration Stream ( Array a ) a erf√ºllt ebenfalls die Forderung nach funktionaler Abh√§ngigkeit, denn wenn Array a (und damit stream) auf einen konkreten Datentyp festgelegt ist, dann ist auch a selbst (und damit element) eindeutig auf einen Datentyp festgelegt. Der Compiler ist damit zufriedengestellt solange wir keine weiteren Instanzdeklarationen hinzuf√ºgen, die diese Eindeutigkeit verletzen.\nVerallgemeinerte algebraische Datentypen (GADTs) # Weiter oben haben wir schon eine Verallgemeinerung der einfachen ADTs kenngenlernt: die parametrischen ADTs. Verallgemeinerung bedeutet, dass das Verallgemeinerte zum Spezialfall des Verallgemeinernden wird. Bei den parametrischen ADTs besteht der Spezialfall eines einfachen, parameterlosen ADT darin, dass die Anzahl seiner Typparameter 0 ist: jeder parameterlose ADT ist ein parametrischer ADT mit 0 Typparametern!\nDie Sprache wird bei solchen Dingen oft etwas ungenau. Wenn wir von einem parametrischen ADT sprechen, meinen wir nat√ºrlich einen ADT mit mindestens einem Typparameter, sonst m√ºssten wir den allgemeineren Begriff nicht bem√ºhen. Aber wenn jemand √ºber einen ADT sagt: \u0026ldquo;das ist kein parametrischer sondern ein einfacher ADT\u0026rdquo;, dann ist das genaugenommen ein Widerspruch und damit falsch. Im Gespr√§ch sollte man das nicht zum Anlass nehmen, gleich mit dem Belehrfinger zu fuchteln, aber man sollte im Hinterkopf behalten, dass genaugenommen der konkretere Begriff in dem allgemeineren Begriff enthalten ist.\nGADTs (generalized algebraic data types) sind wiederum eine Verallgemeinerung der parametrischen ADTs. Also ist jeder parameterlose und jeder parametrische ADT stets auch ein GADT. Aber auch √ºber ADTs und GADTs wird h√§ufig so gesprochen als seien es disjunkte Konzepte. Zum Beispiel enth√§lt der englische Wikipedia-Artikel √ºber GADTs in seiner aktuellen Form (2023-06) den folgenden Code-Kommentar:\n-- A parametric ADT that is not a GADT Im Haskell-Wiki und in der GHC-Dokumentation gibt es √§hnliche Formulierungen. Das ist nicht schlimm, aber auch hier sollten wir im Hinterkopf behalten, dass formal der konkretere Begriff im allgemeineren Begriff enthalten ist.\nNeue Syntax\nGADTs bringen in Haskell neben der Verallgemeinerung auch eine eigene Syntax mit. Ich m√∂chte zun√§chst herk√∂mmliche ADTs in dieser GADT-Syntax aufschreiben. Dann schauen wir uns an, worin genau die Verallgemeinerung besteht. Hier noch mal Bool in der herk√∂mmlichen ADT-Syntax:\n-- Haskell data Bool = False | True So w√ºrde man Bool in der GADT-Syntax schreiben:\n-- Haskell data Bool where False :: Bool True :: Bool Der Ampel Datentyp in herk√∂mmlicher ADT-Syntax:\n-- Haskell data Ampel = Gr√ºn | Gelb | Rot Der Ampel Datentyp in GADT-Syntax:\n-- Ampel in GADT-Syntax data Ampel where Gr√ºn :: Ampel Gelb :: Ampel Rot :: Ampel Herk√∂mmliche ADTs in GADT-Syntax aufzuschreiben, ist kein Gedankenexperiment: die Beispiele sind g√ºltiger Haskell Code und k√∂nnen genau so verwendet werden. Bei der GADT-Syntax f√§llt gleich auf, dass die Wertekonstruktoren mit Typannotationen versehen sind. Bei parameterlosen ADTs in GADT-Syntax sind diese Typannotationen √ºberfl√ºssig: selbstverst√§ndlich haben hier alle Wertekonstruktoren den selben Datentyp. Schauen wir uns als n√§chstes ein paar echte parametrische ADTs in GADT-Syntax an. Hier noch mal Maybe a in der herk√∂mmlichen Syntax:\n-- Haskell data Maybe a = Nothing | Just a Zum Vergleich, Maybe a in GADT-Syntax:\n-- Haskell data Maybe a where Nothing :: Maybe a Just :: a -\u0026gt; Maybe a Der Wertekonstrukor Just ist interessant. Er hat den Datentyp a -\u0026gt; Maybe a. Das ist immer der Fall, auch wenn wir den Datentyp in der herk√∂mmlichen ADT-Syntax aufschreiben, aber hier schreiben wir den Datentyp explizit hin. Hier noch mal der Datentyp List, diesmal in Haskell:\n-- Haskell List a = Nil | Cons a ( List a ) In GADT-Syntax:\n-- Haskell List a where Nil :: List a Cons :: a -\u0026gt; List a -\u0026gt; List a Die neue Syntax f√ºr GADTs ist ein Wink mit dem Zaunspfahl bzgl. der Verallgemeinerung, um die es geht. Bei einem herk√∂mmlichen parametrischen ADT kann jeder Typparameter stets nur f√ºr alle Wertekontruktoren gemeinsam auf einen Datentyp festgelegt werden. Bei einem GADT kann jeder Typparameter f√ºr verschiedene Wertekonstruktoren auf verschiedene Datentypen festgelegt werden. Hier ein GADT mit drei Wertekonstruktoren:\n-- Haskell data MyGadt a where MyInt :: Int -\u0026gt; MyGadt Int MyBool :: Bool -\u0026gt; MyGadt Bool MyString :: String -\u0026gt; MyGadt String Das besondere an einem GADT wie diesem ist, dass die Wertekonstruktoren den Datentyp jeweils unterschiedlich konkretisieren: der Wertekonstruktor MyInt erzeugt immer einen MyGadt Int, der Wertekonstruktor MyBool erzeugt immer einen MyGadt Bool und der Wertekonstruktor MyString erzeugt immer einen MyGadt String. Aber MyGadt hat nur diese drei Wertekonstruktoren. Daraus ergibt sich ein entscheidender Sachverhalt: der Typparameter a kann hier konstruktionsbedingt nur die Datentypen Int, Bool oder MyString annehmen.\nBei einem GADT k√∂nnen wir die Typparameter durch seine Wertekonstruktoren so einschr√§nken, dass konstruktionsbedingt nur noch ganz bestimme Datentypen auf die Typparameter passen. Mehr noch: wir k√∂nnen die Wertekonstruktoren so entwerfen, dass sie Beziehungen zwischen den verschiedenen Konkretisierungen eines generischen Datentyps beschreiben. Es ist ein bisschen so als w√ºrden wir mit einem GADT nicht nur einen Datentyp beschreiben, sondern eine ganze Gruppe von Datentypen und ihre Beziehungen zueinander. Wer schon mal eine kleine formale Sprache entworfen und in eine Reihe von Datentypen gegossen hat oder einen Parser f√ºr eine formale Sprache geschrieben hat, m√ºsste hier hellh√∂rig werden. Tats√§chlich eignen sich GADTs sehr gut daf√ºr, DSLs oder ganze Programmiersprachen zu beschreiben. Grunds√§tzlich geht das auch mit herk√∂mmlichen ADTs, aber mit GADTs lassen sich solche Beschreibungen kompakter formulieren und mehr Invarianten auf der Typebene festhalten. Als Beispiel daf√ºr schauen wir uns die kleine arithmetische Sprache an, die der Wikipedia-Artikel zu GADTs enth√§lt:\n-- Haskell data Expr a where EInt :: Int -\u0026gt; Expr Int EBool :: Bool -\u0026gt; Expr Bool EEqual :: Expr Int -\u0026gt; Expr Int -\u0026gt; Expr Bool Der Wertekonsturktor EInt erzeugt immer einen Expr Int Wert. Die Wertekonstruktoren EBool und EEqual erzeugen immer einen Expr Bool Wert. Deswegen kann der Typparameter a hier nur die Typen Int und Bool annehmen. Dazu geh√∂rt noch die eval Funktion, die einen Expr a Ausdruck in einen Wert vom Typ a √ºberf√ºhrt:\n-- Haskell eval :: Expr a -\u0026gt; a eval expr = case expr of EInt n -\u0026gt; n EBool b -\u0026gt; b EEqual a b -\u0026gt; eval a == eval b Damit sollte das folgende Programm False ausgeben:\n-- Haskell main = do let v1 = EInt 123 let v2 = EInt 124 let result = EEqual v1 v2 putStrLn ( show ( eval result ) ) Eine Sache, die mich ein bisschen daran st√∂rt, ist dass wir EEqual nicht auf Expr Bool Werte anwenden k√∂nnen. Das ist aber leicht behoben:\n-- Haskell data Expr a where EInt :: Int -\u0026gt; Expr Int EBool :: Bool -\u0026gt; Expr Bool EEqual :: Eq a =\u0026gt; Expr a -\u0026gt; Expr a -\u0026gt; Expr Bool eval :: Expr a -\u0026gt; a eval expr = case expr of EInt n -\u0026gt; n EBool b -\u0026gt; b EEqual a b -\u0026gt; eval a == eval b Damit sollte auch das folgende Programm compilieren und False ausgeben:\n-- Haskell main = do let v1 = EBool False let v2 = EBool True let result = EEqual v1 v2 putStrLn ( show ( eval result ) ) Wie w√ºrde man das ohne GADTs modellieren? Keine Ahnung! Aber wir k√∂nnen uns anschauen, was √ºbrigbleibt, wenn wir Expr auf einen parametrischen ADT reduzieren:\n-- Haskell data Expr a = EInt Int | EBool Bool | EEqual ( Expr a ) ( Expr a ) Wenn wir den so angepassten Datentyp in der GADT-Syntax aufschreiben, sehen wir besser, was sich ge√§ndert hat:\n-- Haskell data Expr a where EInt :: Int -\u0026gt; Expr a EBool :: Bool -\u0026gt; Expr a EEqual :: Expr a -\u0026gt; Expr a -\u0026gt; Expr a Der Datentyp ist so v√∂llig unbrauchbar. Es gibt jetzt keine Beziehung mehr zwischen dem Typparameter a und den Feldtypen von EInt und EBool:\n-- Haskell v1 :: Expr Int v1 = EBool True v2 :: Expr String v2 = EInt 123 Der Wertekonstruktor EEqual ist so auch unbrauchbar. Wenn EEqual einen Expr Bool Wert erzeugen soll, muss er auch auf zwei Expr Bool Werten operieren. Schauen wir uns trotzdem an, wie weit wir bei der eval Funktion kommen:\n-- Haskell eval :: Expr a -\u0026gt; a eval expr = case expr of EInt n -\u0026gt; undefined EBool b -\u0026gt; undefined EEqual e1 e2 -\u0026gt; undefined Was sollen wir z.B. f√ºr EInt n berechnen? Der Wert n hat hier den Datentyp Int, aber eval operiert auf einem Expr a Wert und erzeugt einen a Wert. Wir br√§uchten eine Funktion Int -\u0026gt; a f√ºr beliebige Datentypen a. Das w√§re zwar rein formal m√∂glich (also typisierbar) aber wie sollen wir f√ºr jeden m√∂glichen Datentyp ad hoc und aus dem Nichts einen Wert herzaubern? Die gleiche Frage stellt sich f√ºr EBool b. Bei EEqual e1 e2 ist das Problem noch gravierender, weil wir nur dann zu einem Bool Wert auswerten k√∂nnen, wenn e1 und e2 vom Datentyp Expr Bool sind. Die ganze Konstruktion ist also v√∂llig unbrauchbar.\nWenn wir Expr in einen parameterlosen ADT umbauen, kommt z.B. das heraus:\n-- Haskell data Expr = EInt Int | EBool Bool | EEqual Expr Expr Das erscheint mir auf den ersten Blick schon sinnvoller. Schauen wir uns an, wie eval aussehen k√∂nnte:\n-- Haskell eval :: Expr -\u0026gt; a eval expr = case expr of EInt n -\u0026gt; undefined EBool b -\u0026gt; undefined EEqual e1 e2 -\u0026gt; case ( e1 , e2 ) of ( EInt n1 , EInt n2 ) -\u0026gt; undefined ( EBool b1 , EBool b2 ) -\u0026gt; undefined _ -\u0026gt; undefined Das ist wieder eine Sackgasse. Wir k√∂nnen eval zwar von Expr -\u0026gt; a konkretisieren auf Expr -\u0026gt; Bool oder auf Expr -\u0026gt; Int, aber das findet immer f√ºr die gesamte Funktion inklusive aller Case-Zweige statt. Wir k√∂nnen nicht in einem Case-Zweig nach Bool und im n√§chsten nach Int auswerten. √úberhaupt m√ºssen wir ja nach a auswerten, auch wenn f√ºr a weder Bool noch Int eingesetzt worden ist. Wenn wir f√ºr a einen konketen Wert einsetzen, wird die Sache einfacher. F√ºr einige Anwendungen gen√ºgt sicherlich eine Funktion eval :: Expr -\u0026gt; String:\n-- Haskell eval :: Expr -\u0026gt; String eval expr = case expr of EInt n -\u0026gt; show n EBool b -\u0026gt; show b EEqual e1 e2 -\u0026gt; case ( e1 , e2 ) of ( EInt n1 , EInt n2 ) -\u0026gt; show ( n1 == n2 ) ( EBool b1 , EBool b2 ) -\u0026gt; show ( b1 == b2 ) _ -\u0026gt; show False Andernfalls sehe ich nicht, wie man hier ohne GADTs auskommen k√∂nnte. Ich hoffe, ich konnte demonstrieren, was man mit GADTs anstellen kann. F√ºr mich ist das Konzept noch relativ neu.\nEpilog # Dieser Text ist f√ºr mich in erster Linie eine Art Selbsttest: kann ich mein Verst√§ndnis der Konzepte, die ich hier vorstelle, ausformulieren und aufschreiben, so dass ich hinterher damit zufrieden bin, auch wenn ich den Text zwischenzeitlich f√ºr ein paar Wochen beiseite gelegt habe? Wenn nicht, werde ich weiter daran arbeiten (sofern ich Zeit und Lust dazu habe). Mein Bezug zu diesem Thema ist ein praktischer. Bisher bin ich noch nicht dazu gekommen, mich ernsthaft mit B√ºchern √ºber Typentheorie zu befassen. Insofern hoffe ich, dass sich hier kein Bl√∂dsinn eingeschlichen hat. Das w√§re mir wirklich peinlich. Wenn der Text noch jemandem au√üer mir selbst nutzt, freut mich das umso mehr.\n"},{"id":1,"href":"/docs/weblog/2023-02-17/","title":"Negation in Haskell Und Purescript","section":"Docs","content":"2023-02-17\nNegation in Haskell und Purescript # Haskell fetzt! Allerdings ist Haskell in seiner Nische (rein funktionale ML-Sprachen) l√§ngst nicht mehr allein. Die moderneren Abk√∂mmlinge dieser Familie bringen hier und da interessante Verbesserungen mit. Ein sch√∂nes Beispiel daf√ºr ist die not Funktion in Purescript.\nWerte negieren # In Haskell negiert not den Wert eines boolschen Ausdrucks:\n-- Haskell GHCi Session ‚Äã \u0026gt; not True False ‚Äã \u0026gt; not False True In Purescript gilt das gleiche:\n-- Purescript PSCi Session ‚Äã \u0026gt; not true false ‚Äã \u0026gt; not false true Das ist nicht weiter kompliziert.\nFunktionen negieren # Grunds√§tzlich m√ºssten sich auf die gleiche Weise auch Funktionen negieren lassen, die nach Bool abbilden. F√ºr eine Funktion f :: a -\u0026gt; Bool w√§re not f dann ebenfalls eine Funktion a -\u0026gt; Bool, so dass ( not f ) x \u0026hellip;\nzu True auswertet wenn f x zu False auswertet, bzw. zu False auswertet wenn f x zu True auswertet. Haskells not kann das nicht leisten. Um das zu demonstrieren, definieren wir eine even Funktion, die entscheidet, ob eine ganze Zahl gerade ist:\n-- Haskell GHCi Session ‚Äã \u0026gt; even n = modBy 2 n == 0 \u0026gt; even 0 True ‚Äã \u0026gt; even 1 False ‚Äã \u0026gt; even 2 True ‚Äã \u0026gt; even 3 False Anmerkung: Mein Haskell ist nicht ganz idiomatisch. modBy ist selbstdefiniert.\nWir m√ºssten also eine odd Funktion definieren k√∂nnen, die entscheidet, ob eine ganze Zahl ungerade ist, indem wir even mit not negieren. Wenn wir versuchen, das in Haskell umzusetzen, scheitern wir:\n-- Haskell GHCi Session ‚Äã \u0026gt; odd = not even \u0026lt;interactive\u0026gt;: error: ‚Ä¢ Couldn\u0026#39;t match expected type ‚ÄòBool‚Äô with actual type ‚Äòa0 -\u0026gt; Bool‚Äô ‚Ä¢ ... In Purescript ist das gar kein Problem. Hier ist die even Funktion in Purescript:\n-- Purescript PSCi Session ‚Äã \u0026gt; even n = mod n 2 == 0 ‚Äã \u0026gt; even 0 true ‚Äã \u0026gt; even 1 false ‚Äã \u0026gt; even 2 true ‚Äã \u0026gt; even 3 false Wenn wir even mit not negieren, erhalten wir ohne Probleme unsere odd Funktion:\n-- Purescript GHCi Session ‚Äã \u0026gt; odd = not even ‚Äã \u0026gt; odd 0 false ‚Äã \u0026gt; odd 1 true ‚Äã \u0026gt; odd 2 false ‚Äã \u0026gt; odd 3 true Wie ist das umgesetzt? # In Haskell ist not eine Funktion Bool -\u0026gt; Bool. In Purescript ist not eine Funktion HeytingAlgebra a =\u0026gt; a -\u0026gt; a. Die Heyting-Algebra ist offenbar eine Verallgemeinerung der booleschen Algebra. Auf den ersten Blick spricht nichts dagegen, not auf die gleiche Weise auch in Haskell zu verallgemeinern. Vielleicht nehme ich das mal in Angriff und versuche not in meinem DIY Prelude entsprechend anzupassen.\nBonus # Dann ist mir noch ein sch√∂nes Beispiel daf√ºr eingefallen, dass man manchmal in der Lage ist, zu erkennen, zu welchem Wert ein Ausdruck auswerten m√ºsste, obwohl der Compiler auf dem Schlauch steht:\nfoldr (+) 0 ( repeat 0 ) Der Ausdruck terminiert weder in Haskell noch in Purescript, weil repeat eine unendliche Sequenz erzeugt. Anschaulich ist v√∂llig klar, dass er zu 0 auswerten m√ºsste, denn wir summieren einfach nur Nullen auf. Formal l√§sst sich das auch leicht rechtfertigen: wenn wir eine unendliche Summe √ºber einem Monoid bilden, wobei alle Summanden das neutrale Element sind, dann ergibt die Summe schon per Definition ebenfalls das neutrale Element.\nEs gibt weitere Beispiele dieser Art. Der folgende Ausdruck terminiert auch nicht, m√ºsste aber zum leeren String \u0026quot;\u0026quot; auswerten. Anschaulich ist das auch wieder v√∂llig klar. Formal gilt das gleiche wie oben.\nfoldr (++) \u0026#34;\u0026#34; ( repeat \u0026#34;\u0026#34; ) Hinweis: (++) ist hier ein Alias f√ºr (\u0026lt;\u0026gt;).\nDer folgende Ausdruck terminiert auch nicht, m√ºsste aber in Haskell zur leeren Liste [] auswerten.\nfoldr (++) [] ( repeat [] ) Spannend ist die Frage, wie man das umsetzen k√∂nnte. Alle Beispiele haben die Form:\nfoldr mappend mempty ( repeat mempty ) Wenn die Faltung in der Lage w√§re, diese Form zu erkennen, k√∂nnte sie in diesem Fall zu mempty auswerten.\n"},{"id":2,"href":"/docs/weblog/2023-01-18/","title":"Closures","section":"Docs","content":"2023-01-18\nClosures # Ich spiele gerade ein bisschen mit Go herum, weil ich mich aus meiner funktionalen Ecke heraustrauen und etwas mehr mit imperativen, C-artigen Sprachen befassen m√∂chte. Rust h√§tte mich auch interessiert, scheint aber ein Fass ohne Boden zu sein. Go ist modern, trotzdem stabil, recht kompakt und weitverbreitet. Die Liste der gro√üen und popul√§ren Softwareprojekte, die auf Go setzen, ist beachtlich.\nIn der Go-Tour gibt es einen Abschnitt zu Closures. Ich nutze die Gelegenheit, um f√ºr mich zu kl√§ren was Closures sind. Ich hab den Begriff bisher nie wirklich verstanden.\nEine Closure (i.e. ein Funktionsabschluss) ist eine Funkion, die Referenzen auf ihren Erstellungskontext enth√§lt, wobei dieser Kontext au√üerhalb der Funktion nicht mehr sichtbar und nicht mehr referenzierbar ist.\nEin Beisiel aus dem Haskell Wiki:\n\u0026gt; f x = \\ y -\u0026gt; x + y \u0026gt; g = f 3 \u0026gt; g 4 7 Wenn wir g definieren, wird der Wert 3 an den Parameter x gebunden, so dass g = \\ y -\u0026gt; 3 + y gilt. Auf den Kontext, in dem die Bindung x = 3 vorliegt, k√∂nnen wir aber nicht mehr zugreifen, obwohl er weiter existiert solange g existiert. Eine Closure liegt vor weil die Bindung x = 3 im Kontext des Lambda-Ausdrucks erfolgt aber innerhalb des Lambda-Ausdrucks verwendet wird. Dadurch lebt der Kontext √ºber die Definition hinaus weiter, weil er f√ºr die Auswertung ben√∂tigt wird.\nIch verstehe das, aber was ich nicht verstehe ist, warum man dieser Sache einen gesonderten Namen gibt und sie als eine spezielle Programmiertechnik behandelt. Statt f x = \\ y -\u0026gt; x + y k√∂nnte man auch schreiben: f x y = x + y. Das ist die normalste Sache der Welt und ich verstehe √ºberhaupt nicht, wie es anders sein k√∂nnte, also was es bedeuten soll, ohne Closures zu programmieren.\nBeim Schreiben kommt mir der Verdacht, dass es irgendwie damit zusammenh√§ngen muss, dass Sprachen wie C keine First Class Functions haben. Wenn man es nicht gewohnt ist, kann das Herumreichen von Funktionen als Argumente und R√ºckgabewerte mit allen M√∂glichkeiten, die sich daraus ergeben, vielleicht wie ein besonderer Hokuspokus erscheinen, der erst mal in einen Begriff zu bringen ist: Closure ‚Äî eine Funktion, die auf freien Variablen operiert.\nDas Gegenteil w√§re ein Combinator ‚Äî eine Funktion ohne freie Variable.\nUpdate\nOk, ich hab\u0026rsquo;s! Der eigentliche Effekt, an dem man offenbar bei der imperativen Programmierung mit Closures interessiert ist, tritt bei der rein funktionalen Programmierung gar nicht auf. Eine Closure ist in diesem Fall eine Prozedur mit einem inneren Zustand, der √ºber mehrere Aufrufe hinweg fortbesteht und ver√§nderbar ist. Hier ein angepasstes Beispiel aus der Go Tour:\nfunc adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { f := adder() fmt.Println(f(0)) // 0 fmt.Println(f(1)) // 1 fmt.Println(f(2)) // 3 fmt.Println(f(3)) // 6 fmt.Println(f(4)) // 10 fmt.Println(f(5)) // 15 } Was passiert hier? Die Prozedur f hat einen inneren Zustand, der mit sum := 0 initialisiert wird, bei jedem Aufruf von f ver√§ndert wird und nur indirekt √ºber den R√ºckgabewert observierbar ist. Daraus k√∂nnte man ein Objektsystem stricken.\nNicht alle imperativen Sprachen unterst√ºtzen Closures. Wenn sie es nicht tun, wird f im obigen Beispiel zur Identit√§tsfunktion, weil f(n) stets zu 0 + n auswertet.\n"},{"id":3,"href":"/docs/weblog/2022-12-02/","title":"Trial Beim MC Post Leipzig","section":"Docs","content":"2022-12-02\nTrial Beim MC Post Leipzig # In meiner Jugend bin ich wettkampforientiert Fahrrad-Trial gefahren. Einige Jahre lang war dieser Sport gewisserma√üen meine Raison d‚Äô√™tre. Dann hat f√ºr mich das echte Leben begonnen: Abitur, Studium, Freundin, WG-Leben und eine chaotische Suche nach meinem Platz in dieser Welt. Jetzt ist es vielleicht achtzehn Jahre oder l√§nger her, dass ich den Trial-Sport aufgegeben habe. Irgendwie war damals die Luft raus. Aber in den darauffolgenden Jahren habe ich etwas so k√∂rperlich intensives und viszeral sinnstiftendes wirklich sehr sehr vermisst in meinem Leben. Trial hat mir damals das gegeben, was Hartmut Rosa eine diagonale Resonanzbeziehung nennt.\nJetzt bin ich 38 Jahre alt und √ºbergewichtig. Ich muss dringend mehr Sport machen, um meine zweite Lebensh√§lfte gesund √ºber die B√ºhne zu bringen. Noch geht es mir gut, aber ich bef√ºrchte, dass ich in zehn Jahren endg√ºltig ein dicker Stubenhocker sein werde, f√ºr den die sportlichen Highlights des Tages die Wege zum K√ºhlschrank, zum Briefkasten und zum Auto sind. Die Eitelkeit als Triebfeder f√ºr die k√∂rperliche Fitness tritt f√ºr mich mit zunehmendem Alter in den Hintergrund. Sie wird abgel√∂st von der Sorge um mein k√∂rperliches und geistiges Wohlbefinden.\nIm Fr√ºhling kam mir die Idee, Trial wieder auszuprobieren um herauszufinden ob es wieder Spa√ü macht und wieviel davon mein K√∂rper noch erinnert. Ja, es macht einen Heidenspa√ü und zu meinem gro√üen Erstaunen kann ich es noch.\nDie Bilder sind auf dem Trainingsgel√§nde des MC Post Leipzig e.V. entstanden. Ich bin dort seit ein paar Wochen Mitglied und nutze jede Gelegenheit f√ºr ein Training. Nach f√ºnf Minuten atme ich wie nach einem Sprint. Nach einer Stunde bin ich nassgeschwitzt und v√∂llig ersch√∂pft.\nDer Fotograf, der diese Aufnahmen geschossen hat, ist Jan Zwicker. Jan stand am Samstag fr√ºh um zehn (f√ºr einen anderen Anlass) mit seiner professionellen Fotoausr√ºstung auf dem Gel√§nde und hat gefragt, ob er ein paar Fotos machen darf.\nhttps://wheels-and-vibes.com/\nIch wiege 25 kg mehr als damals. Das macht sich bemerkbar. Aber die grunds√§tzlichen Bewegungsabl√§ufe und das Gef√ºhl f√ºr das Fahrrad sind noch da. Es scheint zu stimmen: Fahrradfahren verlernt man nicht. Jetzt ist die gro√üe Frage, wie es f√ºr mich weitergeht. Bleibe ich beim Midlife-Cycling? Wird das dazu beitragen, dass ich wieder fit werde und mein √úbergewicht loswerde? Oder mache ich mir damit auf Dauer nur die Knochen kaputt?\nDas Trainingsgel√§nde des MC Post Leipzig ist das einzige seiner Art mitten in einer deutschen Gro√üstadt. Es ist keinen ganzen Kilometer von meiner Wohnung entfernt und ich frage mich, warum ich nicht schon eher auf die Idee gekommen bin, dort mitzumachen. Im Moment bin ich der einzige Fahrrad-Trialer im Verein. Die anderen fahren Motorrad.\nWenn du auch Fahrrad-Trial f√§hrst und in der N√§he lebst, mach bei uns mit. Es lohnt sich.\nhttps://mcpostleipzig.de/\n"},{"id":4,"href":"/docs/weblog/2022-12-01/","title":"Nix Expression Language","section":"Docs","content":"2022-12-01\nNix Expression Language # Ich erkunde die Nix Expression Language. Mein Startpunkt ist https://learnxinyminutes.com/docs/nix/. Sehr hilfreich ist auch die Dokumentation, welche √ºber die Nix Repl verf√ºgbar ist.\nAuswertung # Die auszuwertenden Ausdr√ºcke schreibe ich in eine Datei scratch.nix. Die Auswertung erfolgt so:\n$ nix-instantiate --eval scratch.nix F√ºr mehr Komfort kann man inotifywait benutzen um die Auswertung jedesmal anzusto√üen wenn die Datei scratch.nix gespeichert wird:\n$ while true inotifywait -q -e modify scratch.nix clear nix-instantiate --eval scratch.nix and echo \u0026#34;.\u0026#34; end Das ist eine Kommandozeile f√ºr die fish Shell. In sh usw. muss man das ein bisschen anders schreiben. Die fish Shell ist sehr komfortabel: man kann das einfach so mehrzeilig aufschreiben; die Shell wei√ü, wann die Eingabetaste die Zeile umbrechen soll und wann sie die Auswertung ansto√üen soll.\nKurze Ausdr√ºcke kann man auch direkt in der Nix Repl ausprobieren:\n$ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; \u0026#34;Das ist eine Zeichenkette\u0026#34; \u0026#34;Das ist eine Zeichenkette\u0026#34; nix-repl\u0026gt; 7 * 11 * 13 1001 Update: Am Ende habe ich die Methode mit der Scratch-Datei kaum verwendet und mich stattdessen fast ausschlie√ülich auf die Nix Repl verlassen. Die Nix Repl bietet integrierte Dokumentation und kann auch mit mehrzeiligen Eingaben gut umgehen.\nEinfache Sprachbestandteile # Im Schnelldurchlauf.\nKommentare # # Einzeilige Kommentare (wie in Python). /* Mehrzeilige Kommentare (wie in C++). Python-Einzeiler und C++-Mehrzeiler sind schon mal eine seltsame Kombination. Wir haben noch nicht richtig begonnen und der Merkw√ºrdigkeitsfaktor ist schon gr√∂√üer 1. */ Booleans # nix-repl\u0026gt; true \u0026amp;\u0026amp; false false nix-repl\u0026gt; true || false true Verzweigung # nix-repl\u0026gt; if 3 \u0026lt; 4 then \u0026#34;a\u0026#34; else \u0026#34;b\u0026#34; \u0026#34;a\u0026#34; Zahlen # Es scheint Integers und Floats zu geben. Man kann sie beim Rechnen mit einander kombinieren. Die arithmetischen Operatoren sind polymorph. Der Interpreter scheint selbst√§ndig nach gewissen Regeln zu enscheiden, wann das Ergebnis Integer und wann es Float ist. Daraus ergeben sich die √ºblichen Fallstricke:\nnix-repl\u0026gt; 7.0 / 2 3.5 nix-repl\u0026gt; 7 / 2 3 F√ºr den Einsatzzweck der Nix Expression Language ist das bestimmt kein Problem.\nStrings # nix-repl\u0026gt; \u0026#34;Das ist ein String\u0026#34; \u0026#34;Das ist ein String\u0026#34; Strings k√∂nnen mehrzeilig sein:\nnix-repl\u0026gt; \u0026#34;asdf ... asdf ... asdf\u0026#34; \u0026#34;asdf\\nasdf\\nasdf\u0026#34; Die sogenannten Indented Strings sind ebenfalls mehrzeilig. Bei ihnen wird die Einr√ºckung nicht mit ausgewertet. Das ist die k√ºrzeste Folge von f√ºhrenden Leerzeichen, in der alle nicht leeren Zeilen des Strings √ºbereinstimmen. Ob und wie dabei Tabs ber√ºcksichtigt werden, habe ich nicht ausprobiert. Hier werden in jeder Zeile die vier f√ºhrenden Leerzeichen entfernt:\nnix-repl\u0026gt; \u0026#39;\u0026#39; asdf ... asdf ... asdf\u0026#39;\u0026#39; \u0026#34;asdf\\nasdf\\nasdf\u0026#34; Mit leeren Zeilen sind hier auch Zeilen gemeint, die nur aus Leerraum bestehen. Leerzeilen am Rand des Strings werden verworfen.\nVerkettung von Strings mit +:\nnix-repl\u0026gt; \u0026#34;ab\u0026#34; + \u0026#34;cd\u0026#34; \u0026#34;abcd\u0026#34; Auswertung in Strings:\nnix-repl\u0026gt; \u0026#34;Home is ${builtins.getEnv \u0026#34;HOME\u0026#34;}.\u0026#34; \u0026#34;Home is /home/aramis.\u0026#34; Der Name builtins verweist auf eine Standardbibliothek (genauer: ein Set) von Funktionen und Prozeduren. Das builtins Set ist immer verf√ºgbar wenn der Nix Interpreter startet. Die Prozedur builtins.getEnv liefert den Wert von Umgebungsvariablen.\nnix-repl\u0026gt; builtins.getEnv \u0026#34;HOME\u0026#34; \u0026#34;/home/aramis\u0026#34; Pfade # F√ºr Pfade gibt es einen eigenen Basisdatentyp. Man notiert Pfade einfach so wie man sie auch sonst notieren w√ºrde:\nnix-repl\u0026gt; /home/aramis /home/aramis Das hat aber Einschr√§nkungen. Zum Beispiel sind abschlie√üende Schr√§gstriche aus irgendwelchen Gr√ºnden nicht gestattet:\nnix-repl\u0026gt; /home/aramis/ error: path has a trailing slash nix-repl\u0026gt; /home/aramis/. /home/aramis Pfade ganz ohne Schr√§gstriche wie z.B. . werden auch nicht erkannt:\nnix-repl\u0026gt; . error: syntax error, unexpected \u0026#39;.\u0026#39; nix-repl\u0026gt; ./ error: path has a trailing slash nix-repl\u0026gt; ./. /home/aramis Relative Pfade werden in absolute Pfade aufgel√∂st relativ zu dem Verzeichnis, in welchem sich die Datei befindet, die ausgewertet wird:\nnix-repl\u0026gt; ./. /home/aramis Pfade werden kanonisiert:\nnix-repl\u0026gt; /home/aramis/. /home/aramis Daraus, dass der Parser auch relative Pfade als Pfade erkennt, ergibt sich, dass der Schr√§gstrich, wenn er als Divisionszeichen gelesen werden soll, von Leerraum umgeben sein muss\nnix-repl\u0026gt; 0/0 /home/aramis/0/0 nix-repl\u0026gt; 0 / 0 error: division by zero Imports # Jedes Nix Skript enth√§lt genau einen Top-Level-Ausdruck ohne freie Variable, der also vollst√§ndig ausgewertet werden kann. Wenn ein Skript importiert wird, entspricht der Wert des Import-Ausdrucks dem Wert des importierten Skripts:\n$ echo \u0026#34;1 + 2\u0026#34; \u0026gt; foo.nix $ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; import ./foo.nix 3 Das import Schl√ºsselwort kann auch Strings verarbeiten:\nnix-repl\u0026gt; import \u0026#34;/home/aramis/foo.nix\u0026#34; 3 Aber das scheint nur zu funktionieren wenn der String einen absoluten Pfad enth√§lt:\nnix-repl\u0026gt; import \u0026#34;foo.nix\u0026#34; error: string \u0026#39;foo.nix\u0026#39; doesn\u0026#39;t represent an absolute path nix-repl\u0026gt; import \u0026#34;./foo.nix\u0026#34; error: string \u0026#39;./foo.nix\u0026#39; doesn\u0026#39;t represent an absolute path Let-In-Ausdr√ºcke # Daf√ºr gibt es eine let ... ; in ... Syntax:\nnix-repl\u0026gt; let x = \u0026#34;a\u0026#34; ; in x + x + x \u0026#34;aaa\u0026#34; Die Zuweisungen k√∂nnen sich auf einander beziehen, unabh√§ngig von ihrer Reihenfolge:\nnix-repl\u0026gt; let y = x + \u0026#34;b\u0026#34; ; x = \u0026#34;a\u0026#34; ; in y + \u0026#34;c\u0026#34; \u0026#34;abc\u0026#34; Innere Zuweisungen √ºberschatten weiter au√üen liegende Zuweisungen:\nnix-repl\u0026gt; let a = 1 ; in let a = 2 ; in a 2 Funktionen # Das ist erstaunlich rudiment√§r gel√∂st. Nix kennt eigentlich nur einfache Lambdas:\nnix-repl\u0026gt; (n : n + 1) 5 6 Lambdas mit mehr als einem Parameter ergeben sich aus der Syntax auf nat√ºrliche Weise:\nnix-repl\u0026gt; (a : b : a + b) 5 6 11 Wenn man Namen f√ºr Funktionen vergeben m√∂chte, kann man auf die let ... ; in ... Syntax zur√ºckgreifen:\nnix-repl\u0026gt; let plus = (a : b : a + b ) ; in plus 5 6 11 Listen # Listen sind von eckigen Klammern begrenzt. Die Elemente sind durch Lerraum getrennt.\nnix-repl\u0026gt;[ 1 2 3 ] [ 1 2 3 ] Es gibt viele Built-Ins f√ºr Listen:\nnix-repl\u0026gt; builtins.length [ 1 2 3 ] 3 nix-repl\u0026gt; builtins.concatLists [ [ 1 2 3 ] [ 4 5 6 ] ] [ 1 2 3 4 5 6 ] nix-repl\u0026gt; builtins.head [ 1 2 3 ] 1 nix-repl\u0026gt; builtins.filter (n : n \u0026lt; 3) [ 1 2 3 ] [ 1 2 ] Sets (Mengen) # In Nix Sets hat jedes Element einen String als Schl√ºssel also einen Namen. Demnach sind Nix Sets keine blo√üen Mengen sondern eher Records bzw. Maps.\nnix-repl\u0026gt; { a = 1 ; b = 2 ; }.a 1 nix-repl\u0026gt; let s = { a = 1 ; b = 2 ; } ; in s.a 1 Der ? Operator pr√ºft die Existenz eines Schl√ºssels:\nnix-repl\u0026gt; { a = 1 ; b = 2 ; } ? a true Der // Operator vereinigt zwei Sets:\nnix-repl\u0026gt; { a = 1 ; } // { b = 2 ; } { a = 1; b = 2; } Wenn dabei Schl√ºssel kollidieren, hat das rechte Set Vorrang:\nnix-repl\u0026gt; { a = 1 ; } // { a = 2 ; } { a = 2; } Mit dem rec Schl√ºsselwort k√∂nnen rekursive Sets deklariert werden. Darin k√∂nnen sich Werte auf andere Werte des selben Sets beziehen:\nnix-repl\u0026gt; rec { a = 1 ; b = a ; } { a = 1; b = 1; } nix-repl\u0026gt; rec { a = b ; b = a ; } error: infinite recursion encountered F√ºr verschachtelte Sets gibt es eine Kurznotation:\nnix-repl\u0026gt; { a.b = 2 ; a.c = 3 ; } { a = { ... }; } Das entspricht:\nnix-repl\u0026gt; { a = { b = 2 ; c = 3 ; } ; } { a = { ... }; } Man kann die Kurznotation mit der ausf√ºhrlicheren mischen:\nnix-repl\u0026gt; { a = { b = 2 ; } ; a.c = 3 ; } { a = { ... }; } Ich finde, das sieht widerspr√ºchlich aus.\nDas with Schl√ºsselwort # Das with Schl√ºsselwort nimmt ein Set und einen Ausdruck. In dem Ausdruck gelten die Schl√ºssel-Wert-Paare des Sets als Bindungen:\nnix-repl\u0026gt; with { a = 1 ; b = 2 ; } ; a + b 3 Das ist also wie die let ... ; in ... Syntax:\nnix-repl\u0026gt; let a = 1 ; b = 2 ; in a + b 3 Der Unterschied ist, dass bei with die gesamte Menge von Bindungen in einem (Set-)Ausdruck zusammengefasst ist. Dadurch kann man sich die Bindungen sozusagen als ein ganzes B√ºndel aus dem Kontext holen. Man sieht das h√§ufig in Nix-Expressions bspw. um die Built-Ins unqualifiziert verf√ºgbar zu machen:\nnix-repl builtins.length [ 1 2 3 ] 3 nix-repl\u0026gt; with builtins ; length [ 1 2 3 ] 3 Das ist sinnvoll wenn man z.B. viele Built-Ins in einem Ausdruck verwenden m√∂chte und sie nicht jedesmal mit builtins. qualifizieren m√∂chte.\nOhne with:\nnix-repl\u0026gt; [ ( builtins.length [ 1 2 3 ] ) ... ( builtins.head [ 1 2 3 ] ) ... ( builtins.elem 2 [ 1 2 3 ] ) ... ] [ 3 1 true ] Mit with:\nnix-repl\u0026gt; with builtins ; ... [ ( length [ 1 2 3 ] ) ... ( head [ 1 2 3 ] ) ... ( elem 2 [ 1 2 3 ] ) ... ] [ 3 1 true ] Wenn man also qualifiziert importieren m√∂chte, ganz grob ungef√§hr so wie man es in Haskell machen w√ºrde, k√∂nnte das so aussehen:\n$ echo \u0026#34;{ plus = a : b : a + b ; }\u0026#34; \u0026gt; foo.nix $ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; let foo = import ./foo.nix ; in with foo ; foo.plus 5 6 11 Das w√ºrde einem unqualifizierten Import entsprechen:\nnix-repl\u0026gt; with import ./foo.nix ; plus 5 6 11 Anstatt wie oben den Import in einem Let-Ausdruck an den Namen foo zu binden, kann man diesen Namen in der importierten Datei festlegen. Dann spart man sich den Let-Ausdruck:\n$ echo \u0026#34;{ foo = { plus = a : b : a + b ; } ; }\u0026#34; \u0026gt; foo.nix $ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; with import ./foo.nix ; foo.plus 5 6 11 Die Variante hat den gro√üen Nachteil, dass die Festlegung des Qualifiers foo in der importierenden Datei nicht explizit ist.\nMit with l√§sst sich jeweils nur ein Set von Bindungen angeben aber, √§hnlich wie bie den Lambdas, ergibt sich auch hier aus der Syntax eine nat√ºrliche Erweiterung auf mehrere Sets:\nnix-repl\u0026gt; with builtins ; ... with { myList = [ 1 2 3 ] ; } ; ... length myList 3 Set Patterns # Funktionen unterst√ºtzen per se keine benannten Parameter. Lambdas k√∂nnen aber selbstverst√§ndlich auch auf Sets operieren:\nnix-repl\u0026gt; (x : x.a + x.b) { a = 5 ; b = 6 ; } 11 Mit sogenannten Set Patterns kann man letztlich doch benannte Funktionsparameter aufschreiben:\nnix-repl\u0026gt; ({a,b} : a + b) { a = 5 ; b = 6 ; } 11 Dabei ist {a,b} ein sogenanntes Set Pattern.\nAchtung: Wenn das Argument ein Set ist, welches zus√§tzliche Werte enth√§lt, die im Set Pattern nicht angegeben sind, ist das ein Fehler:\nnix-repl\u0026gt; ({a,b} : a + b) { a = 5 ; b = 6 ; c = 7 ; } error: anonymous function at (string):1:2 called with unexpected argument \u0026#39;c\u0026#39; Man kann den Fall aber im Set Pattern durch Auslassungspunkte ausdr√ºcklich zulassen:\nnix-repl\u0026gt; ({a,b,...} : a + b) { a = 5 ; b = 6 ; c = 7 ; } 11 Fehler # Das throw Schl√ºsselwort bricht die Auswertung ab und gibt eine Fehlermeldung aus:\nnix-repl\u0026gt; 1 + 2 + throw \u0026#34;drei\u0026#34; error: drei Anscheinend werden Fehler innerhalb von Listen wie normale Elemente behandelt. Die Auswertung wird nicht abgebrochen:\nnix-repl\u0026gt; [ 1 (throw \u0026#34;zwei\u0026#34;) 3 ] [ 1 ¬´error: error: zwei¬ª 3 ] Das gleiche Verhalten tritt innerhalb von Sets auf:\nnix-repl\u0026gt; { eins = 1 ; zwei = throw \u0026#34;zwei\u0026#34; ; drei = 3 ; } { drei = 3; eins = 1; zwei = ¬´error: error: zwei¬ª; } Neben throw gibt es auch noch das Schl√ºsselwort abort, welches ebenfalls die Auswertung abbricht und eine Fehlermeldung ausgibt:\nnix-repl\u0026gt; 1 + 2 + abort \u0026#34;drei\u0026#34; error: evaluation aborted with the following error message: \u0026#39;drei\u0026#39; Im Unterschied zu throw f√ºhrt abort auch innerhalb von Listen und Sets zum Abbruch der Auswertung:\nnix-repl\u0026gt; [ 1 (abort \u0026#34;zwei\u0026#34;) 3 ] error: evaluation aborted with the following error message: \u0026#39;zwei\u0026#39; nix-repl\u0026gt; { eins = 1 ; zwei = abort \u0026#34;zwei\u0026#34; ; drei = 3 ; } error: evaluation aborted with the following error message: \u0026#39;zwei\u0026#39; Der Unterschied zwischen throw und abort ist n√ºtzlich. In nix-env -qa und anderen Shell-Anweisungen, die Listen oder Sets von Nix Derivationen verarbeiten, wird throw verwendet, sofern bei einem Fehler in einer Derivation trotzdem alle nachfolgenden Derivationen verarbeitet werden sollen. Nat√ºrlich gibt es auch F√§lle, in denen ein Fehler zum Abbruch der ganzen Auswertung f√ºhren soll. In solchen F√§llen verwendet man abort.\nMit builtins.tryEval k√∂nnen Fehler aufgefangen werden, die mit throw ausgel√∂st worden sind:\nnix-repl\u0026gt; builtins.tryEval (1 + 2 + 3) { success = true; value = 6; } nix-repl\u0026gt; builtins.tryEval (1 + 2 + throw \u0026#34;drei\u0026#34;) { success = false; value = false; } Mit abort ausgel√∂ste Fehler kann builtins.tryEval nicht auffangen:\nnix-repl\u0026gt; builtins.tryEval (1 + 2 + abort \u0026#34;drei\u0026#34;) error: evaluation aborted with the following error message: \u0026#39;drei\u0026#39; Das assert Schl√ºsselwort erwartet zwei Ausdr√ºcke, getrennt durch ein Semikolon:\nassert \u0026lt;erster Ausdruck\u0026gt; ; \u0026lt;zweiter Ausdruck\u0026gt; Der erste Ausdruck muss boolsch sein. Der zweite Ausdruck kann beliebig sein. Wenn der erste Ausdruck zu true auswertet, wertet der gesamte assert Ausdruck zum zweiten Ausdruck aus:\nnix-repl\u0026gt; assert true ; \u0026#34;1199Panigale\u0026#34; \u0026#34;1199Panigale\u0026#34; nix-repl\u0026gt; assert 3 \u0026lt; 4 ; \u0026#34;1199\u0026#34; + \u0026#34;Panigale\u0026#34; \u0026#34;1199Panigale\u0026#34; Wenn der erste Ausdruck zu false auswertet, l√∂st der assert Ausdruck einen Fehler aus:\nnix-repl\u0026gt; assert false ; \u0026#34;1199Panigale\u0026#34; error: assertion \u0026#39;false\u0026#39; failed nix-repl\u0026gt; assert 4 \u0026lt; 3 ; \u0026#34;1199\u0026#34; + \u0026#34;Panigale\u0026#34; error: assertion \u0026#39;(__lessThan 4 3)\u0026#39; failed Fehler, die von assert ausgel√∂st worden sind, k√∂nnen mit builtins.tryEval aufgefangen werden:\nnix-repl\u0026gt; builtins.tryEval (assert true ; \u0026#34;1199Panigale\u0026#34;) { success = true; value = \u0026#34;1199Panigale\u0026#34;; } nix-repl\u0026gt; builtins.tryEval (assert false ; \u0026#34;1199Panigale\u0026#34;) { success = false; value = false; } Impurity # Die Nix Expression Language ist keine pure funktionale Sprache. Sie folgt dem Anspruch, m√∂glichst pur zu arbeiten, um die Reproduzierbarkeit von Builds sicherzustellen. Es gibt aber ein paar Ausnahmen.\nIch will kein Haskell Snob sein, bin aber geneigt, anzumerken, dass eine Programmiersprache entweder purely functional ist oder nicht, also ganz oder gar nicht. Es gibt dazwischen keinen Kompromiss, bzw. der Kompromiss w√§re immer impure. Schlie√ülich ist eine mathematische Relation entweder eine Abbildung oder eben nicht. Andererseits kann man sehr wohl auch in einer Programmiersprache, welche diese Eigenschaft nicht hat, purely functional programmieren; es obliegt dann nur dem Menschen, sicherzustellen dass der Code ausschlie√ülich statische Werte aus dem Kontext liest und klar unterscheidet zwischen Prozeduren, die Nebeneffekte hervorrufen, und solchen die das nicht tun.\nEs folgen ein paar Ursachen daf√ºr, dass die Nix Expression Language nicht pure ist. (Es gibt noch weitere.)\nbuiltins.getEnv # Die Prozedur builtins.getEnv liest Umgebungsvariable:\nnix-repl\u0026gt; builtins.getEnv \u0026#34;HOME\u0026#34; \u0026#34;/home/aramis\u0026#34; Das ist unter allen Prozeduren, die hier aufgef√ºhrt sind, der eine, von dem ich mir vorstellen k√∂nnte, dass er in die tolle Idee vom Purely Functional Package Management eine gro√üe L√ºcke rei√üt.\nbuiltins.trace # Die Prozedur builtins.trace nimmt zwei Werte entgegen, sendet den ersten Wert zur Standardfehlerausgabe und wertet selbst zum zweiten Wert aus:\nnix-repl\u0026gt; builtins.trace \u0026#34;err\u0026#34; \u0026#34;val\u0026#34; trace: err \u0026#34;val\u0026#34; Auf die Standardfehlerausgabe zu schreiben, ist strenggenommen ein Nebeneffekt, aber auch Sprachen, die sich r√ºhmen, purely functional zu sein, brauchen und haben eine trace Prozedur.\nbuiltins.toFile # Die Prozedur builtins.toFile schreibt Dateien in den Nix Store:\nnix-repl\u0026gt; builtins.toFile \u0026#34;foo.txt\u0026#34; \u0026#34;hello!\u0026#34; \u0026#34;/nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt\u0026#34; nix-repl\u0026gt; :q $ cat /nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt hello! In eine Datei zu schreiben ist nat√ºrlich ein Nebeneffekt. Zumindest wird hier sichergestellt, dass eine Datei, die einmal im Nix Store erzeugt worden ist, ihren Inhalt nicht mehr unbemerkt √§ndern kann, denn ein Hashwert ihres Inhalts wird dem Dateinamen als Pr√§fix vorangestellt. Was Nix anschlie√üend mit diesen Hashwerten macht \u0026ndash; insbesondere ob Nix wirklich jede Datei vor jeder Verarbeitung erneut hasht und mit dem Dateinamen abgleicht \u0026ndash; wei√ü ich nicht, aber das finde ich bestimmt noch heraus.\nAn der Stelle bin ich durch mit https://learnxinyminutes.com/docs/nix/. Aktuell ist mein Plan, mir als n√§chstes die Namen anzuschauen, die in der Nix Repl aufgelistet werden wenn man direkt nach dem Start die Tab-Taste dr√ºckt. Dann schaue ich mir den Inhalt des builtins Sets genauer an.\nTop-Level Namen # Es gibt ein paar Namen (f√ºr Funktionen, Prozeduren, \u0026hellip;), die nach dem Start der Nix Repl unqualifiziert im Top-Level zur Verf√ºgung stehen:\nabort baseNameOf break builtins derivation derivationStrict dirOf false fetchGit fetchMercurial fetchTarball fetchTree fromTOML import isNull map null placeholder removeAttrs scopedImport throw toString true Daneben gibt es noch eine Menge von Namen, die mit einem Unterstrich beginnen, wie z.B. __typeOf. Das scheinen allesamt Aliase f√ºr die Namen im builtins Set zu sein. Diese Namen lasse ich hier aus, weil ich vorhabe, sp√§ter auf den Inhalt von builtins einzugehen.\nDie folgenden Namen wurden schon weiter oben erl√§utert:\nabort builtins false import throw true Jetzt schaue ich mir den Rest an.\nmap # Damit kann man eine Funktion auf jedes Element in einer Liste anwenden:\nnix-repl\u0026gt; map (n : 2 * n) [ 1 2 3 ] [ 2 4 6 ] Wer schon funktional programmiert hat, d√ºrfte map kennen.\nbaseNameOf # Liefert das letzte Segment in einem Pfad:\nnix-repl\u0026gt; baseNameOf /home/aramis \u0026#34;aramis\u0026#34; nix-repl\u0026gt; baseNameOf ./. \u0026#34;aramis\u0026#34; Das funktioniert auch mit Strings:\nnix-repl\u0026gt; baseNameOf \u0026#34;/home/aramis\u0026#34; \u0026#34;aramis\u0026#34; nix-repl\u0026gt; baseNameOf \u0026#34;/home/aramis/\u0026#34; \u0026#34;aramis\u0026#34; Pfade in einem String werden aber nicht kanonisiert:\nnix-repl\u0026gt; baseNameOf \u0026#34;../../..\u0026#34; \u0026#34;..\u0026#34; dirOf # Liefert den Pfad ohne das letzte Segment:\nnix-repl\u0026gt; dirOf /home/aramis /home nix-repl\u0026gt; dirOf \u0026#34;/home/aramis\u0026#34; \u0026#34;/home\u0026#34; nix-repl\u0026gt; dirOf \u0026#34;/home/aramis/\u0026#34; \u0026#34;/home/aramis\u0026#34; nix-repl\u0026gt; dirOf \u0026#34;../../..\u0026#34; \u0026#34;../..\u0026#34; null, isNull # Offenbar gibt es einen null Wert. Ich wei√ü nicht, welche Rolle null in der Nix Expression Language spielt. Hoffentlich keine allzu gro√üe. In anderen Sprachen repr√§sentiert der null Wert h√§ufig die Abwesenheit eines \u0026ldquo;echten\u0026rdquo; Wertes.\nDer null Wert scheint seinen eigenen Datentyp zu haben. Ich greife an der Stelle vor auf builtins.typeOf. Damit kann man den Datentyp eines Ausdrucks finden:\nnix-repl\u0026gt; builtins.typeOf 0 \u0026#34;int\u0026#34; nix-repl\u0026gt; builtins.typeOf 0.0 \u0026#34;float\u0026#34; nix-repl\u0026gt; builtins.typeOf false \u0026#34;bool\u0026#34; nix-repl\u0026gt; builtins.typeOf \u0026#34;\u0026#34; \u0026#34;string\u0026#34; nix-repl\u0026gt; builtins.typeOf [] \u0026#34;list\u0026#34; nix-repl\u0026gt; builtins.typeOf {} \u0026#34;set\u0026#34; nix-repl\u0026gt; builtins.typeOf null \u0026#34;null\u0026#34; Die Funktion isNull ist markiert als deprecated. Man soll stattdessen ... == null verwenden:\nnix-repl\u0026gt; isNull null true nix-repl\u0026gt; isNull 0 false nix-repl\u0026gt; isNull \u0026#34;\u0026#34; false nix-repl\u0026gt; null == null true nix-repl\u0026gt; 0 == null false nix-repl\u0026gt; \u0026#34;\u0026#34; == null false toString # Damit k√∂nnen Ausdr√ºcke in eine Stringdarstellung √ºberf√ºhrt werden:\nnix-repl\u0026gt; toString 123 \u0026#34;123\u0026#34; nix-repl\u0026gt; toString \u0026#34;Das ist schon ein String\u0026#34; \u0026#34;Das ist schon ein String\u0026#34; Pfade werden kanonisiert:\nnix-repl\u0026gt; toString ./. \u0026#34;/home/aramis\u0026#34; F√ºr andere Datentypen liefert toString Ergebnisse, die ich so nicht erwartet h√§tte:\nnix-repl\u0026gt; toString 0.0 \u0026#34;0.000000\u0026#34; nix-repl\u0026gt; toString true \u0026#34;1\u0026#34; nix-repl\u0026gt; toString false \u0026#34;\u0026#34; nix-repl\u0026gt; toString [] \u0026#34;\u0026#34; nix-repl\u0026gt; toString [ 1 2 3 ] \u0026#34;1 2 3\u0026#34; nix-repl\u0026gt; toString [ 1 2 3 [ 4 5 6 ] ] \u0026#34;1 2 3 4 5 6\u0026#34; nix-repl\u0026gt; toString null \u0026#34;\u0026#34; Auf Sets kann toString nur operieren wenn darin ein spezieller Schl√ºssel __toString oder outPath vorhanden ist:\nnix-repl\u0026gt; toString { a = 1 ; b = 2 ; c = 3 ; } error: cannot coerce a set to a string nix-repl\u0026gt; toString { a = 1 ; b = 2 ; c = 3 ; outPath = \u0026#34;asdf\u0026#34; ; } \u0026#34;asdf\u0026#34; nix-repl\u0026gt; toString ... { a = 1 ; b = 2 ; c = 3 ; __toString = self : self.a } \u0026#34;1\u0026#34; break # Die Prozedur break hat hier nichts mit While-Schleifen oder √§hnlichem zu tun. Man kann damit Breakpoints im Code setzen, an denen der Interpreter im Debug Modus die Auswertung pausiert und in die Repl wechselt. Um den Interpreter im Debug Modus zu starten, muss das Flag --debugger mit √ºbergeben werden.\nDa wir hier nicht imperativ sondern deklarativ bzw. funktional programmieren, kann break nicht als Anweisung im Code platziert werden ohne selbst zu irgendetwas auszuwerten. Deswegen erwartet break ein Argument und wertet zu diesem Argument aus:\nnix-repl\u0026gt; break 1 1 removeAttrs # Die Funktion removeAttrs nimmt ein Set und eine Liste mit Schl√ºsseln entgegen. Die aufgef√ºhrten Schl√ºssel werden aus dem Set entfernt. Schl√ºssel, die in dem Set nicht vorkommen, werden ignoriert:\nnix-repl\u0026gt; removeAttrs { x = 1 ; y = 2 ; z = 3 ; } [ \u0026#34;a\u0026#34; \u0026#34;x\u0026#34; \u0026#34;z\u0026#34; ] { y = 2; } Ich glaube, diese Stelle markiert einen √úbergang. Ich habe zun√§chst versucht, die Nix Expression Language ganz allgemein als Programmiersprache zu betrachten, ohne darauf R√ºcksicht zu nehmen, wof√ºr sie tats√§chlich eingesetzt werden soll. Ich denke, dass das ab hier immer weniger m√∂glich sein wird.\nfromTOML # Ich bin mit TOML nicht besonders vertraut, aber ich glaube, es ist nicht viel mehr als eine Folge von zeilenweisen Schl√ºssel-Wert-Zuweisungen in der Form key=value. Die Funktion fromTOML scheint TOML Markup in ein Nix Set zu √ºberf√ºhren:\nnix-repl\u0026gt; fromTOML \u0026#34;a=1\\nb=2\u0026#34; { a = 1; b = 2; } scopedImport # Das ist nirgendwo richtig dokumentiert und wird nicht einmal im Nix Manual erw√§hnt. Es gibt eine Issue auf Github dazu:\nhttps://github.com/NixOS/nix/issues/1450\nEin paar Ausz√ºge:\n\u0026ldquo;scopedImport has nasty performance consequences since it disables the parser/evaluation cache\u0026rdquo; \u0026ldquo;It allows doing some pretty nasty/nifty things like overriding every primop (including import)\u0026rdquo; Ok, also die Finger davon lassen. Es h√§tte mich trotzdem ein bisschen interessiert, wie man das benutzt, aber nicht so sehr, dass ich an der Stelle weiterbuddeln m√∂chte.\nfetchGit, fetchMercurial, fetchTarball, fetchTree # Mit den Fetch-Befehlen lassen sich Dateien herunterladen und in den Nix Store schreiben. fetchMercurial und fetchTree sind undokumentiert, also schaue ich mir zun√§chst die anderen beiden an.\nfetchGit holt einen Pfad aus einem Git Repository und schreibt ihn in den Nix Store. In der Nix Repl erh√§lt man mit :doc fetchGit reichlich Dokumentation dazu, wie das genau zu benutzen ist. Ich m√∂chte das hier nicht alles wiedergeben.\nfetchTarball l√§dt ein Tar-Archiv herunter und entpackt es in den Nix Sore. Das Tar-Archiv kann (oder muss?) zus√§tzlich mit gzip, bzip7 oder xv komprimiert sein. Die Dokumentation in der Repl dazu ist auch recht ausf√ºhrlich.\nfetchMercurial ist in der Repl nicht dokumentiert. Ich nehme an, es ist wie fetchGit aber f√ºr Mercurial Repositories.\nfetchTree ist ebenfalls undokumentiert in der Repl. Das Nix Manual erw√§hnt, dass fetchTree die Funktionalit√§t der anderen Fetch-Befehle in sich vereint und somit beliebige Quellen herunterladen kann. M√∂glicherweise ist das nur eine Fassade, die je nach Quelle das passende Backend w√§hlt, ungef√§hr so wie aunpack das Entpacken von Archivdateien handhabt.\nderivation, derivationStrict # Beides hat in der Nix Repl keine Dokumentation. Was ist eine Derivation? Man kann das w√∂rtlich mit Ableitung √ºbersetzen. Im Kontext von Nix ist damit eine sogenannte Build Action gemeint. Ich nehme an, das ist ein Rezept f√ºr den Bau eines Softwarepaketes und seine \u0026ldquo;Installation\u0026rdquo; im Nix Store. Laut Handbuch ist derivation die wichtigste built-in Funktion: schlie√ülich ist Nix genau daf√ºr gedacht/gemacht, solche Derivationen zu beschreiben und auszuf√ºhren.\nderivation verarbeitet ein Set, das genau beschreibt, was gebaut wird, und zwar mit den folgenden Schl√ºsseln (Attributen):\nsystem Nix Systemtyp, z.B. \u0026quot;i686-linux\u0026quot; oder \u0026quot;x86_64-darwin\u0026quot; siehe nix -vv --version name der Name des Pakets builder das Programm, welches zum Bauen verwendet wird kann eine Derivation oder eine lokale Datei sein (ein Script) Die Attribute der Derivation werden als Umgebungsvariable √ºbergeben: Strings und Zahlen werden unver√§ndert √ºbergeben. Pfade werden zun√§chst in den Nix Store kopiert und der Zielpfad landet in der Umgebungsvariable. Derivationen werden gebaut und der Pfad des Zielartefakts landet in der Umgebungsvariable. Listen werden leerzeichensepariert √ºbergeben. true wird als 1 √ºbergeben. false und null werden als \u0026quot;\u0026quot; √ºbergeben. args optionale Liste von CLI-Argumenten f√ºr das bauende Programm outputs optionale Liste von Ausgabepfaden Normalerweise gibt es nur einen Outputpfad out, aber man kann diesen Schl√ºssel verwenden, um verschiedene Ausgabepfade zu deklarieren, bspw. [ \u0026quot;lib\u0026quot; \u0026quot;headers\u0026quot; \u0026quot;doc\u0026quot; ], dann stehen dem bauenden Programm drei Pfade statt nur einem zur Verf√ºgung, die separat garbage-collected werden k√∂nnen. Damit habe ich eine erste, grobe Vorstlelung davon, wie Nix baut.\nF√ºr derivationStrict habe ich nirgendwo Dokumentation gefunden.\nplaceholder # Nimmt einen Ausgabepfad entgegen (\u0026quot;out\u0026quot;, \u0026quot;bin\u0026quot;, \u0026quot;dev\u0026quot;, \u0026hellip;) und liefert einen Plazhalter, der beim Bauen durch den Ausgabepfad ersetzt wird. Es scheint wirklich eine Funktion zu sein:\nnix-repl\u0026gt; placeholder \u0026#34;out\u0026#34; \u0026#34;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9\u0026#34; nix-repl\u0026gt; placeholder \u0026#34;out\u0026#34; \u0026#34;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9\u0026#34; nix-repl\u0026gt; placeholder \u0026#34;out\u0026#34; \u0026#34;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9\u0026#34; Keine Ahnung, wof√ºr das gut ist.\nBuilt-ins # Im letzten Abschnitt habe ich mir die Namen angeschaut, die nach dem Start der Nix Repl unqualifiziert im Top-Level verf√ºgbar sind. Unterhalb von builtins gibt es eine ganze Reihe weiterer Namen. Die schaue ich mir jetzt an. Einige davon sind nicht neu, weil sie auch im Top-Level verf√ºgbar sind. Die lasse ich unerw√§hnt aus.\nbuiltins.add # Die Funktion hinter dem + Operator:\nnix-repl\u0026gt; builtins.add 3 4 7 builtins.addErrorContext # Daf√ºr finde ich keine Dokumentation.\nbuiltins.all # Pr√ºft ob ein Pr√§dikat auf alle Elemente einer Liste zutrifft:\nnix-repl\u0026gt; builtins.all ( n : n \u0026gt; 3 ) [ 1 2 3 ] false nix-repl\u0026gt; builtins.all ( n : n \u0026gt; 3 ) [ 4 5 6 ] true builtins.any # Pr√ºft ob ein Pr√§dikat auf mindestens ein Element einer Liste zutrifft:\nnix-repl\u0026gt; builtins.any ( n : n \u0026lt; 3 ) [ 1 2 3 ] true nix-repl\u0026gt; builtins.any ( n : n \u0026lt; 3 ) [ 4 5 6 ] false builtins.appendContext # Daf√ºr finde ich keine Dokumentation.\nbuiltins.attrNames # Liefert eine sortierte Liste der Schl√ºssel in einem Set:\nnix-repl\u0026gt; builtins.attrNames { a = 1 ; b = 2 ; c = 3 ; } [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] builtins.attrValues # Wie Sartres Autodidakt, gehe ich die Built-ins in alphabetischer Reihder sonderliche Autodidakt in Bouville, gehe ich die Built-ins in alphabetischer Reihenfolge durch. Immerhin sind es bei mir nicht die B√ºcher einer ganzen Bibliothek, sondern nur ein paar Nix-Funktionen. Jetzt w√§re builtins.deepSeq\nnix-repl\u0026gt; builtins.attrValues { a = 3 ; b = 2 ; c = 1 ; } [ 3 2 1 ] builtins.bitAnd # Bitweise Konjunktion zweier Integers:\nnix-repl\u0026gt; builtins.bitAnd 123 456 72 Rechnen wir das spa√üeshalber durch:\n123 = 64 + 32 + 16 + 8 + 2 + 1 = 2^6 + 2^5 + 2^4 + 2^3 + 2^1 + 2^0 = 1111011 456 = 256 + 128 + 64 + 8 = 2^8 + 2^7 + 2^6 + 2^3 = 111001000 001111011 + 111001000 = 001001000 = 2^3 + 2^6 = 72 builtins.bitOr # Bitweise Disjunktion zweier Integers:\nnix-repl\u0026gt; builtins.bitOr 123 456 507 builtins.bitXor # Bitweise Kontravalenz (\u0026ldquo;exklusive Disjunktion\u0026rdquo;) zweiter Integers:\nnix-repl\u0026gt; builtins.bitXor 123 456 435 builtins.builtins # Offenbar enth√§lt das builtins Set eine Referenz auf sich selbst.\nnix-repl\u0026gt; builtins.builtins == builtins true nix-repl\u0026gt; builtins.builtins.builtins.builtins == builtins true Schrullig, aber was soll\u0026rsquo;s.\nbuiltins.catAttrs # Das nimmt einen Schl√ºssel (String) und sammelt aus einer Liste von Sets die Werte f√ºr diesen Schl√ºssel ein:\nnix-repl\u0026gt; builtins.catAttrs \u0026#34;a\u0026#34; ... [ { a = 1 ; } { b = 2 ; } { a = 3 ; } ] [ 1 3 ] builtins.ceil # Liefert f√ºr eine Zahl x die n√§chste Ganzzahl n sodass x \u0026lt;= n:\nnix-repl\u0026gt; builtins.ceil 1.5 2 nix-repl\u0026gt; builtins.ceil 2 2 builtins.compareVersions # Vergleicht zwei Strings anhand der typischen Ordnung von Versionsnummern. Das Ergebnis ist -1, 0 oder 1, je nachdem ob das erste Argument gegen√ºber dem zweiten kleiner, gleich oder gr√∂√üer ist.\nnix-repl\u0026gt; builtins.compareVersions \u0026#34;0.0.0\u0026#34; \u0026#34;0.0.1\u0026#34; -1 nix-repl\u0026gt; builtins.compareVersions \u0026#34;0.0.1\u0026#34; \u0026#34;0.0.1\u0026#34; 0 nix-repl\u0026gt; builtins.compareVersions \u0026#34;0.0.2\u0026#34; \u0026#34;0.0.1\u0026#34; 1 builtins.concatLists # Konkateniert Listen:\nnix-repl\u0026gt; builtins.concatLists [ [ 1 2 3 ] [ 4 5 6 ] ] [ 1 2 3 4 5 6 ] builtins.concatMap # Das ist eine Verkettung von map und concatLists. Das hei√üt, f√ºr eine Funktion f und eine Liste ls sind die folgenden beiden Ausdr√ºcke √§quivalent:\nbuiltins.concatLists (map f ls)\nbuiltins.concatMap f ls\nBeispielsweise:\nnix-repl\u0026gt; with ... { f = map ( n : 2 * n ) ; ... ls = [ [ 1 2 3 ] [ 4 5 6 ] ] ; ... } ; ... builtins.concatLists ( map f ls ) [ 2 4 6 8 10 12 ] nix-repl\u0026gt; with ... { f = map ( n : 2 * n ) ; ... ls = [ [ 1 2 3 ] [ 4 5 6 ] ] ; ... } ; ... builtins.concatMap f ls [ 2 4 6 8 10 12 ] builtins.concatStringsSep # Konkateniert Strings mit einem Trennzeichen:\nnix-repl\u0026gt; builtins.concatStringsSep \u0026#34;/\u0026#34; [ \u0026#34;usr\u0026#34; \u0026#34;local\u0026#34; \u0026#34;bin\u0026#34; ] \u0026#34;usr/local/bin\u0026#34; builtins.currentSystem # Liefert einen Namen f√ºr das System, auf dem Nix gerade l√§uft:\nnix-repl\u0026gt; builtins.currentSystem \u0026#34;x86_64-linux\u0026#34; builtins.currentTime # Liefert die aktuelle Posix-Zeit:\nnix-repl\u0026gt; builtins.currentTime 1661168166 builtins.seq # Wie der sonderliche Autodidakt in Bouville, gehe ich die Built-ins in alphabetischer Reihenfolge durch. Immerhin sind es bei mir nicht die B√ºcher einer ganzen Bibliothek, sondern nur ein paar Nix-Funktionen. Jetzt w√§re builtins.deepSeq an der Reihe, aber das w√§re Quatsch ohne vorher builtins.seq zu betrachten. Deswegen ziehe ich das vor.\nNix wertet verz√∂gert aus (so wie Haskell). Das bedeutet, dass Ausdr√ºcke erst dann ausgewertet werden wenn sie tats√§chlich gebraucht werden und auch nur so weit wie es tats√§chlich n√∂tig ist. Ich m√∂chte das kurz an einem Beispiel demonstrieren. Das geht vielleicht am besten mit einer Funktion, die viel Rechenzeit frisst. Ad hoc f√§llt mir die Fibonacci-Funktion ein. Das hier w√§re eine einfache Implementierung daf√ºr in Haskell:\n-- Haskell: fib n = if n \u0026lt; 1 then 0 else if n \u0026lt; 2 then 1 else fib ( n - 1 ) + fib ( n - 2 ) Das ist so rechenaufw√§ndig, dass ich mit meinem Rechner auf fib 32 schon ein paar Sekunden warten muss, also ein guter Kandidat. Wir k√∂nnen das auch als Lambda-Ausdruck schreiben. Dann wandert der Parameter n nach rechts hinter das = Zeichen:\n-- Haskell: fib = \\ n -\u0026gt; if n \u0026lt; 1 then 0 else if n \u0026lt; 2 then 1 else fib ( n - 1 ) + fib ( n - 2 ) In Nix m√ºssen Funktionen als Lambda-Ausdr√ºcke notiert werden. Die konventionelle Notation mit dem Parameter auf der linken Seite wird nicht unterst√ºtzt. Mein erster Versuch, diese Funktion in Nix zu schreiben, sah so aus:\nnix-repl\u0026gt; fib = n : ... if n \u0026lt; 1 then 0 ... else if n \u0026lt; 2 then 1 ... else fib ( n - 1 ) + fib ( n - 2 ) error: undefined variable \u0026#39;fib\u0026#39; Nix unterst√ºtzt keine rekursiven Funktionen, jedenfalls nicht auf diese Weise. Damit das klappt, m√ºssen wir die Funktion in ein rekursives Set stecken:\nnix-repl\u0026gt; funs = rec ... { fib = n : ... if n \u0026lt; 1 then 0 ... else if n \u0026lt; 2 then 1 ... else fib ( n - 1 ) + fib ( n - 2 ) ; ... } nix-repl\u0026gt; funs.fib 32 2178309 Nix rechnet funs.fib 32 schneller aus als Haskell aber es dauert mit meinem Rechner immer noch mehr als eine Sekunde, bis der Interpreter die Berechnung gestemmt hat und das Ergebnis ausdruckt. Damit haben wir alles beisammen um verz√∂gerte Auswertung zu demonstrieren. Daf√ºr erg√§nzen wir das Set um zwei weitere Schl√ºssel-Wert-Paare:\nnix-repl\u0026gt; funs = rec ... { fib = n : ... if n \u0026lt; 1 then 0 ... else if n \u0026lt; 2 then 1 ... else fib ( n - 1 ) + fib ( n - 2 ) ; ... ... fib35 = fib 35 ; ... x = 1 ; ... } nix-repl\u0026gt; Den Wert f√ºr den Schl√ºssel fib35 auszurechnen, sollte ein paar Sekunden dauern, aber die Nix Repl nimmt das Set ohne Zeitverz√∂gerung entgegen. Das spricht daf√ºr, dass der Wert f√ºr fib35 nicht sofort berechnet wird. Wir k√∂nnen uns auch den Wert f√ºr den Schl√ºssel x ohne Zeitverz√∂gurung ausgeben lassen:\nnix-repl\u0026gt; funs.x 1 Erst wenn wir uns den Wert f√ºr fib35 ausgeben lassen, gibt es eine deutliche Verz√∂gerung von mehreren Sekunden, die darauf hinweist, dass der Wert jetzt tats√§chlich berechnet wird:\nnix-repl\u0026gt; funs.fib35 9227465 Wenn wir uns im Anschluss noch einmal das ganze Set ausgeben lassen, geschieht das wieder ohne Verz√∂gerung:\nnix-repl\u0026gt; funs { fib = ¬´lambda @ (string):1:14¬ª; fib35 = 9227465; x = 1; } Der Wert f√ºr den Schl√ºssel fib35 wurde schon berechnet und wird hier einfach wiederverwendet anstatt ihn ein zweites Mal zu berechnen. Deswegen erfolgt die Ausgabe ohne zeitliche Verz√∂gerung. Wenn wir vorher nicht funs.fib35 ausgewertet h√§tten, dann h√§tten wir an dieser Stelle ein paar Sekunden auf die Auswertung warten m√ºssen.\nDas ist verz√∂gerte Auswertung: die Ausdr√ºcke und Teilausdr√ºcke werden nicht sofort ausgewertet sondern erst dann wenn ihr Wert tats√§chlich ben√∂tigt wird, bspw. um eine Ausgabe zu erzeuen.\nIm Allgemeinen ist das eine gute Sache, aber manchmal m√∂chte man, dass die Auswertung nicht verz√∂gert sondern sofort stattfindet. Das ist vor allem dann wichtig, wenn zwei Ausdr√ºcke irgendwelche externen Effeke haben und diese Effekte in einer bestimmen Reihenfolge auftreten sollen. Dann muss man irgendwie sicherstellen, dass die Ausdr√ºcke in der richtigen Reihenfolge ausgewertet werden. In Programmiersprachen, die standardm√§√üig strikt (i.e. unverz√∂gert) auswerten, hat man dieses Problem nicht. Da ist die Auswertungsreihenfolge dadurch vorgegeben, in welcher Reihenfolge man Ausdr√ºcke notiert. In Programmiersprachen, die standardm√§√üig verz√∂gert auswerten, ben√∂tigt man daf√ºr besondere Hilfsmittel, die eine strikte Auswertung sicherstellen.\nHier kommt builtins.seq ins Spiel. builtins.seq nimmt zwei Ausdr√ºcke entgegen, wertet den ersten Ausdruck aus, verwirft das Resultat und wertet dann den zweiten Ausdruck aus:\nnix-repl\u0026gt; builtins.seq 1 2 2 So wird sichergestellt, dass der erste Ausdruck vor dem zweiten ausgewertet wird. Ich kann gerade kein leicht demonstrierbares Beispiel aus dem √Ñrmel sch√ºtteln, bei dem das eine Rolle spielen w√ºrde, aber wenn bspw. der erste Ausdruck eine Datei schreibt und der zweite diese Datei liest, stellt builtins.seq sicher, dass das Schreiben tats√§chlich vor dem Lesen erfolgt. Ohne builtins.seq w√§re diese Reihenfolge wegen der verz√∂gerten Auswertung nicht sichergestellt.\nbuiltins.deepSeq # Die Auswertung von builtins.seq e1 e2 ist zwar strikt im Ausdruck e1, aber mit einem Haken: der Ausdruck e1 wird nur oberfl√§chlich strikt ausgewertet. Ich erkl√§re kurz, was das bedeutet. Es gibt einfache Ausdr√ºcke, die direkt ausgewertet werden k√∂nnen ohne daf√ºr weiter vereinfacht werden zu m√ºssen. Das sind bspw. einfache Zahlenausdr√ºcke 123 oder Zeichenketten wie \u0026quot;asdf\u0026quot;. Daneben gibt es aber auch komplexe Ausdr√ºcke, die bei der Auswertung zun√§chst auf einen einfachen Ausdruck reduziert werden m√ºssen. Das ist der Fall wenn ein Ausdruck Funktionen (bzw. Operationen) enth√§lt, die bei der Auswertung angewendet werden m√ºssen. Diese Reduktion auf einen einfachen Ausdruck erfolgt schrittweise. Hier ist ein Ausdruck, der in mehreren Schritten ausgewertet werden muss:\nnix-repl\u0026gt; let ... f1 = n : 1 + n ; ... f2 = n : 2 + n ; ... f3 = n : 3 + n ; ... in ... f3 ( f2 ( f1 0 ) ) Hier ist eine m√∂gliche Auswertung f√ºr diesen Ausdruck:\n=\u0026gt; f3 ( f2 ( f1 0 ) ) -----------------------------------^^^^^^^^^^^^^---------- =\u0026gt; f3 ( f2 ( ( n : 1 + n ) 0 ) ) -----------------------------------^^^^^^^^^^^^^^^-------- =\u0026gt; f3 ( f2 ( 1 + 0 ) ) ---------------------------------^^^^^^^^^^^^^^^^^^^------ =\u0026gt; f3 ( f2 1 ) -------------------^^^^^^^^^^^^^-------------------------- =\u0026gt; f3 ( ( n : 2 + n ) 1 ) -------------------^^^^^^^^^^^^^^^------------------------ =\u0026gt; f3 ( 2 + 1 ) -----------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---- =\u0026gt; f3 3 ---^^^^^^^^^^^^^------------------------------------------ =\u0026gt; ( n : 3 + n ) 3 ---^^^^^^^^^^^^^^^---------------------------------------- =\u0026gt; 3 + 3 ---^^^^^-------------------------------------------------- =\u0026gt; 6 Ob die Auswertung tats√§chlich genau in dieser Reihenfolge stattfindet, wei√ü ich nicht. Es gibt da verschiedene M√∂glichkeiten. Relevant ist f√ºr uns nur, dass die Auswertung schrittweise erfolgt.\nWenn das nun der Teilausausdruck e1 im Ausdruck builtins.seq e1 e2 w√§re, w√ºrde builtins.seq nicht garantieren, dass das ganze vor der Auswertung von e2 vollst√§ndig auf den Wert 6 reduziert wird. builtins.seq w√ºrde lediglich gew√§hrleisten, dass e1 auf der ersten Ebene strikt ausgewertet wird, also vielleicht bis f3 ( f2 ( 1 + 0 ) ). Damit w√§re die Funktion f1 schon vollst√§ndig abgefr√ºhst√ºckt, aber wenn sich in f2 oder f3 noch irgendwelche externen Nebeneffekte verbergen w√ºrden, w√§re durch builtins.seq nicht sichergestellt, dass diese Effekte vor der Auswertung von e2 eintreten. Genau das war gemeint mit der Feststellung, builtins.seq w√ºrde e1 nur oberfl√§chlich strikt auswerten.\nIch m√∂chte hier anmerken, dass ich mich mit dieser Erl√§uterung recht weit aus dem Fenster lehne. Ich wei√ü nicht, wie der Nix Interpreter tats√§chlich auswertet und ob meine Charakterisierung einer nur oberfl√§chlich strikten Auswertung den Nagel auf den Kopf trifft. Ich hoffe, dass es hier kein fundamentales Missverst√§ndnis meinerseits gibt, das diese Erl√§uterung zu Stuss macht. In jedem Fall ist das gegenw√§rtig mein mentales Modell dieser Sache.\nWenn e1 eine Prozedur wie fetchGit ist, die direkt einen externen Nebeneffekt erzeugt, gen√ºgt die oberfl√§chlich strikte Auswertung durch builtins.seq, aber wenn ein komplexer Ausdruck vollst√§ndig, also in voller Tiefe, strikt ausgewertet werden soll, muss daf√ºr builtins.deepSeq verwendet werden.\nMeine Motivation, daf√ºr ein gutes Beispiel zu finden, ist bei Null, denn ich habe noch reichlich Built-ins vor mir. Vielleicht erg√§nze ich sp√§ter eins.\nbuiltins.div # Die Funktion hinter dem Divisionsoperator /, den wir schon weiter oben behandelt haben:\nnix-repl\u0026gt; builtins.div 7.0 2 3.5 nix-repl\u0026gt; builtins.div 7 2 3 builtins.elem # Pr√ºft, ob ein Wert als Element in einer Liste enthalten ist:\nnix-repl\u0026gt; builtins.elem 3 [ 1 2 3 ] true nix-repl\u0026gt; builtins.elem 4 [ 1 2 3 ] false builtins.elemAt # Liefert das n-te Element einer Liste:\nnix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] 0 \u0026#34;a\u0026#34; nix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] 1 \u0026#34;b\u0026#34; nix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] 2 \u0026#34;c\u0026#34; nix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] 3 error: list index 3 is out of bounds Das hier ist aufschlussreich:\nnix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] -1 error: value is the partially applied built-in function \u0026#39;elemAt\u0026#39; while an integer was expected Die Fehlermeldung legt nahe, dass das Minuszeichen hier nicht als Vorzeichen sondern als Subtraktionsoperator interpretiert wird. Um das zu √§ndern, muss man Klammern setzen:\nnix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] (-1) error: list index -1 is out of bounds Immer noch ein Fehler, aber ein besserer.\nbuiltins.fetchurl # L√§dt etwas herunter, legt es im Nix Store ab und gibt den Pfad aus:\nnix-repl\u0026gt; builtins.fetchurl https://arxiv.org/pdf/2208.10524 [4.2 MiB DL]\u0026#34;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\u0026#34; Wenn man schon im Vorfeld den SHA-256 Hash der Datei kennt, kann man den Hash mit angeben und damit kryptografisch verifizieren, dass es die richtige Datei ist:\nnix-repl\u0026gt; builtins.fetchurl ... { url = https://arxiv.org/pdf/2208.10524 ; ... sha256 = \u0026#34;cbd791862a937ac2f823b81a771e63bdb5313d204e0011965c833ee3889fdc73\u0026#34; ; ... } \u0026#34;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\u0026#34; Wenn der Hash nicht passt, l√∂st das einen Fehler aus:\nnix-repl\u0026gt; builtins.fetchurl ... { url = https://arxiv.org/pdf/2208.10524 ; ... sha256 = \u0026#34;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\u0026#34; ; ... } error: hash mismatch in file downloaded from \u0026#39;https://arxiv.org/pdf/2208.10524\u0026#39;: specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz got: sha256:0wywky4f6gl3bjb1202f40yk3ddxccg7f6mq4gwc4ylk5a393myb [4.2 MiB DL] Der Hash in der Fehlermeldung unterscheidet sich von dem Hash in der Anweisung:\nsha256 = \u0026#34;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\u0026#34; ; ... specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz Ich nehme an, dass Nix einfach nur eine andere Darstellung verwendet um die Hashes kompakter zu machen. Man sieht das auch daran, dass der Hash im Nix Store Pfad ein anderer ist. Es w√§re gut, zu wissen, welcher Hash und welche Darstellung das genau ist, aber darum k√ºmmere ich mich sp√§ter.\nIch bin mir gar nich sicher, ob Nix die Datei jetzt noch einmal heruntergeladen hat oder einfach die bereits heruntergeladene Datei wiederverwendet hat. Also w√ºrde ich gern die Datei aus dem Store l√∂schen und dann noch einmal herunterladen. Wie geht das? So:\n$ nix-store --delete /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524 Aber Achtung: Bevor man die Datei aus dem Store l√∂schen kann, muss man die Nix Repl terminieren. Solange die Repl noch l√§uft, verweigert Nix das L√∂schen, weil die Datei noch in Verwendung ist.\nIch lade die Datei also noch einmal mit einem falschen Hash herunter:\nnix-repl\u0026gt; builtins.fetchurl ... { url = https://arxiv.org/pdf/2208.10524 ; ... sha256 = \u0026#34;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\u0026#34; ; ... } error: hash mismatch in file downloaded from \u0026#39;https://arxiv.org/pdf/2208.10524\u0026#39;: specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz got: sha256:0wywky4f6gl3bjb1202f40yk3ddxccg7f6mq4gwc4ylk5a393myb [4.2 MiB DL] n Die finale Ausgabe stimmt √ºberein, aber die Ausf√ºhrung hat deutlich l√§nger gedauert, weil Nix die Datei wirklich ein weiteres Mal heruntergeladen hat.\nMit builtins.fetchurl haben wir also die M√∂glichkeit, beliebige Dateien aus dem Netz herunterzuladen und die Echtheit dieser Dateien durch Angabe eines SHA-256 Hashes abzusichern. Das bedeutet, dass wir Dateien, deren Hash wir bereits kennen, aus beliebigen Quellen herunterladen k√∂nnen, ohne uns Sorgen dar√ºber machen zu m√ºssen, dass vielleicht jemand diese Dateien ohne unser Wissen ver√§ndert haben k√∂nnte. Das ist gro√üartig! Nix ist ein System f√ºr die Verwaltung von Softwarepaketen, aber auch jenseits davon fallen mir f√ºr so etwas viele Einsatzm√∂glichkeiten ein.\nbuiltins.filter # Bereinigt eine Liste um alle Elemente, denen ein bestimmtes Pr√§dikat fehlt:\nnix-repl\u0026gt; isEven = n : n / 2 == n / 2.0 nix-repl\u0026gt; builtins.filter isEven ... [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ] [ 2 4 6 8 10 12 14 16 ] builtins.filterSource # Damit kann man Quellen in den Nix Store √ºbertragen und dabei gewisse Dateien herausfiltern. N√§her will ich das hier nicht betrachten. Die Dokumentation enth√§lt eine Warnung, die man vor dem Gebrauch lesen und verstehen sollte.\nbuiltins.findFile # Weder in der Nix Repl noch im Handbuch dokumentiert.\nbuiltins.floor # Liefert f√ºr eine Zahl x die n√§chste Ganzzahl n sodass x \u0026gt;= n:\nnix-repl\u0026gt; builtins.floor 1.5 1 nix-repl\u0026gt; builtins.floor 1 1 builtins.foldl' # Damit kann man eine Liste von Werten sozusagen \u0026ldquo;zusammenfalten\u0026rdquo; auf einen einzigen Wert, indem man sukzessive von links nach rechts eine Funktion darauf anwendet, die jeweils zwei Werte mit einander kombiniert. Man muss einen Startwert mit √ºbergeben. Ausgehend von diesem Startwert werden sukzessive die Elemente der Liste eingesammelt und mit dem bisherigen Zwischenergebnis kombiniert.\nHier wird eine Liste von Zahlen via builtins.add mit dem Startwert 0 zusammengefaltet:\nnix-repl\u0026gt; builtins.foldl\u0026#39; builtins.add 0 [ 1 2 3 4 5 6 ] 21 Das entspricht einer Verallgemeinerung der zweiwertigen Addition auf beliebig viele Werte. Mit builtins.foldl' lassen sich viele zweiwertige Funktionen auf nat√ºrliche Weise verallgemeinern auf beliebig viele Werte. Das setzt nat√ºrlich voraus, dass es zu den Werten, auf denen man operiert einen neutralen Wert gibt, also eine Entsprechung zur Null bei den Zahlen. Mathematisch ist so eine Struktur artikuliert im algebraischen Begriff eines Monoiden. Damit muss man sich aber nicht unbedingt befassen: in der Praxis kann man auch einfach ein paar Werte mit builtins.foldl' zusammenstauchen, ohne sich vorher Gedanken dar√ºber zu machen, ob man wirklich eine Null zur Verf√ºgung hat.\nDas zweite l in foldl steht f√ºr left, weil von rechts nach links gefaltet wird. Nix stellt nur diese eine Funktion als Built-in zur Verf√ºgung, aber im Allgemeinen gibt es auch Faltungsfunktionen die von links nach rechts falten. Die hei√üen dann typischerweise foldr. Bei der Addition macht das keinen Unterschied, aber bei Funktionen, die nicht kommutativ sind ,bei denen also das Ergebnis von der Reihenfolge der beiden Argumente abh√§ngt, h√§ngt auch das Ergebnis einer Faltung davon ab, in welche Richtung gefaltet wird.\nDas abschlie√üende Hochkomma im Namen builtins.foldl' soll anzeigen, dass diese Funktion strikt ausgewertet wird. Ich bin weiter oben darauf eingegangen, dass Nix standardm√§√üig verz√∂gert auswertet und dass man in manchen F√§llen lieber eine strikte Auswertung haben m√∂chte. Das hier ist ein solcher Fall. Das Hochkomma ist nur eine Namenskonvention, die warscheinlich daher r√ºhrt, dass man sich hier recht stark an Haskell orientiert. In Haskell wertet die foldl Funktion aus der Standardbibliothek verz√∂gert aus. Daneben gibt es auch eine mit Hochkomma markierte foldl' Funktion, die strikt auswertet. In der Praxis will man eigentlich immer eine strikte Faltung nach links, also w√§re es vielleicht besser gewesen, die strikte Variante foldl (ohne Hochkomma) zu nennen. Schade, dass Nix sich an dieser ung√ºnstigen Konvention orientiert, zumal ohnehin nur diese eine Faltungsfunktion als Built-in mitgeliefert wird.\nbuiltins.fromJSON # Parst und √ºberf√ºhrt JSON-Werte in Nix-Werte:\nnix-repl\u0026gt; builtins.fromJSON \u0026#34;{ \\\u0026#34;a\\\u0026#34; : 1 , \\\u0026#34;b\\\u0026#34; : 2 , \\\u0026#34;c\\\u0026#34; : 3 }\u0026#34; { a = 1; b = 2; c = 3; } nix-repl\u0026gt; builtins.fromJSON \u0026#34;[ 1, 2, 3 ]\u0026#34; [ 1 2 3 ] nix-repl\u0026gt; builtins.fromJSON \u0026#34;123.456\u0026#34; 123.456 nix-repl\u0026gt; builtins.fromJSON \u0026#34;\\\u0026#34;asdf\\\u0026#34;\u0026#34; \u0026#34;asdf\u0026#34; builtins.functionArgs # Nimmt eine Funktion entgegen und liefert ein Set mit den Namen ihrer Parameter als Schl√ºssel. Die Werte geben f√ºr jeden Parameter Auskunft dar√ºber, ob es zu ihm einen Standardwert gibt:\nnix-repl\u0026gt; builtins.functionArgs ( { x , y ? 123 } : x + y ) { x = false; y = true; } Das Fragezeichen ist neue Syntax f√ºr mich. Ziemlich weit am Anfang dieses Dokumentes hatte ich Set Patterns erw√§hnt, die man verwenden kann, um benannte Funktionsparameter aufzuschreiben:\nnix-repl\u0026gt; ({a,b} : a + b) { a = 5 ; b = 6 ; } 11 Offenbar kann man mit dem Fragezeichen Standardargumente festhalten:\nnix-repl\u0026gt; ({a?5,b?6} : a + b) {} 11 nix-repl\u0026gt; ({a?5,b?6} : a + b) { a = 11 ; } 17 nix-repl\u0026gt; ({a?5,b?6} : a + b) { b = 12 ; } 17 nix-repl\u0026gt; ({a?5,b?6} : a + b) { a = 11 ; b = 12 ; } 23 Die sinnvolle Verwendung von builtins.functionArgs setzt nat√ºrlich voraus, dass eine Funktion mit benannten Parametern via Set Patterns aufgeschrieben worden ist. F√ºr reine Lambda-Funktionen liefert builtins.functionArgs immer ein leeres Set:\nnix-repl\u0026gt; builtins.functionArgs ( a : b : a + b ) { } builtins.genList # builtins.genlist f n erzeugt eine Liste der L√§nge n, wobei die Funktion f die jeweiligen Elemente aus den jeweiligen Indizes berechnet:\nnix-repl\u0026gt; builtins.genList ( x : -x ) 4 [ 0 -1 -2 -3 ] nix-repl\u0026gt; builtins.genList ( x : 1.0/(x+1) ) 4 [ 1 0.5 0.333333 0.25 ] builtins.genericClosure # Das ist eine eigenartig spezifische und zugleich eigenartig allgemeine Funktion! Sie erinnert mich ein bisschen an das M√§rchen vom s√º√üen Brei. Ich w√ºrde wirklich gern wissen, wof√ºr sie gedacht ist. Ich erkenne darin jedenfalls keine so klare und universell brauchbare Abstraktion wie map oder filter oder foldl.\nbuiltins.genericClosure nimmt ein Set mit den Schl√ºsseln startSet und operator entgegen. startSet ist eine Liste mit Sets. operator ist eine Funktion, die auf einem Set operiert und daraus eine Liste von weiteren Sets erzeugt. builtins.genericClosure verwendet ausgehend von der startSet Liste die operator Funktion um rekursiv aus den bestehenden Sets weitere Sets zu berechnen. Alle hier erw√§hnten Sets (abgesehen von dem √§u√üeren) m√ºssen einen Schl√ºssel key enthalten. Alle Sets, mit einem key Wert, der schon einmal aufgetaucht ist, werden verworfen. Sobald keine Sets mit neuen key Werten hinzukommen, endet die Rekursion.\nDas ist ziemlich kompliziert. Hier sind ein paar Beispiele. Zun√§chst der einfachste Fall:\nnix-repl\u0026gt; builtins.genericClosure ... { startSet = [] ; ... operator = s : [] ; ... } [ ] Wir f√ºllen startSet mit ein paar Sets:\nnix-repl\u0026gt; builtins.genericClosure ... { startSet = ... [ { key = 5 ; } ... { key = 6 ; } ... { key = 7 ; } ... ] ; ... operator = s : [] ; ... } [ { ... } { ... } { ... } ] Die Auslassungpunkte kommen daher, dass die Nix Repl beim Auswerten und beim Ausgeben der Ergebnisse maximal eine Ebene in die Tiefe geht. Bisher bin ich darauf nicht eingegangen, aber das ist schon einmal vorgekommen, n√§mlich im Abschnitt Sets (Mengen) wo ich die Kurznotation f√ºr verschachtelte Sets einf√ºhre. Man erh√§lt die Auslassungspunkte schon wenn man eine Liste in eine Liste steckt:\nnix-repl\u0026gt; [[]] [ [ ... ] ] Die innere Liste ist leer, aber der Interpreter schaut gar nicht erst hinein sondern gibt sie gleich mit den Auslassungspunkten aus.\nMan kann die Nix Repl veranlassen, einen Ausdruck in voller Tiefe auszuwerten und das Ergebnis in voller Tiefe auszugeben. Daf√ºr muss man dem auszuwertenden Ausdruck die Repl-Anweisung :p voranstellen. Damit k√∂nnen wir uns wieder builtins.genericClosure zuwenden:\nnix-repl\u0026gt; :p builtins.genericClosure ... { startSet = ... [ { key = 5 ; } ... { key = 6 ; } ... { key = 7 ; } ... ] ; ... operator = s : [] ; ... } [ { key = 5; } { key = 6; } { key = 7; } ] Dass Sets, deren key schon einmal vorgekommen ist, verworfen werden, gilt schon f√ºr die Sets in der startSet Liste:\nnix-repl\u0026gt; :p builtins.genericClosure ... { startSet = ... [ { key = 5 ; } ... { key = 6 ; } ... { key = 7 ; } ... { key = 5 ; } ... ] ; ... operator = s : [] ; ... } [ { key = 5; } { key = 6; } { key = 7; } ] Um die Wirkung der operator Funktion zu demonstrieren, inkrementieren wir einfach die key Werte. Damit built.genericClosure trotzdem terminiert, m√ºssen wir das irgendwo deckeln. Ich schlage vor, wir belassen es bei key \u0026lt; 10:\nnix-repl\u0026gt; :p builtins.genericClosure ... { startSet = ... [ { key = 5 ; } ... { key = 6 ; } ... { key = 7 ; } ... { key = 5 ; } ... ] ; ... operator = s : ... [ { key = ... if s.key \u0026lt; 9 ... then s.key + 1 ... else s.key ; ... } ... ] ; ... } [ { key = 5; } { key = 6; } { key = 7; } { key = 8; } { key = 9; } ] Das hei√üt, wir inkrementieren den key Wert so lange er kleiner als 9 ist. Das Set mit key = 9 wird noch erzeugt, aber dar√ºber kommt nichts mehr. Die Ausgabe ist so wie ich es erwartet habe. Ich glaube, ich habe damit vollst√§ndig erfasst, was builtins.genericClosure macht. Einen guten Anwendungsfall daf√ºr habe ich nicht, aber zumindest den vagen Eindruck, dass man damit etwas n√ºtzliches machen kann, vielleicht irgend etwas in Richtung transitiver H√ºllen.\nbuiltins.getAttr # Liefert aus einem Set den Wert zu einem Schl√ºssel:\nnix-repl\u0026gt; builtins.getAttr \u0026#34;foo\u0026#34; { foo = 123 ; } 123 Wenn es den Schl√ºssel nicht gibt, l√∂st das einen Fehler aus:\nnix-repl\u0026gt; builtins.getAttr \u0026#34;bar\u0026#34; { foo = 123 ; } error: attribute \u0026#39;bar\u0026#39; missing for call to \u0026#39;getAttr\u0026#39; Das selbe kann man nat√ºrlich schon mit dem . Operator machen:\nnix-repl\u0026gt; s = { foo = 123 ; } nix-repl\u0026gt; s.foo 123 Aber es gibt einen Unterschied: builtins.getAttr nimmt den Schl√ºssel als String. Dadurch kann man den Schl√ºssel dynamisch konstruieren:\nnix-repl\u0026gt; s = { foo = 123 ; } nix-repl\u0026gt; builtins.getAttr ( \u0026#34;f\u0026#34; + \u0026#34;o\u0026#34; + \u0026#34;o\u0026#34; ) s 123 Update: der . Operator akzeptiert auch Strings:\nnix-repl\u0026gt; { foo = 123 ; }.\u0026#34;foo\u0026#34; 123 Aber dynamisch konstruieren kann man den Schl√ºssel trotzdem nicht:\nnix-repl\u0026gt; { foo = 123 ; }.( \u0026#34;f\u0026#34; + \u0026#34;o\u0026#34; + \u0026#34;o\u0026#34; ) error: syntax error, unexpected \u0026#39;(\u0026#39;, ... nix-repl\u0026gt; { foo = 123 ; }.( \u0026#34;foo\u0026#34; ) error: syntax error, unexpected \u0026#39;(\u0026#39;, ... builtins.getContext # Weder in der Nix Repl noch im Handbuch dokumentiert.\nbuiltins.getEnv # Liefert den Wert einer Umgebungsvariable als String:\nnix-repl\u0026gt; builtins.getEnv \u0026#34;HOME\u0026#34; \u0026#34;/home/aramis\u0026#34; F√ºr fehlende Umgebungsvariable wird der leere String wird der leere String gegeben:\nnix-repl\u0026gt; builtins.getEnv \u0026#34;sa0iboojav9ood5C\u0026#34; \u0026#34;\u0026#34; builtins.getFlake # L√§dt eine Nix Flake herunter und gibt ihre Attribute zusammen mit ein paar Metadaten aus.\nFlakes sind ein alternativer Mechanismus um Abh√§ngigkeiten zu beschreiben und Software in den Nix Store herunterzuladen. Nix Channels folgen in der Handhabung dem typischen Paketverwaltungsmodell von Linux Distros: Es gibt Kan√§le, in denen versionierte Softwarepakete verf√ºgbar sind, die man bei Bedarf herunterladen kann. Um seine Software auf dem neusten Stand zu halten, ruft man zun√§chst aus seinen Kan√§len Informationen zu den aktuellen Versionen ab und installiert dann Updates f√ºr die Software, die nicht mehr auf dem neusten Stand ist.\nSo sieht das f√ºr die Debian/Ubuntu Paketverwaltung aus:\n$ apt update # Aktualisiere Kan√§le $ apt upgrade # Aktualisiere Softwarepakete So sieht das f√ºr Nix aus:\n$ nix-channel --update # Aktualisiere Kan√§le $ nix-env --upgrade # Aktualisiere Softwarepakete Mit Debian/Ubuntu verwendet man apt f√ºr beide Schritte. Mit Nix verwendet man im ersten Schritt nix-channel und im zweiten Schritt nix-env, aber an den Flags sieht man schon, mit wes Geistes Kind man es hier zu tun hat.\nIm Unterschied dazu, orientieren sich Flakes an Paketverwaltungen wie Cargo (Rust) oder NPM (JS). Es gibt keine Kan√§le. Man deklariert die Abh√§ngigkeiten einer Software als Git Repositories in einer flake.nix Datei. W√§hrend der Installation der Abh√§ngigkeiten wird eine flake.lock Datei erzeugt, welche die Hashes der verwendeten Git Commits protokolliert und dadurch die Abh√§ngigkeiten sozusagen einfriert.\nFlakes sind noch als experimentell markiert und m√ºssen in einer Konfigurationsdatei aktiviert werden bevor sie verwendet werden k√∂nnen:\n$ echo experimental-features = nix-command flakes \u0026gt;\u0026gt; ~/.config/nix/nix.conf Ich habe mir, √ºber das hier aufgeschriebene hinaus, Flakes noch nicht genauer angeschaut.\nbuiltins.groupBy # builtings.groupBy f ls gruppiert die Liste ls anhand der Funktion f:\nnix-repl\u0026gt; isEven = n : n / 2 == n / 2.0 nix-repl\u0026gt; :p builtins.groupBy ... ( n : toString ( isEven n ) ) [ 1 2 3 4 5 6 7 8 9 ] { \u0026#34;\u0026#34; = [ 1 3 5 7 9 ]; \u0026#34;1\u0026#34; = [ 2 4 6 8 ]; } Dabei muss f stets einen String zur√ºckgeben. Sonst funktioniert das nicht:\nnix-repl\u0026gt; :p builtins.groupBy isEven [ 1 2 3 4 5 6 7 8 9 ] error: value is a Boolean while a string was expected builtins.hasAttr # Pr√ºft ob ein Schl√ºssel in einem Set enthalten ist:\nnix-repl\u0026gt; builtins.hasAttr \u0026#34;foo\u0026#34; {} false nix-repl\u0026gt; builtins.hasAttr \u0026#34;foo\u0026#34; { foo = 123 ; } true Offenbar gibt es auch einen ? Operator, der dasselbe macht:\nnix-repl\u0026gt; {} ? \u0026#34;foo\u0026#34; false nix-repl\u0026gt; { foo = 123 ; } ? \u0026#34;foo\u0026#34; true Der ? Operator kann den zu pr√ºfenden Schl√ºssel nicht nur als String sondern auch als einfachen Bezeichner verarbeiten:\nnix-repl\u0026gt; { foo = 123 ; } ? foo true nix-repl\u0026gt; {} ? foo false Der ? Operator hat die selbe Beschr√§nkung wie der . Operator, n√§mlich dass der Schl√ºssel nicht dynamisch erzeugt werden kann:\nnix-repl\u0026gt; { foo = 123 ; } ? ( \u0026#34;f\u0026#34; + \u0026#34;o\u0026#34; + \u0026#34;o\u0026#34; ) error: syntax error, unexpected \u0026#39;(\u0026#39;, ... nix-repl\u0026gt; { foo = 123 ; } ? ( \u0026#34;foo\u0026#34; ) error: syntax error, unexpected \u0026#39;(\u0026#39;, ... builtins.hasContext # Weder in der Nix Repl noch im Handbuch dokumentiert.\nbuiltins.hashFile # Erzeugt einen Hash Wert aus einer Datei. Erwartet werden zwei Argumente. Das erste Argument ist der Hash-Algorithmus. M√∂glich sind \u0026quot;md5\u0026quot;, \u0026quot;sha1\u0026quot;, \u0026quot;sha256\u0026quot; und \u0026quot;sha512\u0026quot;. Das zweite Argument ist der Pfad zur Datei. Der Pfad kann als Nix Pfad oder als String √ºbergeben werden.\nnix-repl\u0026gt; builtins.hashFile \u0026#34;md5\u0026#34; ... /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524 \u0026#34;ffab34ab46902e10183dc2a065e50ebd\u0026#34; nix-repl\u0026gt; builtins.hashFile \u0026#34;md5\u0026#34; ... \u0026#34;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\u0026#34; \u0026#34;ffab34ab46902e10183dc2a065e50ebd\u0026#34; nix-repl\u0026gt; builtins.hashFile \u0026#34;sha1\u0026#34; ... /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524 \u0026#34;95936f2f3d784c7a90623acfbb9d093384f5a6a2\u0026#34; nix-repl\u0026gt; builtins.hashFile \u0026#34;sha1\u0026#34; ... \u0026#34;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\u0026#34; \u0026#34;95936f2f3d784c7a90623acfbb9d093384f5a6a2\u0026#34; Die Funktion verarbeitet beliebige Pfade, auch au√üerhalb des Nix Store. Leider wei√ü ich jetzt immer noch nicht, was es mit dem Hash 97ggi3ryxkvdljycw05nq82bgs6kdxcx im Store Path auf sich hat.\nbuiltins.hashString # Erzeugt einen Hash Wert aus einem String. Erwartet werden zwei Argumente. Das erste Argument ist der Hash-Algorithmus. M√∂glich sind \u0026quot;md5\u0026quot;, \u0026quot;sha1\u0026quot;, \u0026quot;sha256\u0026quot; und \u0026quot;sha512\u0026quot;. Das zweite ist der zu verarbeitende String:\nnix-repl\u0026gt; builtins.hashString \u0026#34;md5\u0026#34; \u0026#34;foobar\u0026#34; \u0026#34;3858f62230ac3c915f300c664312c63f\u0026#34; builtins.head # Liefert das erste Element einer Liste:\nnix-repl\u0026gt; builtins.head [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] \u0026#34;a\u0026#34; Wenn man sich das ganze im mathematichen Sinne als eine Abbildung von der Menge aller Listen auf die Menge aller m√∂glichen Listenelemente vorzustellen versucht, stellt man fest, dass es in der Sprechweise der Schulmathematik eine m√∂gliche Definitionsl√ºcke gibt: n√§mlich bei der leeren Liste:\nnix-repl\u0026gt; builtins.head [] error: list index 0 is out of bounds Die Fehlermeldung l√§sst vermuten, dass builtins.head ls intern in builtins.elemAt ls 0 √ºbersetzt wird. Jedenfalls l√∂st die Funktion f√ºr die leere Liste einen Fehler aus. Es ist strenggenommen nur eine partielle Funktion. Das ist schade, wobei ich hier noch mehr Verst√§ndnis daf√ºr habe als bei der head Funktion aus der Haskell Standardbibliothek, die das gleiche Problem hat.\nbuiltins.intersectAttrs # Erwartet zwei Sets und liefert ein Set mit den Schl√ºssel-Wert-Paaren aus dem zweiten Set, deren Schl√ºssel auch im ersten Set vorkommen:\nnix-repl\u0026gt; builtins.intersectAttrs ... { a = 1 ; b = 2 ; } { b = 3 ; c = 4 ; } { b = 3; } builtins.isAttrs # Pr√ºft, ob es sich bei einem Wert um ein Set handelt:\nnix-repl\u0026gt; builtins.isAttrs {} true nix-repl\u0026gt; builtins.isAttrs 123 false builtins.isBool # Pr√ºft, ob es sich bei einem Wert um einen boolschen Wert handelt:\nnix-repl\u0026gt; builtins.isBool false true nix-repl\u0026gt; builtins.isBool 123 false builtins.isFloat # Pr√ºft, ob es sich bei einem Wert um eine Flie√ükommazahl handelt:\nnix-repl\u0026gt; builtins.isFloat 123.456 true nix-repl\u0026gt; builtins.isFloat 123 false builtins.isFunction # Pr√ºft, ob es sich bei einem Wert um eine Funktion handelt:\nnix-repl\u0026gt; builtins.isFunction ( x : x ) true nix-repl\u0026gt; builtins.isFunction 123 false builtins.isInt # Pr√ºft, ob es sich bei einem Wert um eine Ganzzahl handelt:\nnix-repl\u0026gt; builtins.isInt 123 true nix-repl\u0026gt; builtins.isInt \u0026#34;123\u0026#34; false builtins.isList # Pr√ºft, ob es sich bei einem Wert um eine Liste handelt:\nnix-repl\u0026gt; builtins.isList [] true nix-repl\u0026gt; builtins.isList 123 false builtins.isPath # Pr√ºft, ob es sich bei einem Wert um einen Nix Pfad handelt:\nnix-repl\u0026gt; builtins.isPath ./. true nix-repl\u0026gt; builtins.isPath 123 false builtins.isString # Pr√ºft, ob es sich bei einem Wert um eine Zeichenkette (String) handelt:\nnix-repl\u0026gt; builtins.isString \u0026#34;\u0026#34; true nix-repl\u0026gt; builtins.isString 123 false builtins.langVersion # Undokumentiert. Wahrscheinlich ist Nix (die Sprache) irgendwie versioniert:\nnix-repl\u0026gt; builtins.langVersion 6 builtins.length # Liefert die L√§nge einer Liste:\nnix-repl\u0026gt; builtins.length [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] 3 builtins.lessThan # Die Funktion hinter dem \u0026lt; Operator:\nnix-repl\u0026gt; builtins.lessThan 3 4 true nix-repl\u0026gt; builtins.lessThan 4 3 false builtins.listToAttrs # Verarbeitet eine Liste von Sets mit Schl√ºsseln name und value zu einem Set mit entsprechenden Schl√ºssel-Wert-Paaren:\nnix-repl\u0026gt; builtins.listToAttrs ... [ { name = \u0026#34;foo\u0026#34; ; value = 123 ; } ... { name = \u0026#34;bar\u0026#34; ; value = 456 ; } ... ] { bar = 456; foo = 123; } builtins.mapAttrs # Eine Map-Funktion f√ºr Sets, die auf den Werten operiert und dabei die Schl√ºssel ber√ºcksichtigen kann:\nnix-repl\u0026gt; builtins.mapAttrs ... ( k : v : k + \u0026#34;:\u0026#34; + builtins.toString v ) ... { a = 1 ; b = 2 ; c = 3 ; } { a = \u0026#34;a:1\u0026#34;; b = \u0026#34;b:2\u0026#34;; c = \u0026#34;c:3\u0026#34;; } builtins.match # Erwartet einen regul√§ren Ausdruck und einen String. Der regul√§re Ausdruck kann RegEx-Gruppen enthalten. Als Ergebnis liefert builtins.match eine Liste der √úbereinstimmungen f√ºr diese RegEx-Gruppen. Ohne RegEx-Gruppen ist das Ergebnis nat√ºrlich die leere Liste (bei √úbereinstimmung). Wenn der String nicht auf den regul√§ren Ausdruck passt, ist das Ergebnis null:\nnix-repl\u0026gt; builtins.match \u0026#34;foo\u0026#34; \u0026#34;bar\u0026#34; null nix-repl\u0026gt; builtins.match \u0026#34;foo\u0026#34; \u0026#34;foo\u0026#34; [ ] nix-repl\u0026gt; builtins.match \u0026#34;a(b)c(d)e\u0026#34; \u0026#34;abcde\u0026#34; [ \u0026#34;b\u0026#34; \u0026#34;d\u0026#34; ] RegEx-Gruppen sind Teile eines regul√§ren Ausdrucks, die durch Klammern hervorgehoben sind. Man verwendet sie, um nicht nur zu pr√ºfen ob ein String auf einen regul√§ren Ausdruck passt, sondern auch Teile aus dem String zu extrahieren. Beispielsweise k√∂nnte man einen regul√§ren Ausdruck f√ºr postalische Adressen konstruieren, der die Stra√üe, die Hausnummer, die Postleitzahl und die Stadt extrahiert.\nbuiltins.mul # Die Funktion hinter dem * Operator:\nnix-repl\u0026gt; builtins.mul 3 5 15 builtins.nixPath # Weder in der Nix Repl noch im Handbuch dokumentiert.\nnix-repl\u0026gt; :p builtins.nixPath [ { path = \u0026#34;/home/aramis/.nix-defexpr/channels\u0026#34;; prefix = \u0026#34;\u0026#34;; } ] builtins.nixVersion # Liefert die Nix Versionsnummer:\nnix-repl\u0026gt; builtins.nixVersion \u0026#34;2.10.3\u0026#34; Die Nix Versionsnummer wird auch ausgegeben wenn man die Repl startet:\n$ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; builtins.parseDrvName # Zerlegt einen Paketbezeichner der Form \u0026lt;Name\u0026gt;-\u0026lt;Version\u0026gt; in den Namen und die Version des Pakets auf. Das Ergebnis wird als Set mit den Schl√ºsseln name und version gegeben:\nnix-repl\u0026gt; builtins.parseDrvName \u0026#34;nix-0.12pre12876\u0026#34; { name = \u0026#34;nix\u0026#34;; version = \u0026#34;0.12pre12876\u0026#34;; } Die beiden Teile m√ºssen durch einen Bindestrich getrennt sein. Die Version muss mit Ziffern beginnen. Sonst ist mindestens einer der beiden Werte der leere String:\nnix-repl\u0026gt; builtins.parseDrvName \u0026#34;\u0026#34; { name = \u0026#34;\u0026#34;; version = \u0026#34;\u0026#34;; } nix-repl\u0026gt; builtins.parseDrvName \u0026#34;foo123\u0026#34; { name = \u0026#34;foo123\u0026#34;; version = \u0026#34;\u0026#34;; } nix-repl\u0026gt; builtins.parseDrvName \u0026#34;foo-bar\u0026#34; { name = \u0026#34;foo-bar\u0026#34;; version = \u0026#34;\u0026#34;; } nix-repl\u0026gt; builtins.parseDrvName \u0026#34;foo-1bar\u0026#34; { name = \u0026#34;foo\u0026#34;; version = \u0026#34;1bar\u0026#34;; } builtins.partition # Trennt die Spreu vom Weizen:\nnix-repl\u0026gt; :p builtins.partition ( n : n \u0026gt; 3 ) [ 1 2 3 4 5 6 ] { right = [ 4 5 6 ]; wrong = [ 1 2 3 ]; } builtins.path # F√ºgt Daten zum Nix Store hinzu. Die funktion nimmt ein Set als Argument entgegen. Nur der Schl√ºssel path ist Pflicht. Hier sind alle Schl√ºssel:\npath: der Pfad zu den Daten name: der Pfadname im Nix Store filter: die Funktion; filtert unerw√ºnschte Unterpfade heraus recursive: false: f√ºgt den Pfad mit einem flachen Hash zum Store hinzu true: f√ºgt den Pfad mit einem Hash der NAR Serialisierung zum Store hinzu sha256: der zu erwartende Hash f√ºr die Daten in path NAR steht f√ºr Nix Archive. Das ist ein Serialisierungsformat f√ºr Dateisystemobjekte (i.e. Dateien, Verzeichnisse, Symlinks). NAR ist vergleichbar mit Archivformaten wie TAR und ZIP. Allerdings kann es bei diesen Formaten f√ºr ein und dasselbe Objekt mehrere g√ºltige Serialisierungen geben, zum Beispiel weil die Reihenfolge der Serialisierung von Verzeichnisinhalten nicht definiert ist oder weil eine variable Menge an F√ºllbytes zwischen Segmenten der Serialisierung zul√§ssig ist oder weil auch Zeitstempel mit in die Serialisierung aufgenommen werden. Die Beziehung zwischen einem serialisierten Objekt und den Bytes seiner Serialisierung hat somit keinen Abbildungscharakter. Das macht diese Archivformate unbrauchbar wenn der Hash der Serialisierung als Hash f√ºr das serialisierte Objekt geeignet sein soll. NAR ist speziell daf√ºr entwickelt worden, Dateisystemobjekte f√ºr das Hashing zu serialisieren und l√§sst keinen Implementierungsspielraum, der die Serialisierung eines Dateisystemobjektes in verschiedene Bytefolgen gestatten w√ºrde. (Quelle: https://edolstra.github.io/pubs/phd-thesis.pdf)\nF√ºgt Daten zum Nix Store hinzu. Die funktion nimmt ein Set als Argument entgegen. Nur der Schl√ºssel path ist Pflicht. Hier sind alle Schl√ºssel:\npath: der Pfad zu den Daten name: der Pfadname im Nix Store filter: die Funktion; filtert unerw√ºnschte Unterpfade heraus recursive: false: f√ºgt den Pfad mit einem flachen Hash zum Store hinzu true: f√ºgt den Pfad mit einem Hash der NAR Serialisierung zum Store hinzu sha256: der zu erwartende Hash f√ºr die Daten in path NAR steht f√ºr Nix Archive. Das ist ein Serialisierungsformat f√ºr Dateisystemobjekte (i.e. Dateien, Verzeichnisse, Symlinks). NAR ist vergleichbar mit Archivformaten wie TAR und ZIP. Allerdings kann es bei diesen Formaten f√ºr ein und dasselbe Objekt mehrere g√ºltige Serialisierungen geben, zum Beispiel weil die Reihenfolge der Serialisierung von Verzeichnisinhalten nicht definiert ist oder weil eine variable Menge an F√ºllbytes zwischen Segmenten der Serialisierung zul√§ssig ist oder weil auch Zeitstempel mit in die Serialisierung aufgenommen werden. Die Beziehung zwischen einem serialisierten Objekt und den Bytes seiner Serialisierung hat somit keinen Abbildungscharakter. Das macht diese Archivformate unbrauchbar wenn der Hash der Serialisierung als Hash f√ºr das serialisierte Objekt geeignet sein soll. NAR ist speziell daf√ºr entwickelt worden, Dateisystemobjekte f√ºr das Hashing zu serialisieren und l√§sst keinen Implementierungsspielraum, der die Serialisierung eines Dateisystemobjektes in verschiedene Bytefolgen gestatten w√ºrde. (Quelle: https://edolstra.github.io/pubs/phd-thesis.pdf)\nbuiltins.pathExists # Pr√ºft, ob ein Pfad im lokalen Dateisystem existiert:\nnix-repl\u0026gt; builtins.pathExists /home/aramis true nix-repl\u0026gt; builtins.pathExists /home/foo false Kann auch Strings verarbeiten:\nnix-repl\u0026gt; builtins.pathExists \u0026#34;/\u0026#34; true Oben hatte ich ein paar Prozeduren aufgelistet, die Nix impure machen. Diese hier (und die nachfolgenden) h√§tte man auch mit auflisten k√∂nnen.\nPr√ºft, ob ein Pfad im lokalen Dateisystem existiert:\nnix-repl\u0026gt; builtins.pathExists /home/aramis true nix-repl\u0026gt; builtins.pathExists /home/foo false Kann auch Strings verarbeiten:\nnix-repl\u0026gt; builtins.pathExists \u0026quot;/\u0026quot; true Oben hatte ich ein paar Prozeduren aufgelistet, die Nix impure machen. Diese hier (und die nachfolgenden) h√§tte man auch mit auflisten k√∂nnen.\nbuiltins.readDir # Liefert f√ºr einen Verzeichnispfad ein Set mit den Verzeichnisinhalten als Schl√ºssel und den jeweiligen Dateitypen als Werte:\nnix-repl\u0026gt; builtins.readDir /home { aramis = \u0026#34;directory\u0026#34;; } Die m√∂glichen Werte f√ºr den Dateityp sind \u0026quot;regular\u0026quot;, \u0026quot;directory\u0026quot;, \u0026quot;symlink\u0026quot; und \u0026quot;unknown\u0026quot;.\nLiefert f√ºr einen Verzeichnispfad ein Set mit den Verzeichnisinhalten als Schl√ºssel und den jeweiligen Dateitypen als Werte:\nnix-repl\u0026gt; builtins.readDir /home { aramis = \u0026quot;directory\u0026quot;; } Die m√∂glichen Werte f√ºr den Dateityp sind \u0026quot;regular\u0026quot;, \u0026quot;directory\u0026quot;, \u0026quot;symlink\u0026quot; und \u0026quot;unknown\u0026quot;.\nbuiltins.readFile # Liefert den Inhalt einer Datei als String:\n$ echo hallo \u0026gt; greeting.txt $ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; builtins.readFile ./greeting.txt \u0026#34;hallo\\n\u0026#34; Liefert den Inhalt einer Datei als String:\n$ echo hallo \u0026gt; greeting.txt $ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; builtins.readFile ./greeting.txt \u0026quot;hallo\\n\u0026quot; builtins.replaceStrings # Ersetzt alle Vorkommen eines Teilstrings:\nnix-repl\u0026gt; builtins.replaceStrings [ \u0026#34;o\u0026#34; ] [ \u0026#34;x\u0026#34; ] \u0026#34;foobar\u0026#34; \u0026#34;fxxbar\u0026#34; nix-repl\u0026gt; builtins.replaceStrings [ \u0026#34;o\u0026#34; \u0026#34;a\u0026#34; ] [ \u0026#34;x\u0026#34; \u0026#34;y\u0026#34; ] \u0026#34;foobar\u0026#34; \u0026#34;fxxbyr\u0026#34; Ersetzt alle Vorkommen eines Teilstrings:\nnix-repl\u0026gt; builtins.replaceStrings [ \u0026quot;o\u0026quot; ] [ \u0026quot;x\u0026quot; ] \u0026quot;foobar\u0026quot; \u0026quot;fxxbar\u0026quot; nix-repl\u0026gt; builtins.replaceStrings [ \u0026quot;o\u0026quot; \u0026quot;a\u0026quot; ] [ \u0026quot;x\u0026quot; \u0026quot;y\u0026quot; ] \u0026quot;foobar\u0026quot; \u0026quot;fxxbyr\u0026quot; builtins.sort # Sortiert eine Liste anhand einer Vergleichsfunktion:\nnix-repl\u0026gt; builtins.sort ... ( a : b : a \u0026lt; b ) ... [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ] [ 1 1 2 3 3 3 4 5 5 5 6 7 8 9 9 9 ] nix-repl\u0026gt; builtins.sort ... ( a : b : a \u0026gt; b ) ... [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ] [ 9 9 9 8 7 6 5 5 5 4 3 3 3 2 1 1 ] Sortiert eine Liste anhand einer Vergleichsfunktion:\nnix-repl\u0026gt; builtins.sort ( a : b : a \u0026lt; b ) [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ] [ 1 1 2 3 3 3 4 5 5 5 6 7 8 9 9 9 ] nix-repl\u0026gt; builtins.sort ( a : b : a \u0026gt; b ) [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ] [ 9 9 9 8 7 6 5 5 5 4 3 3 3 2 1 1 ] builtins.split # Zerteilt einen String anhand eines regul√§ren Ausdrucks in eine Liste. Alles, was auf den regul√§ren Ausdruck passt, wird als Trennzeichen behandelt. Der regul√§re Ausdruck kann RegEx-Gruppen enthalten. An jeder Trennstelle wird eine Liste mit den √úbereinstimmungen f√ºr die RegEx-Gruppen an dieser Stelle in die Ergebnisliste aufgenommen. Ohne RegEx-Gruppen werden an den Trennstellen entsprechend leere Listen eingef√ºgt:\nnix-repl\u0026gt; :p builtins.split \u0026#34;a\u0026#34; \u0026#34;bacadaeafagahai\u0026#34; [ \u0026#34;b\u0026#34; [ ] \u0026#34;c\u0026#34; [ ] \u0026#34;d\u0026#34; [ ] \u0026#34;e\u0026#34; [ ] \u0026#34;f\u0026#34; [ ] \u0026#34;g\u0026#34; [ ] \u0026#34;h\u0026#34; [ ] \u0026#34;i\u0026#34; ] nix-repl\u0026gt; builtins.split \u0026#34;a\u0026#34; \u0026#34;bcde\u0026#34; [ \u0026#34;bcde\u0026#34; ] Siehe builtins.match f√ºr mehr zu RegEx-Gruppen.\nZerteilt einen String anhand eines regul√§ren Ausdrucks in eine Liste. Alles, was auf den regul√§ren Ausdruck passt, wird als Trennzeichen behandelt. Der regul√§re Ausdruck kann RegEx-Gruppen enthalten. An jeder Trennstelle wird eine Liste mit den √úbereinstimmungen f√ºr die RegEx-Gruppen an dieser Stelle in die Ergebnisliste aufgenommen. Ohne RegEx-Gruppen werden an den Trennstellen entsprechend leere Listen eingef√ºgt:\nnix-repl\u0026gt; :p builtins.split \u0026quot;a\u0026quot; \u0026quot;bacadaeafagahai\u0026quot; [ \u0026quot;b\u0026quot; [ ] \u0026quot;c\u0026quot; [ ] \u0026quot;d\u0026quot; [ ] \u0026quot;e\u0026quot; [ ] \u0026quot;f\u0026quot; [ ] \u0026quot;g\u0026quot; [ ] \u0026quot;h\u0026quot; [ ] \u0026quot;i\u0026quot; ] nix-repl\u0026gt; builtins.split \u0026quot;a\u0026quot; \u0026quot;bcde\u0026quot; [ \u0026quot;bcde\u0026quot; ] Siehe builtins.match f√ºr mehr zu RegEx-Gruppen.\nbuiltins.splitVersion # Teilt einen String, der eine (Software) Version darstellt, in seine Bestandteile auf. Ich bin mir nicht 100%ig sicher, aber ich denke, die Trennstellen sind Punkte ., Bindestriche - und √úberg√§nge zwischen Ziffern und Buchstaben:\nnix-repl\u0026gt; builtins.splitVersion \u0026#34;a.b-c123e\u0026#34; [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; \u0026#34;123\u0026#34; \u0026#34;e\u0026#34; ] Teilt einen String, der eine (Software) Version darstellt, in seine Bestandteile auf. Ich bin mir nicht 100%ig sicher, aber ich denke, die Trennstellen sind Punkte ., Bindestriche - und √úberg√§nge zwischen Ziffern und Buchstaben:\nnix-repl\u0026gt; builtins.splitVersion \u0026quot;a.b-c123e\u0026quot; [ \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot; \u0026quot;123\u0026quot; \u0026quot;e\u0026quot; ] builtins.storeDir # Undokumentiert. Liefert den Pfad zum Nix Store als String:\nnix-repl\u0026gt; builtins.storeDir \u0026#34;/nix/store\u0026#34; Undokumentiert. Liefert den Pfad zum Nix Store als String:\nnix-repl\u0026gt; builtins.storeDir \u0026quot;/nix/store\u0026quot; builtins.storePath # Alles, was ein Programm ben√∂tigt, um gebaut zu werden, soll sich im Nix Store befinden. Entsprechend werden die Abh√§ngigkeiten, die in Ableitungen (Derivations) deklariert sind, zun√§chst zum Nix Store hinzugef√ºgt. Das geschieht normalerweise auch dann, wenn sich etwas schon im Nix Store befindet. Mit builtins.storePath kann man das vermeiden.\nAlles, was ein Programm ben√∂tigt, um gebaut zu werden, soll sich im Nix Store befinden. Entsprechend werden die Abh√§ngigkeiten, die in Ableitungen (Derivations) deklariert sind, zun√§chst zum Nix Store hinzugef√ºgt. Das geschieht normalerweise auch dann, wenn sich etwas schon im Nix Store befindet. Mit builtins.storePath kann man das vermeiden.\nbuiltins.stringLength # Liefert die L√§nge eines Strings:\nnix-repl\u0026gt; builtins.stringLength \u0026#34;asdf\u0026#34; 4 Liefert die L√§nge eines Strings:\nnix-repl\u0026gt; builtins.stringLength \u0026quot;asdf\u0026quot; 4 builtins.sub # Die Funktion hinter dem - Operator:\nnix-repl\u0026gt; builtins.sub 7 5 2 Die Funktion hinter dem - Operator:\nnix-repl\u0026gt; builtins.sub 7 5 2 builtins.substring # Selbsterkl√§rend:\nnix-repl\u0026gt; builtins.substring 0 3 \u0026#34;nixos\u0026#34; \u0026#34;nix\u0026#34; Selbsterkl√§rend:\nnix-repl\u0026gt; builtins.substring 0 3 \u0026quot;nixos\u0026quot; \u0026quot;nix\u0026quot; builtins.tail # Liefert eine Liste ohne das erste Element:\nnix-repl\u0026gt; builtins.tail [ 1 2 3 ] [ 2 3 ] nix-repl\u0026gt; builtins.tail [] error: \u0026#39;tail\u0026#39; called on an empty list Liefert eine Liste ohne das erste Element:\nnix-repl\u0026gt; builtins.tail [ 1 2 3 ] [ 2 3 ] nix-repl\u0026gt; builtins.tail [] error: 'tail' called on an empty list builtins.toFile # Schreibt einen String in eine Datei im Nix Store und gibt den Pfad dieser Datei zur√ºck:\nnix-repl\u0026gt; builtins.toFile \u0026#34;greeting\u0026#34; \u0026#34;hallo\u0026#34; \u0026#34;/nix/store/8fday1j2s9rpc28yirwbjp59a1wr3rx3-greeting\u0026#34; Die Datei kann dann beispielsweise als Input f√ºr Derivationen verwendet werden. Damit lassen sich beispielsweise Build Skripte inline unterbringen.\nbuiltins.toJSON # √úbersetzt einen Nix Ausdruck in sein Json √Ñquivalent, aber mit ein paar effektvollen Besonderheiten. Strings, Integers, Floats, Bools, null und Listen werden einfach in ihr Json √Ñquivalent √ºbersetzt. Nix Sets werden zu Json Objekten. Davon ausgenommen sind Derivationen: die werden in den entsprechenden Ausgabepfad √ºbersetzt (als Json String). Nix Paths werden in den Nix Store kopiert und zu ihrem Zielpfad evaluiert (als Json String).\nnix-repl\u0026gt; builtins.toJSON /home/aramis/todo.txt \u0026#34;\\\u0026#34;/nix/store/dmj65s7zfyzzypymaihy8yd1mrdz27pm-todo.txt\\\u0026#34;\u0026#34; nix-repl\u0026gt; builtins.toJSON 123 \u0026#34;123\u0026#34; nix-repl\u0026gt; builtins.toJSON \u0026#34;123\u0026#34; \u0026#34;\\\u0026#34;123\\\u0026#34;\u0026#34; nix-repl\u0026gt; builtins.toJSON [] \u0026#34;[]\u0026#34; nix-repl\u0026gt; builtins.toJSON {} \u0026#34;{}\u0026#34; Ich frage mich, wie hier unterschieden wird zwischen Derivationen und anderen Sets.\nbuiltins.toPath # DEPRECATED.\nMan soll stattdessen f√ºr absolute Pfade /. + \u0026quot;/path\u0026quot; und f√ºr relative Pfade ./. + \u0026quot;/path\u0026quot; verwenden.\nbuiltins.toXML # √úbersetzt einen Nix Ausdruck in eine XML Darstellung:\nnix-repl\u0026gt; builtins.toXML 123 \u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39;?\u0026gt; \u0026lt;expr\u0026gt; \u0026lt;int value=\\\u0026#34;123\\\u0026#34; /\u0026gt; \u0026lt;/expr\u0026gt; \u0026#34;\u0026#34;\u0026#34; nix-repl\u0026gt; builtins.toXML \u0026#34;123\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39;?\u0026gt; \u0026lt;expr\u0026gt; \u0026lt;string value=\\\u0026#34;123\\\u0026#34; /\u0026gt; \u0026lt;/expr\u0026gt; \u0026#34;\u0026#34;\u0026#34; nix-repl\u0026gt; builtins.toXML [] \u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39;?\u0026gt; \u0026lt;expr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/expr\u0026gt; \u0026#34;\u0026#34;\u0026#34; nix-repl\u0026gt; builtins.toXML {} \u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39;?\u0026gt; \u0026lt;expr\u0026gt; \u0026lt;attrs\u0026gt; \u0026lt;/attrs\u0026gt; \u0026lt;/expr\u0026gt; \u0026#34;\u0026#34;\u0026#34; Das ist daf√ºr da, mit einem Build Script auf eine strukturiertere Weise Daten auszutauschen als es allein mit Umgebungsvariablen m√∂glich ist.\nIrgendwie verursacht XML in mir so etwas wie PTSD.\nbuiltins.traceVerbose # Wenn die Flag --trace-verbose aktiv ist, entspricht ein Aufruf von builtins.trace einem Aufruf von builtins.trace:\n$ nix repl --trace-verbose Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; builtins.traceVerbose [ 1 2 3 ] \u0026#34;foo\u0026#34; trace: [ 1 2 3 ] \u0026#34;foo\u0026#34; Ohne die Flag wertet builtins.traceVerbose e1 e2 einfach nur zu e2 aus:\n$ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; builtins.traceVerbose [ 1 2 3 ] \u0026#34;foo\u0026#34; \u0026#34;foo\u0026#34; builtins.tryEval # Darauf gehe ich im Abschnitt Fehler ein.\nbuiltins.typeOf # Liefert einen String, der den Datentyp eines Ausdrucks bezeichnet. Die Datentypen sind \u0026quot;int\u0026quot;, \u0026quot;bool\u0026quot;, \u0026quot;string\u0026quot;, \u0026quot;path\u0026quot;, \u0026quot;null\u0026quot;, \u0026quot;set\u0026quot;, \u0026quot;list\u0026quot;, \u0026quot;lambda\u0026quot; und \u0026quot;float\u0026quot;:\nnix-repl\u0026gt; builtins.typeOf 0 \u0026#34;int\u0026#34; nix-repl\u0026gt; builtins.typeOf false \u0026#34;bool\u0026#34; nix-repl\u0026gt; builtins.typeOf \u0026#34;\u0026#34; \u0026#34;string\u0026#34; nix-repl\u0026gt; builtins.typeOf /. \u0026#34;path\u0026#34; nix-repl\u0026gt; builtins.typeOf null \u0026#34;null\u0026#34; nix-repl\u0026gt; builtins.typeOf {} \u0026#34;set\u0026#34; nix-repl\u0026gt; builtins.typeOf [] \u0026#34;list\u0026#34; nix-repl\u0026gt; builtins.typeOf ( x : x ) \u0026#34;lambda\u0026#34; nix-repl\u0026gt; builtins.typeOf 0.0 \u0026#34;float\u0026#34; builtins.unsafeDiscardOutputDependency # Undokumentiert.\nbuiltins.unsafeDiscardStringContext # Undokumentiert.\nbuiltins.unsafeGetAttrPos # Undokumentiert.\nbuiltins.zipAttrsWith # Das ist wieder so eine Funktion, die etwas ausf√ºhrlicher beschrieben werden muss.\nSie nimmt eine zweiwertige Funktion f und eine Liste von Sets entgegen. Aus den Sets werden zun√§chst die Werte f√ºr die jeweiligen Schl√ºssel in Listen gesammelt. Aus den Schl√ºsseln und den zugeh√∂rigen Listen wird ein Set erstellt. Auf dieses Set wird builtins.mapAttrs f angewendet.\nSchauen wir uns das zun√§chst mit einer neutralen Funktion f an:\nnix-repl\u0026gt; :p builtins.zipAttrsWith ... ( k : v : v ) ... [ { x = 1 ; y = 2 ; } ... { x = 3 ; y = 4 ; z = 5 ; } ... ] { x = [ 1 3 ]; y = [ 2 4 ]; z = [ 5 ]; } Ich denke, hier sieht man ganz gut, was vor sich geht: alle Schl√ºssel werden eingesammelt und f√ºr jeden Schl√ºssel werden die zugeh√∂rigen Werte in Listen akkumuliert. Diese Listen sind naturgem√§√ü nichtleer (sonst g√§be es keinen zugeh√∂rigen Schl√ºssel).\nWir k√∂nnen dann mit f auf diesen Listen operieren. Beispielsweise k√∂nnen wir z√§hlen, wie oft jeder Schl√ºssel vorkommt:\nnix-repl\u0026gt; :p builtins.zipAttrsWith ... ( k : v : builtins.length v ) ... [ { x = 1 ; y = 2 ; } ... { x = 3 ; y = 4 ; z = 5 ; } ... ] { x = 2; y = 2; z = 1; } Oder wir finden den jeweils gr√∂√üten Wert f√ºr jeden Schl√ºssel. Daf√ºr bauen wir uns zun√§chst eine max Funktion f√ºr nichtnegative Zahlen:\nnix-repl\u0026gt; max = ls : ... builtins.foldl\u0026#39; ... ( a : b : if a \u0026gt; b then a else b ) ... 0 ... ls nix-repl\u0026gt; max [ 1 2 3 4 5 4 3 2 1 ] 5 Damit k√∂nnen wir die gr√∂√üten Schl√ºssel finden:\nnix-repl\u0026gt; :p builtins.zipAttrsWith ... ( k : v : max v ) ... [ { x = 1 ; y = 2 ; } ... { x = 3 ; y = 4 ; z = 5 ; } ... ] { x = 3; y = 4; z = 5; } Damit ist meine erste Erkundung der Nix Expression Language abgeschlossen. Vielleicht gibt es hier und da noch einen unbeleuchteten Aspekt, aber im gro√üen und ganzen habe ich einen guten √úberblick und ein gutes Gef√ºhl f√ºr die Sprache. Syntaktisch erinnert sie mich weniger an Haskell aber vielleicht ein bisschen an OCaml und an Coqs Gallina Sprache. Semantisch sind wir eher im Erlang/Ruby/JavaScript-Land: dynamische Typisierung, polymorphe Listen usw.\nDamit kann ich Nix (die Sprache) zun√§chst abhaken. Als n√§chstes arbeite ich G. Gonzalez\u0026rsquo; Vortrag Nix: under the hood durch, um den Nix Store und die Nix CLI-Befehle besser kennenzulernen.\n"},{"id":5,"href":"/docs/weblog/2022-11-30/","title":"Digital Gardening","section":"Docs","content":"2022-11-30\nDigital Gardening # Online kursierte vor einiger Zeit unter dem Schlagwort Digital Gardening eine alternative Vision f√ºr das Web jenseits des sequentiellen Publizierens √† la Twitter, Instagram, Weblog und so weiter: statt fertige, datierte Inhalte online zu stellen und Hot Takes in den Socials zu posten, k√∂nnen wir im Web Wissensammlungen anfertigen. Allgemein oder thematisch, lose oder strukturiert, allein oder kollaborativ ‚Äî die M√∂glichkeiten sind zahlreich und es gibt dabei keinen Zwang zur Tagesaktualit√§t und Reichweite.\nDie Idee ist genaugenommen keine neue. Solche Inhalte haben fr√ºher einen gro√üen Teil des Web ausgemacht. Dann haben Google, Facebook usw. das Web √ºbernommen und daraus eine Einkaufspromenade gemacht. Aber jetzt scheint eine neue Generation die alten Freiheitsgrade wiederzuentdecken. Neben dem urspr√ºnglichen World Wide Web m√ºsste eine Genealogie des Digital Gardening mindestens auch die folgenden Wegsteine enthalten.\nNiklas Luhmanns Zettelkasten. Luhmann hat Hypertext handschritlich auf nummerierten Karteikarten so produktiv gemacht wie kein zweiter und auf dieser Basis eine umfassende Theorie der Gesellschaft erarbeitet. Luhmanns Lebenswerk zeigt, dass textvermitteltes Denken effektiv und effizient ist, wenn verf√ºgbare und bew√§hrte Werkzeuge mit Disziplin, Kontinuit√§t und Geschick eingesetzt werden.\nToDo Apps und Note Taking Apps. Evernote, Org Mode, Roam Research, Obsidian, Logseq: beim Einsatz solcher Anwendungen muss man aufpassen: es bedarf einer echten Aufgabe, eines konkreten Ziels oder irgendeiner anderen Substanz, an der sich die ToDos und Notes ausrichten. Sonst bleibt das ganze Note Taking und ToDoing rein mastorbatorisch. Es ist nicht schwer, in diese Falle zu tappen, der Software die Schuld daf√ºr zu geben und gleich die n√§chste auszuprobieren. So dreht man sich nur im Kreis ohne je sinnstiftende Arbeit zu verrichten.\nDigital Humanities. Dagegen sind die Wikis, digitalen Archive und Online-Editionen der Digitial Humanities echte Bem√ºhungen, einen digitalen Bestand an Texten und anderen medialen Artefakten aufzubauen, hypertextuell zu verflechten und f√ºr die Wissenschaften produktiv zu machen oder der breiteren √ñffentlichkeit zur Verf√ºgung zu stellen.\nEngelbarts Dynamic Knowledge Repository. Neben der Computermaus geht auf Douglas Engelbart die Vorstellung zur√ºck, dass der Computer \u0026ndash; wenn wir ihn richtig einsetzen \u0026ndash; unsere kollektive Intelligenz exponentiell steigern wird. Zentral ist dabei die Idee eines Wissensspeichers, der nicht nur einen statischen Wissensvorrat enth√§lt, sondern durch eine dialoghafte Interaktion zwischen Mensch und Computer zu einem Katalysator f√ºr das Denken wird.\nF√ºr die meisten von uns wird Digital Gardening bescheidener und pers√∂nlicher sein, so auch f√ºr mich: wenn ich etwas, lerne, lese, konstruiere, ein Problem bearbeite usw.: dann fertige ich dazu gern Notizen an und versuche, sie so zu verlinken, dass ich sie im passenden Arbeitskontext wiederfinden kann. Die Datenbasis daf√ºr sind Textdateien in einem Git-versionierten Verzeichnis. In diesem Garten gedeihen vielf√§ltige Gew√§chse: Stichwortlisten, Linksammlungen, Protokolle, HowTos, Zusammenfassungen, Taxonomien, und manchmal auch Texte wie dieser.\nLinks zum Thema\nA Brief History of Digital Gardens How the Blog Broke the Web The Garden and the Stream: a Technopastoral As We May Think "}]