---
title: "ADTs, GADTS, Typklassen"
weight: -20230707
# bookFlatSection: false
# bookToc: false
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

2023-07-07

# ADTs, GADTs, Typklassen

Ich habe vor Kurzem *funktionale Abh√§ngigkeiten* kennengelernt und
hatte gleich den Impuls, dar√ºber zu schreiben.  Das ist eine gute
Gelegenheit, um etwas ausf√ºhrlicher auf Konzepte der Typebene
in Sprachen wie Haskell, Purescript, Elm und Ocaml einzugehen.


## Einfache Datentypen

Die meisten Sprachen bringen einen Vorrat an einfachen Datentypen
mit: numerische Datentypen f√ºr ganze Zahlen und Gleitkommazahlen,
Datentypen f√ºr einzelne Buchstaben und andere Schriftzeichen,
einen Datentyp mit den zwei Wahrheitswerten "falsch" und "wahr".

In den Details gibt es gro√üe Unterschiede zwischen den Sprachen,
je nachdem, wo sie ihre Schwerpunkte setzen und welche Form der
Programmierung sie unterst√ºtzen.  Beispielsweise hat C keinen
speziellen Datentyp f√ºr Wahrheitswerte, Python und Javascript
unterscheiden nicht streng zwischen einzelnen Schriftzeichen und
Zeichenketten, Javascript unterscheidet nicht zwischen ganzen Zahlen
und Gleitkommazahlen, TCL kennt nur Zeichenketten, ...

Ein paar einfache Datentypen in Haskell:

- `Int`: ganze Zahlen wie `-3`, `0`, `123`, `999999999`, ...
- `Float`: Gleitkommazahlen wie `-123.45`, `1.0`, `3.141592653`, ...
- `Char`: Zeichen wie `'a'`, `'Œ≤'`, `'7'`, `'+'`, `'?'`, `'üôÇ'`, ...
- `Bool`: die Wahrheitswerte `True` und `False`.


## Die Gr√∂√üe einfacher Datentypen

Man kann einen Datentyp auffassen als die Menge seiner Werte.
Hier als Beispiel der Datentyp `Bool` in Mengenschreibweise:

    Bool = { False , True }

Die Gr√∂√üe eines Datentyps ist die Anzahl seiner Werte.
Der Datentyp `Bool` enth√§lt genau zwei Werte.  Damit ist seine
Gr√∂√üe 2.

Das gleiche Spiel kann man mit allen einfachen Datentypen spielen.
Der kleinste `Int` Wert auf meinem Rechner ist die ganze Zahl
`-9223372036854775808` und der gr√∂√üte `Int` Wert die ganze Zahl
`9223372036854775807`.  Daraus ergibt sich f√ºr den Datentyp `Int`
die Gr√∂√üe `2^64`.

Die Gr√∂√üe eines einfachen Datentyps h√§ngt letztlich auch damit
zusammen, wie viele Bits mindestens ben√∂tigt werden um einen
seiner Werte zu codieren.  Ein `Int` Wert ist auf meinem Rechner
in 64 Bits codiert.  Daraus ergibt sich, dass `2^64` verschiedene
`Int` Werte codiert werden k√∂nnen.  In Sprachen wie C, die daf√ºr
gemacht sind, m√∂glichst effiziente Programme zu schreiben und
verh√§ltnism√§√üig nah an der Hardware zu programmieren, bedeutet
ein Datentyp im Grunde nicht mehr als die Anzahl von Bits, die
einer seiner Werte im Speicher mindestens ben√∂tigt.

Bei `Char` und `Float` ist die Berechnung der Gr√∂√üe etwas
komplizierter.  vom Datentyp `Char` gibt es insgesamt `1114112`
Werte.  F√ºr `Float` wei√ü ich es nicht, aber es l√§sst sich
grunds√§tzlich ausrechnen.


## Zusammengesetzte Datentypen

Zusammengesetzte Datentypen sind bspw. Arrays, Listen, Strings,
Tupel, Records und Structs.  Das sind allesamt Datentypen, die sich
-- wie der Name sagt -- auf irgendeine Art aus anderen Datentypen
zusammensetzen.

Ein Record-Datentyp f√ºr ganzzahlige Punkte in der Ebene k√∂nnte
so aussehen:

    -- Purescript
    type Point = { x :: Int , y :: Int }

Ein Tupel-Datentyp f√ºr den selben Zweck:

    -- Haskell
    (Int,Int)

Der Record-Datentyp hat den Vorteil, dass die Felder mit x und y
bezeichnet sind.  Dadurch ist es vermutlich etwas schwerer, sie
zu verwechseln.  Au√üerdem k√∂nnen wir direkt √ºber die Feldnamen
auf ihre Werte zugreifen.  Beim Tupel-Datentyp verlassen wir uns
auf die Position der Felder f√ºr ihre Unterscheidung.  Der Zugriff
auf die Felder erfolgt √ºber Pattern-Matching in Case Expressions
oder √ºber spezielle Zugriffsfunktionen wie `fst` und `snd`.
Daf√ºr deckt sich die Tupel-Schreibweise mit der Schreibweise f√ºr
Punkte in der Ebene, die auch sonst √ºblich ist.  Das sind aber rein
ergonomische Unterschiede.  Strukturell unterscheiden sich diese
beiden Datentypen nicht voneinander: in beiden F√§llen besteht ein
Punkt aus zwei `Int` Werten.


## Die Gr√∂√üe zusammengesetzter Datentypen

Es gibt auf meinem Rechner `2^64` Werte vom Datentyp `Int`.
F√ºr den Datentyp `Point` ergeben sich damit `2^64 * 2^64` also
`2^128` Werte.  Das selbe gilt f√ºr den Datentyp `(Int,Int)`.
Solche Datentypen, die sich aus anderen Datentypen zusammensetzen,
so dass ihre Gr√∂√üe das Produkt der Gr√∂√üen der beteiligten
Datentypen ist, hei√üen **Produkttypen**.  Array-Datentypen und
C-Structs sind auch Produkttypen.  Ein bisschen komplexer ist es
bei Listen und Strings.  Mehr dazu weiter unten.

In allen herk√∂mmlichen Sprachen kann man Produkttypen definieren,
aber oft fehlt die M√∂glichkeit, **Summentypen** zu definieren.
Das sind Datentypen, die sich aus anderen Datentypen zusammensetzen,
so dass ihre Gr√∂√üe die Summe der Gr√∂√üen der beteiligten
Datentypen ist.


## Algebraische Datentypen

Algebraische Datentypen (ADTs) vereinen in sich Produkttypen und
Summentypen: jeder ADT ist eine Summe von Produkten.


**Summen**

Einer der einfachsten ADTs ist der Datentyp `Bool` in Haskell:

    -- Haskell
    data Bool = False | True

`False` und `True` sind sogenannte Wertekonstruktoren (oder einfach
nur Werte).  Den Balken m√ºssen wir lesen wie ein exklusives Oder:
jeder Wert vom Datentyp `Bool` ist entweder `False` oder `True`.
Andere als diese zwei `Bool` Werte gibt es nicht.

ADTs k√∂nnen beliebig viele Wertekonstruktoren haben:

    -- Haskell

    data Ampel = Gr√ºn | Gelb | Rot

    data K√§se = Gouda | Cheddar | Brie | Camembert | Gruy√®re
    
    data T = A | B | C | D | E | F | G | H | I | J | K

Wir k√∂nnen auch einen ADT mit genau einem Wertekonstruktor
definieren:

    -- Haskell
    data Eindeutig = Einheit

Hier hat nur der Wert `Einheit` den Datentyp `Eindeutig`.
Damit besteht zwischen dem Datentyp und dem Wert eine
Eins-zu-eins-Beziehung.  Sogar der Spezialfall eines ADT mit
keinen Wertekonstruktoren ist m√∂glich.  Wir geben einfach keine
Wertekonstruktoren an:

    -- Haskell
    data Nichts

Damit hat der Datentyp `Nichts` keine Werte.  Wir haben daher keine
M√∂glichkeit, einen Wert vom Datentyp `Nichts` zu erzeugen oder eine
Funktion anzuwenden, die auf `Nichts` operiert.  Leere Datentypen
sind nicht nutzlos, aber darauf werde ich hier nicht weiter eingehen.
Stattdessen m√∂chte ich auf eine Sache hinweisen, die Verwirrung
stiften kann.  Betrachte daf√ºr die folgende Typdefinition:

    -- Haskell

    data Tasche
        = T√ºte
        | Beutel
        | Rucksack
        | G√ºrteltasche
        | Tasche

Hier definieren wir den Datentyp `Tasche` mit den Werten  `T√ºte`,
`Beutel`, `Rucksack`, `G√ºrteltasche` und `Tasche`.  Es sticht
ins Auge, dass der Name `Tasche` zweimal auftaucht: einmal als
der Datentyp `Tasche`, einmal als der Wertekonstruktor `Tasche`.
F√ºr den Compiler ist das kein Problem.  Er unterscheidet streng
zwischen Datentypen und Wertekonstruktoren und kann sie nicht
verwechseln, auch wenn sie den selben Namen haben.  Das Beispiel ist
zwar an den Haaren herbeigezogen, aber es ist tats√§chlich manchmal
sinnvoll, einem Datentyp und einem seiner Wertekonstruktoren den
selben Namen zu geben.  Weiter unten wird uns so etwas begegnen.

**Wertekonstruktoren mit Feldern**

Bisher haben wir einfache Wertekonstruktoren wie `False`, `Gouda`,
`Rucksack`, `A` usw. gesehen.  Wertekonstruktoren k√∂nnen aber
typisierte Felder haben.  Hier ein Beispiel:

    -- Haskell
    data Lampe = Leuchtet Bool

Der Datentyp `Lampe` hat den Wertekonstruktor `Leuchtet` mit einem
Feld vom Datentyp `Bool`.  Bisher haben wir die Begriffe *Wert*
und *Wertekonstruktor* als Synonyme behandelt.  Das √§ndert sich
sobald Felder ins Spiel kommen.  Der Wertekonstruktor `Leuchtet`
ist allein noch kein Wert vom Datentyp `Lampe`.  Wir m√ºssen ihn
um einen `Bool` Wert erg√§nzen, um einen Wert vom Datentyp `Lampe`
zu erzeugen.

    -- Haskell Repl

    > data Lampe = Leuchtet Bool

    > :type Leuchtet
    Leuchtet :: Bool -> Lampe

    > lampeAn = Leuchtet True

    > :type lampeAn
    lampeAn :: Lampe


**Produkte**

Wertekonstruktoren k√∂nnen mehr als ein Feld haben.  Hier ein
Beispiel:

    -- Haskell
    data Datum = Datum Int Int Int  -- Tag Monat Jahr

Der Datentyp `Datum` hat einen Wertekonstruktor `Datum` mit drei
Feldern vom Datentyp `Int`.  So ein Datentyp  entspricht den normalen
Produkttypen, die wir oben schon kennengelernt haben.


**Summen von Produkten**

In einem ADT lassen sich Produkte und Summen kombinieren.  Hier ein
Datentyp mit drei Wertekonstruktoren, die jeweils ein Feld vom
Datentyp `Bool` haben:

    -- Haskell
    data MyType = X Bool | Y Bool | Z Bool

Daraus ergeben sich die folgenden konkreten Werte:

- `X False`
- `X True`
- `Y False`
- `Y True`
- `Z False`
- `Z True`

Hier ein Datentyp mit f√ºnf Wertekonstruktoren und unterschiedlichen
Anzahlen von Feldern:

    -- Haskell

    data Zubrot
        = K√§se Bool         -- vegan ja/nein
        | Wurst Bool        -- vegan ja/nein
        | Marmelade Int Int -- Frucht- und Zuckergehalt in %
        | Margarine
        | Butter


## Die Gr√∂√üe algebraischer Datentypen

Die Gr√∂√üe eines ADT ist die Summe der Gr√∂√üen seiner
Wertekonstruktoren.  Die Gr√∂√üe eines Wertekonstruktors ist das
Produkt der Gr√∂√üen seiner Feldtypen.  Ein Wertekonstruktor ohne
Felder hat die Gr√∂√üe 1.  Ein Datentyp ohne Wertekonstruktoren
hat die Gr√∂√üe 0.

Wir berechnen die Gr√∂√üe f√ºr ein paar ADTs:

    |Nichts| == 0

    |Eindeutig| == |Einheit| == 1
    
    |Bool| == |False| + |True| == 1 + 1 == 2
    
    |Ampel| == |Gr√ºn| + |Gelb| + |Rot| == 1 + 1 + 1 == 3

    |Lampe| == |Leuchtet Bool| == |Bool| == 2

    |Datum| == |Datum Int Int Int|
            == |Int| * |Int| * |Int|
            == 3^64 * 3^64 * 3^64
            == 3^192

    |MyType| == |X Bool| + |Y Bool| + |Z Bool|
             == |Bool| + |Bool| + |Bool|
             == 2 + 2 + 2
             == 6

    |Zubrot| == |K√§se Bool| + |Wurst Bool| + |Marmelade Int Int|
              + |Margarine| + |Butter|
             == |Bool| + |Bool| + |Int| * |Int| + 1 + 1
             == 2 + 2 + 2^64 * 2^64 + 1 + 1
             == 2^128 + 6

Weiter unten werden wir auch unendlich gro√üe ADTs sehen.


## Der Mehrwert algebraischer Datentypen

Mit ADTs k√∂nnen wir neue Datentypen jeder beliebigen Gr√∂√üe
erzeugen und die Datentypen, die wir schon vorliegen haben, sowohl
additiv als auch multiplikativ zu neuen Datentypen verkn√ºpfen.
F√ºr jede Datenstruktur, die sich so beschreiben l√§sst, k√∂nnen
wir einen ADT definieren.  Ich m√∂chte an zwei Beispielen zeigen,
welchen Mehrwert das hat.


**Beispiel 1: Verkehrsampel**

Ein Datentyp f√ºr die drei Zust√§nde einer aktiven Ampel k√∂nnte
so definiert sein:

    --Haskell
    data Ampel = Gr√ºn | Gelb | Rot

Viele herk√∂mmliche Sprachen scheitern schon daran, einen genau
dreiwertigen Datentyp zu erzeugen.

Wenn wir entscheiden m√ºssen, ob jemand f√ºr das √úberfahren einer
Ampel im Stra√üenverkehr einen Bu√ügeldbescheid erhalten soll oder
nicht, k√∂nnen wir das wie folgt modellieren:

    -- Haskell

    bu√ügeldbescheid :: Ampel -> Bool
    bu√ügeldbescheid ampel = case ampel of
        Gr√ºn -> False
        Gelb -> False
        Rot -> True

Hier ist `bu√ügeldbescheid` eine Funktion von `Ampel` nach `Bool`.
Die drei Werte des Datentyps `Ampel` entsprechen den drei Zust√§nden
einer aktiven Ampel.  Mit anderen als diesen drei Werten m√ºssen
wir uns beim Implementieren nicht auseinandersetzen.  Stattdessen
k√∂nnen wir uns voll und ganz auf das Wesentliche konzentrieren: die
Zuordnung der tats√§chlichen Ampelzust√§nde nach `Bool`.  Auch beim
Verwenden der Funktion ohne Kenntnis ihrer Implementierung m√ºssen
wir uns keine Gedanken √ºber andere als diese drei Werte machen,
denn die Funktion akzeptiert nur diese drei und der Compiler sichert
das f√ºr uns ab.

Ganz anders sieht das aus, wenn wir bei der Modellierung des selben
Sachverhaltes ohne ADTs bzw. ohne Summentypen auskommen m√ºssen.
Wir sind dann gezwungen, auf bestehende Datentypen zur√ºckzugreifen.
Zum Beispiel so:

    -- Haskell

    gr√ºn = 0
    gelb = 1
    rot = 2

    bu√ügeldbescheid :: Int -> Bool
    bu√ügeldbescheid ampel =
        ampel /= gr√ºn && ampel /= gelb

Man kann so programmieren, aber die Funktion hat jetzt f√ºr den
Compiler einen Definitionsbereich aus `2^64` Werten.  Drei davon
k√ºmmern uns: n√§mlich `0`, `1` und `2` bzw. `gr√ºn`, `gelb`
und `rot`.  Die √ºbrigen 18446744073709551613 Werte sind f√ºr den
modellierten Sachverhalt √ºberfl√ºssig.  Aber k√∂nnen wir uns darauf
verlassen, dass kein anderer Wert an die Funktion √ºbergeben wird?
So wie sie jetzt implementiert ist, werden die 18446744073709551613
√ºberfl√ºssigen Werte auf `True` abgebildet.  Das k√∂nnte zur Folge
haben, dass Bu√ügeldbescheide an Personen versendet werden, die
nicht bei Rot gefahren sind, weil jemand den Aufruf der Funktion
vermasselt hat, oder weil jemand die Dokumentation nicht richtig
gelesen hat, oder weil die Implementierung sich zwischenzeitlich
ge√§ndert hat: bei einem Refactoring wurde der R√ºckgabewert f√ºr
die 18446744073709551613 √ºberfl√ºssigen Werte ver√§ndert und schon
tritt ein Fehler auf, den es vorher nicht gab.

Hier liegt ein Fehlerpotenzial vor, das es nicht gibt wenn man ADTs
verwendet um die Definitions- und Wertebereiche der Funktionen,
Prozeduren und Methoden so festzulegen, dass sie genau zum
modellierten Sachverhalt passen.


**Beispiel 2: unbekanntes Alter**

Stellen wir uns vor, dass wir einen Datentyp f√ºr das Alter von
Personen als ganze Zahl in Jahren ben√∂tigen.  Es liegt auf der
Hand, daf√ºr den Datentyp `Int` zu verwenden.  Noch besser w√§re
ein Datentyp f√ºr nat√ºrliche Zahlen, aber darum k√ºmmern wir uns
jetzt nicht.

Komplizierter ist es, wenn wir ber√ºcksichtigen m√ºssen, dass das
Alter einer Person unbekannt sein kann.  Wie bilden wir das ab?
Ich zeige erst, wie hier ein ADT helfen kann.  Dann kritisiere
ich, wie das in Sprachen ohne ADTs gel√∂st wird.  Also, hier mein
Vorschlag f√ºr einen passenden Datentyp:

    -- Haskell
    data Alter = AlterUnbekannt | Alter Int

Ein Wert vom Datentyp `Alter` ist entweder `AlterUnbekannt` oder
`Alter` mit einem `Int` Feld.  Stellen wir uns die drei Personen
Marit, Marta und Max vor.  Marit ist 30, Marta ist 11 und von Max
kennen wir das Alter nicht.

    -- Haskell

    maritAlter :: Alter
    maritAlter = Alter 30

    martaAlter :: Alter
    martaAlter = Alter 11

    maxAlter :: Alter
    maxAlter = AlterUnbekannt

Auf diese Weise unterscheiden wir sauber zwischen einem bekannten und
einem unbekannten Alter.  Eine Funktion, die Altersklassen bestimmt,
k√∂nnte so aussehen:

    -- Haskell

    data Altersklasse
        = Minderj√§hrig
        | Vollj√§hrig
        | AltersklasseUnbekannt
    
    altersklasse :: Alter -> Altersklasse
    altersklasse Alter = case alter of
        Alter n -> if n < 18 then Minderj√§hrig else Vollj√§hrig
        AlterUnbekannt -> AltersklasseUnbekannt

Schauen wir uns die Altersklassen von Marit, Marta und Max an:

    -- Haskell Repl

    > altersklasse maritAlter
    Vollj√§hrig

    > altersklasse martaAlter
    Minderj√§hrig

    > altersklasse maxAlter
    AltersklasseUnbekannt

Dadurch, dass unser Datentyp `Alter` ganz ausdr√ºcklich auch den Wert
`AlterUnbekannt` hat, m√ºssten wir uns schon besondere M√ºhe geben,
um diesen Fall bei der Berechnung der Altersklasse unter den Tisch
fallen zu lassen.

Aber wie w√ºrden wir das ohne ADTs modellieren?  Hier noch mal der
zu modellierende Sachverhalt: wir m√ºssen das Alter von Personen
codieren und dabei ber√ºcksichtigen, dass ein Alter unbekannt sein
kann.  In Sprachen ohne ADTs gibt es f√ºr die Codierung solcher
Sonderf√§lle zwei verschiedene L√∂sungsans√§tze.


**Ansatz 1 ohne ADTs: Numerische Fehlercodes**

Bilde Sonderf√§lle wie Fehlercodes auf Werte ab, die zum selben
Datentyp geh√∂ren wie die modellierte Gr√∂√üe, aber offensichtlich
kein Wert der modellierten Gr√∂√üe sind.  Das setzt voraus, dass
der Datentyp zus√§tzlichen Platz daf√ºr bietet.  Ein gutes Beispiel
daf√ºr ist die Java String-Methode `indexOf`, die man verwendet um
nach Substrings zu suchen.  Wenn der Substring gefunden wurde, wertet
`indexOf` zu dem Index aus, bei dem der Substring beginnt.  Wenn der
Substring nicht gefunden wurde, wertet `indexOf` zu `-1` aus:

    // Java
    "abc".indexof("c")  // Wertet aus zu: 2
    "abc".indexOf("d")  // Wertet aus zu: -1 

Die Idee dahinter ist, dass Indizes nat√ºrliche Zahlen sind und
dass daher mit dem R√ºckgabewert `-1` offensichtlich kein Index
gemeint sein kann.  In unserem Fall k√∂nnte der Ansatz so aussehen:

    -- Haskell

    maritAlter :: Int
    maritAlter = 30

    martaAlter :: Int
    martaAlter = 11

    maxAlter :: Int
    maxAlter = -1

Wenn wir jetzt die Altersklassen berechnen und dabei nicht genau
aufpassen, k√∂nnte die folgende Funktion zustande kommen:

    -- Haskell

    data Altersklasse = Minderj√§hrig | Vollj√§hrig

    altersklasse :: Int ->  Altersklasse
    altersklasse alter =
        if alter < 18 then Minderj√§hrig else Vollj√§hrig

Die Altersklassen f√ºr Marit, Marta und Max sehen dann wie folgt aus:

    -- Haskell Repl

    > altersklasse maritAlter
    Vollj√§hrig

    > altersklasse martaAlter
    Minderj√§hrig

    > altersklasse maxAlter
    Minderj√§hrig

Das ist nat√ºrlich Murks.  Wir wissen gar nicht, ob Max minderj√§hrig
ist, weil wir sein Alter nicht kennen.  Der Fehler ist aber
nachvollziehbar: bei der Implementierung von `altersklasse` legen
wir fest, dass Personen minderj√§hrig sind wenn ihr Alter in Jahren
kleiner als 18 ist, denn genau so ist Minderj√§hrigkeit definiert.
Um den Fehler zu vermeiden, m√ºssen wir wissen, dass hier auch
negative Zahlen zu ber√ºcksichtigen sind und dass `-1` das Fehlen
der Altersinformation repr√§sentiert:

    -- Haskell

    data Altersklasse
        = Minderj√§hrig
        | Vollj√§hrig
        | AltersklasseUnbekannt

    altersklasse :: Int ->  Altersklasse
    altersklasse alter =
        if alter < 0 then AltersklasseUnbekannt
        else if alter < 18 then Minderj√§hrig
        else Vollj√§hrig

Wir gehen hier noch einen Schritt weiter und bilden alle negativen
Zahlen auf `AltersklasseUnbekannt` ab.  Dadurch sind wir schon
auf der sicheren Seite wenn weitere Fehlercodes dazukommen.
Die Altersklassen f√ºr Marit, Marta und Max stimmen jetzt wieder:

    -- Haskell Repl

    > altersklasse maritAlter
    Vollj√§hrig

    > altersklasse martaAlter
    Minderj√§hrig

    > altersklasse maxAlter
    AltersklasseUnbekannt

Javas `indexOf` Methode hat die gleiche Schw√§che.  Wenn wir
bspw. in vielen Strings den gleichen Substring suchen, um seinen
durchschnittlichen Index zu berechnen, d√ºrfen wir nicht vergessen,
den Wert `-1` gesondert zu verarbeiten.  Sonst berechnen wir
ein falsches Ergebnis.  Besser ist es, wenn wir zwischen der
erfolgreichen und der gescheiterten Suche so unterscheiden, dass
auch der Compiler diese Unterscheidung absichert.  Andernfalls liegt
die volle Verantwortung f√ºr diese Unterscheidung bei der Person,
die programmiert.


**Ansatz 2 ohne ADTs: Nullreferenzen**

Verwende Referenzdatentypen und stelle fehlende Werte dar als
Nullreferenzen.  Ein gutes Beispiel daf√ºr ist die Prozedur `strstr`
aus der C-Standard-Bibliothek:

    // C
    char *result = strstr(myString, mySubstr);

Wenn `mySubstr` in `myString` enthalten ist, dann enth√§lt `result`
jetzt eine Referenz auf die Speicheradresse der Anfangsposition von
`mySubstr` innerhalb von `myString`.  Andernfalls enth√§lt `result`
jetzt die Nullreferenz `NULL`.

In Sprachen, die es erlauben, Nullreferenzen so zu verwenden,
muss man h√∂llisch aufpassen: es kann passieren, dass man glaubt,
einen Wert zu verarbeiten obwohl man eine Nullreferenz verarbeitet.
Das f√ºhrt leicht zu Laufzeitfehlern.  In Haskell, Purescript,
etc. kann ich das nicht demonstrieren, weil es in diesen Sprachen
keine Referenzdatentypen und keine Nullreferenzen gibt.  Deswegen
hier ein bisschen Java Code:

    // Main.java

    class Alter {
        int wert;
        public Alter(int wert) {
            this.wert = wert;
        }
        public int get() {
            return this.wert;
        }
    }
    class Person {
        public Alter alter;
        enum Altersklasse { minderj√§hrig, vollj√§hrig }
        public Altersklasse altersklasse() {
            if (this.alter.get() < 18) {
                return Altersklasse.minderj√§hrig;
            } else {
                return Altersklasse.vollj√§hrig;
            }
        }
    }
    class Main {
        public static void main(String[] args) {
            Person marit = new Person();
            Person marta = new Person();
            Person max = new Person();

            marit.alter = new Alter(30);
            marta.alter = new Alter(11);

            System.out.println(marit.altersklasse());
            System.out.println(marta.altersklasse());
            System.out.println(max.altersklasse());
        }
    }

Ich wickle das Alter einer Person hier in einen Datentyp `Alter` ein,
weil Basisdatentypen wie `int` in Java keine Referenzdatentypen sind.
Das passiert wenn wir das Programm compilieren und ausf√ºhren:

    $ javac Main.java
    $ java Main
    vollj√§hrig
    minderj√§hrig
    Exception in thread "main" java.lang.NullPointerException
            at Person.altersklasse(Main.java:21)
            at Main.main(Main.java:14)

Wir haben f√ºr Max kein Alter festgelegt.  Sobald wir seine
Altersklasse abrufen, terminiert das Programm mit einer
`NullPointerException`.  Selbstverst√§ndlich l√§sst sich das
beheben, indem wir die Aufz√§hlung `Altersklasse` und die Methode
`altersklasse` anpassen, so wie wir es auch weiter oben gemacht
haben.  Die volle Verantwortung daf√ºr, solche Laufzeitfehler zu
vermeiden, liegt hier wieder bei der Person, die programmiert.

Welcher dieser beiden Ans√§tze ist besser?  Das kommt darauf an, ob
uns die Vermeidung von Laufzeitfehlern oder die Vermeidung falscher
Ergebnisse wichtiger ist.  Bei der Haskell-Funktion `altersklasse ::
Alter -> Altersklasse`, mit der wir begonnen haben, er√ºbrigt sich
diese Abw√§gung: Nullreferenzen gibt es nicht und um das numerische
Alter mit einem Fehlercode zu erg√§nzen, f√ºhren wir einen neuen
Datentyp ein, der durch zwei Wertekonstruktoren sauber unterscheidet
zwischen einem bekannten und einem unbekannten Alter.


## Parametrische algebraische Datentypen

Parametriche ADTs sind ADTs, die in ihrer Definition einen
sogenannten *Typparameter* enthalten.  Das ist ein Platzhalter,
der durch einen konkreten Datentyp ersetzt werden muss, damit
aus dem parametrischen ADT ein konkreter Datentyp wird.  Solche
Datentypen, die erst noch konkretisiert werden m√ºssen, nennt man
auch *generische Datentypen*.  Um das Konzept zu demonstrieren,
schauen wir uns noch mal den oben definierten Datentyp `Alter` an.
Wir steigen an der Stelle von Haskell auf Purescript um, damit wir
weiter unten Record-Literale verwenden k√∂nnen:

    -- Purescript
    data Alter = AlterUnbekannt | Alter Int

Wir haben diesen Datentyp eingef√ºhrt, um zu modellieren, dass das
Alter einer Person manchmal bekannt und manchmal unbekannt ist.
Aber dieses Problem kann auch bei anderen Daten auftreten.
Wir k√∂nnten daf√ºr jedes mal einen spezifischen Datentyp einf√ºhren:

    -- Purescript
    data Name = NameUnbekannt | Name String
    data Alter = AlterUnbekannt | Alter Int
    data Wohnort = WohnortUnbekannt | Wohnort String
    data Beruf = BerufUnbekannt | Beruf String
    ...

Ein beispielhafter Record f√ºr Marta mit diesen Datentypen k√∂nnte
so aussehen:

    -- Purescript
    marta =
        { name : Name "Marta"
        , alter : Alter 11
        , wohnort : WohnortUnbekannt
        , beruf : BerufUnbekannt
        }

Wir m√ºssen aber nicht jeden Datentyp separat auf diese Weise
erweitern.  Stattdessen k√∂nnen wir einen generischen Datentyp
festlegen, der jeden existierenden Datentyp um die M√∂glichkeit
eines fehlenden Wertes erweitert:

    -- Purescript
    data Vielleicht a = Unbekannt | Wert a

Damit k√∂nnen wir jeden Datentyp so erweitern, dass ein Wert dieses
Typs entweder vorhanden oder abhanden ist.  Wenn wir das Alter
einer Person kennen, sieht das so aus:

    -- Purescript
    alter :: Vielleicht Int
    alter = Wert 23

Wenn wir das Alter nicht kennen, sieht das so aus:

    -- Purescript
    alter :: Vielleicht Int
    alter = Unbekannt

Das gleiche Spiel mit dem Wohnort:

    -- Purescript
    wohnort :: Vielleicht String
    wohnort = Wert "Leipzig"

Oder wenn der Wohnort unbekannt ist:

    -- Purescript
    wohnort :: Vielleicht String
    wohnort = Unbekannt

Beachte, dass das Alter den Datentyp `Int` hat aber der Wohnort
den Datentyp `String`.  Trotzdem konnten wir in beiden F√§llen
den generischen Datentyp `Vielleicht a` einsetzen. Wir haben damit
den Datentyp `Int` auf `Vielleicht Int` und den Datentyp `String`
auf `Vielleicht String` erweitert.  Ein ganzer Record f√ºr Marta
k√∂nnte so aussehen:

    -- Purescript

    marta =
        { name : Wert "Marta"
        , alter : Wert 11
        , wohnort : Wert "Leipzig"
        , beruf : Wert "Sch√ºlerin"
        }

Damit sind die vier spezifischen Datentypen, die wir oben definiert
haben, √ºberfl√ºssig, weil wir sie ersetzen konnten durch einen
einzigen generischen Datentyp, der die selbe Aufgabe erf√ºllt.

In der Praxis w√ºrde man einen Datentyp wie `Vielleicht a` nicht
definieren, sondern den Datentyp `Maybe a` verwenden, der genau
f√ºr diesen Zweck schon vordefiniert ist und die selbe Struktur hat.
Zum Vergleich hier die beiden Datentypen:

    -- Purescript
    data Vielleicht a = Unbekannt | Wert a
    data Maybe a = Nothing | Just a

Es geh√∂rt zum guten Programmierstil, die vordefinierten Datentypen
zu verwenden wenn die Struktur passt.  Das erh√∂ht die Lesbarkeit.
Es kann zwar manchmal sinnvoll sein, trotzdem eigene Datentypen
zu verwenden, um zu verdeutlichen, worum es geht, aber je mehr man
beim Lesen von Code schon kennt, desto verst√§ndlicher ist der Code.


## Unendlich gro√üe Datentypen

Bisher haben wir nur ADTs mit endlicher Gr√∂√üe betrachtet.  Es gibt
aber auch ADTs, die unendlich gro√ü sind.  Das ist zum Beispiel
der Fall bei ADTs, die rekursiv √ºber sich selbst definiert sind.
Ein gutes Beispiel daf√ºr sind verkettete Listen:

    -- Purescript
    List a = Nil | Cons a ( List a )

`Nil` ist der gebr√§uchliche Name f√ºr die leere Liste.  Das hat
historische Gr√ºnde.  `Cons` nimmt einen Wert und eine Liste und
konstruiert daraus wieder eine Liste.  Die Idee dabei ist, dass man
mit der leeren Liste beginnt und von ihr ausgehend `Cons` verwendet
und durch das sukzessive Hinzuf√ºgen weiterer Werte immer gr√∂√üere
Listen konstruiert.  Hier demonstrieren wir schrittweise den Aufbau
einer Liste mit den ersten Ziffern der Kreiszahl Pi 3,1415...

    -- Purescript
    
    list0 = Nil
    list1 = Cons 5 Nil
    list2 = Cons 1 ( Cons 5 Nil )
    list3 = Cons 4 ( Cons 1 ( Cons 5 Nil ) )
    list4 = Cons 1 ( Cons 4 ( Cons 1 ( Cons 5 Nil ) ) )
    list5 = Cons 3 ( Cons 1 ( Cons 4 ( Cons 1 ( Cons 5 Nil ) ) ) )

Haskell unterst√ºtzt f√ºr verkettete Listen eine kompaktere und
freundlichere Syntax, mit der man z.B. `list5` schreiben kann
als `[3,1,4,1,5]`.  Aber letztlich erfolgt die Konstruktion von
verketteten Listen auch in Haskell genau so wie oben beschrieben.

`List a` ist generisch (bzw. parametrisch).  Diese Beispiele haben
allesamt den Datentyp `List Int`.  Nat√ºrlich k√∂nnen wir auch Listen
von Bools oder Floats oder Strings etc. konstruieren.  Die Werte
einer Liste m√ºssen aber allesamt den selben Datentyp haben.

Aus der Definition des generischen Listendatentyps folgt, dass
man aus einer Liste der Gr√∂√üe `n` immer eine Liste der Gr√∂√üe
`n+1` konstruieren kann indem man noch ein Element hinzuf√ºgt.
Daraus ergibt sich, dass Listendatentypen unendlich gro√ü sind.
Der Datentyp `String` ist in Standard-Haskell ein Typalias f√ºr
`List Char` und damit auch unendlich gro√ü.  In Purescript werden
Strings wahrscheinlich irgendwie auf Javascript-Strings abgebildet.
Auch davon gibt es unendlich viele, da man sie durch Verkettung
beliebig verl√§ngern kann.


## Einfache Datentypen sind ADTs

Ich habe es hier noch nicht erw√§hnt, aber bestimmt ist es schon
aufgefallen: die Namen von Datentypen und von Wertekonstruktoren
in einer Typdefinition mit dem `data` Schl√ºsselwort beginnen in
Haskell und in Purescript immer mit einem Gro√übuchstaben.  In Elm
ist es auch so, mit dem Unterschied, dass das Schl√ºsselwort in
Elm nicht `data`  sondern `type` ist.

W√§hrend f√ºr den Datentyp `Bool` mit den Werten `False`
und `True` in Haskell eine normale Typdefinition [vordefiniert
ist](https://hackage.haskell.org/package/ghc-prim-0.10.0/docs/src/GHC.Types.html#Bool),
ist der Datentyp `Boolean` mit den Werten `false` und `true`
in Purescript in den Compiler integriert.  Purescript ist
daf√ºr gemacht, nach Javascript zu compilieren.  Um die zu
√ºberbr√ºckende Kluft zwischen den Purescript-Datentypen und den
Javascript-Datentypen, die nach der Compilation √ºbrigbleiben,
m√∂glichst klein zu halten, orientieren sich die vordefinierten
Datentypen in Purescript an den Datentypen, die auch in Javascript
verf√ºgbar sind.  Deswegen gibt es in Purescript statt `Bool`
den Datentyp `Boolean` mit den Werten `false` und `true`, die vom
Compiler in die gleichnamigen Javascript-Werte `false` und `true`
√ºbersetzt werden.  Das gleiche macht der Purescript-Compiler mit
Zahlenliteralen, Arrays und Records.

Trotz der Sonderbehandlung durch den Compiler, h√§tte man die
Wahrheitswerte auch in Purescript `False` und `True` nennen k√∂nnen.
Ich vermute, dass man sich bewusst f√ºr die Kleinschreibung
entschieden hat, um kenntlich zu machen, dass es sich um keine
gew√∂hnlichen Wertekonstruktoren aus einer `data` Typdefinition
handelt.

Es gibt noch mehr vordefinierte Datentypen -- auch in Haskell
-- deren Werte nicht √ºber eine herk√∂mmliche Typdefinition mit
Wertekonstruktoren erzeugt worden sind, sondern auf besondere Weise
vom Compiler unterst√ºtzt werden.  Die numerischen Datentypen sind
das beste Beispiel daf√ºr.  Eine Sonderbehandlung numerischer
Datentypen und Werte durch den Compiler ist schon f√ºr die
syntaktische Unterst√ºtzung der gew√∂hnlichen Zahlenliterale wie
`-123.45`, `0.0` und `99999` n√∂tig, aber auch f√ºr die effiziente
Arithmetik auf diesen Datentypen.

In Haskell kommt noch dazu, dass Zahlenliterale wie `1` und `1.0`
√ºberladen sind.  `1` kann in Haskell sowohl f√ºr den `Int` Wert
`1` als auch f√ºr den `Float` wert `1.0` stehen.  Es kommen sogar
noch weitere Datentypen in Frage:

    -- Haskell Repl

    > 1 :: Int
    1

    > 1 :: Integer
    1

    > 1 :: Float
    1.0

    > 1 :: Double
    1.0

    > import Numeric.Natural

    > 1 :: Natural
    1

`Integer` ist ein Datentyp f√ºr ganze Zahlen, der beliebig gro√üe
Zahlen aufnehmen kann, solange der Speicherplatz es zul√§sst.
`Natural` ist ein Datentyp f√ºr nat√ºrliche Zahlen.  Zahlenliterale
in Gleitkommaschreibweise sind in Haskell ebenso √ºberladen:

    -- Haskell Repl

    > 1.0 :: Int
    1

    > 1.0 :: Integer
    1

    > 1.0 :: Float
    1.0

    > 1.0 :: Double
    1.0

    > import Numeric.Natural

    > 1.0 :: Natural
    1

Trotz ihrer Besonderheiten, k√∂nnen wir solche Datentypen auch
als ADTs auffassen.  Die Wahrheitswerte `false` und `true`
werden in Purescript zwar klein geschrieben, aber das ist
nur Syntax.  Davon abgesehen k√∂nnen wir komplett ignorieren,
dass der Datentyp `Boolean` nicht auf einer herk√∂mmlichen `data`
Typdefinition basiert.  Es folgt daraus nichts, worauf wir beim
Programmieren achtgeben m√ºssten.  So ist es auch mit den numerischen
Datentypen: Zahlenliterale wie `-3.1415` und `42` sind zwar keine
gew√∂hnlichen Wertekonstruktoren, aber wir k√∂nnen jeden numerischen
Datentyp auffassen als einen Summentyp mit all seinen Werten als
Wertekonstruktoren ohne Typfelder:

    -- Pseudo-Haskell
    data Natural = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | ...

Prinzipiell k√∂nnten wir die ganzen numerischen Datentypen
und die gesamte Zahlenarithmetik auch aus gew√∂hnlichen `data`
Typdefinitionen nachbauen.  Wir m√ºssen uns daf√ºr nur streng an
die Konstruktionsregeln halten.  F√ºr nat√ºrliche Zahlen sind das
die Peano-Axiome.  Ein selbstgebauter Datentyp f√ºr nat√ºrliche
Zahlen k√∂nnte so aussehen:

    -- Haskell

    data Nat = Null | Nachfolger Nat

    plus :: Nat -> Nat -> Nat
    plus a b = case a of
        Nachfolger n -> plus n ( Nachfolger b ) 
        Null -> b

    mal :: Nat -> Nat -> Nat
    mal a b = case a of
        Null -> Null
        Nachfolger Null -> b
        Nachfolger n -> plus b ( mal n b )

F√ºr fast alle praktischen Anwendungen w√§re das v√∂llig unbrauchbar.
Ohne die spezielle Syntax f√ºr Zahlenliterale w√§re es sehr sehr
umst√§ndlich und m√ºhsam, Zahlen aufzuschreiben und zu lesen.
Die Zahlenarithmetik w√§re damit unendlich langsam.  Worum es mir
hier geht, ist, dass sich numerische Datentypen, Arrays, Records,
Strings usw. zumindest rein formal auch als algebraische Datentypen
auffassen lassen.  Das verdeutlicht, wie flexibel ADTs sind: jeder
Datentyp, der sich als ein Summentyp aus Produkttypen darstellen
l√§sst, kann als ADT beschrieben werden.


## Isomorphismen und Aliase

Bisher haben wir neue Datentypen mit dem `data` Schl√ºsselwort
definiert.  Wir k√∂nnten es dabei belassen.  Es gibt aber noch zwei
weitere Schl√ºsselw√∂rter, mit denen sich Datentypen definieren
lassen: `newtype` und `type`.


**Isomorphismen**

Mit dem `newtype` Schl√ºsselwort lassen sich neue Datentypen
definieren, die genau einen Wertekonstruktor mit genau einem Feld
haben.  Damit ist `newtype` auf den ersten Blick √ºberfl√ºssig, denn
dasselbe k√∂nnen wir auch mit dem `data` Schl√ºsselwort erledigen:

    -- Haskell
    data T1 = K1 Bool
    newtype T2 = K2 Bool

Wenn man dasselbe auch mit dem `data` Schl√ºsselwort machen kann,
warum gibt es dann f√ºr diesen Spezialfall ein zus√§tzliches
Schl√ºsselwort?  Um das beanworten zu k√∂nnen, m√ºssen wir wissen,
dass die Verwendung von Datentypen mit gewissen Laufzeitkosten
verbunden ist.  Beispielsweise einen `Int` Wert in einen `Maybe`
Kontext zu stecken und an anderer Stelle wieder aus diesem
`Maybe` Kontext zu befreien: das sind Rechenoperationen, die
zur Laufzeit des Programms stattfinden und ein kleines bisschen
Speicher und Rechenzeit kosten.  Wir nehmen das normalerweise gern
in Kauf, weil uns ein korrektes Programm ohne Laufzeitfehler in den
meisten F√§llen viel wichtiger ist als ein Programm, das m√∂glichst
schnell und speichereffizient arbeitet, aber der Sonderfall eines
Datentyps `T` aus genau einem Wertekonstruktor mit genau einem
Feld ist hier deswegen interessant, weil bei so einem Datentyp eine
Eins-zu-eins-Beziehung zwischen den Werten von `T` und den Werten
des Feldtyps besteht.  Hier ein Beispiel:

    -- Haskell
    data WrapInt = Wrap Int

Dann gilt die Eins-zu-eins-Beziehung:

    ...
    Wrap -3 <--> -3 
    Wrap -2 <--> -2 
    Wrap -1 <--> -1 
    Wrap 0  <--> 0 
    Wrap 1  <--> 1 
    Wrap 2  <--> 2 
    Wrap 3  <--> 3 
    Wrap 4  <--> 4 
    Wrap 5  <--> 5 
    Wrap 6  <--> 6 
    Wrap 7  <--> 7 
    ...

In der Mathematik nennt man so eine Eins-zu-eins-Beziehung einen
Isomorphismus.  Wenn ein Isomorphismus zwischen Datentypen besteht,
ist es schade um den Speicher und die Rechenzeit, die es zur
Laufzeit des Programms kostet, Werte zwischen diesen Datentypen
zu konvertieren.  Hier kommt `newtype` ins Spiel.  Ein Beispiel:

    -- Haskell
    newtype Password = Password String

Es kann sinnvoll sein, f√ºr Passw√∂rter einen eigenen Datentyp
einzuf√ºhren.  Am Ende ist nat√ºrlich jedes Passwort einfach nur
ein String, aber wenn wir auf der Typebene zwischen `String` und
`Password` streng unterscheiden, k√∂nnen wir z.B. die Erzeugung von
schlechen Passw√∂rtern verhindern.  Daf√ºr legen wir ein eigenes
Modul an, das den Datentyp `Password` und bspw. eine sorgf√§ltig
geschriebene Funktion `makePassword : IO Password` enth√§lt.  Der
entscheidende Trick ist, dass wir den Wertekonstruktor `Password`
nicht exportieren.  Dadurch ist Code au√üerhalb dieses Moduls
gezwungen, die Funktion `makePassword` zu verwenden, um an einen
`Password` Wert zu kommen.

Wir k√∂nnen semantisch (fast) exakt dasselbe auch mit dem `data`
Schl√ºsselwort erreichen, aber wenn wir das `newtype` Schl√ºsselwort
verwenden, entfernt der Compiler alle `Password` Wertekonstruktoren,
so dass zur Laufzeit des Programms nur noch gew√∂hnliche `String`
Werte √ºbrigbleiben.  Dadurch entfallen der Speicher und die
Rechenzeit, die es sonst zur Laufzeit des Programms gekostet h√§tte,
Werte zwischen diesen Datentypen zu konvertieren.

*√úbrigens gibt es doch einen semantischen Unterschied zwischen
`data` und `newtype`, der die Auswertungsstrategie betrifft:
Wertekonstruktoren werden bei `data` verz√∂gert ausgewertet und bei
`newtype` strikt ausgewertet.  Was das bedeutet, m√∂chte ich hier
nicht erl√§utern.  Der Text ist schon lang genug und der Unterschied
ist ohnehin marginal: beide Auswertungsstrategien f√ºhren auf den
gleichen Wert, wenn sie erfolgreich auswerten.  Es gibt aber F√§lle
in denen die verz√∂gerte Auswertung Erfolg hat aber die strikte
Auswertung scheitert.  Daher der semantische Unterschied.*


**Aliase**

Das `type` Schl√ºsselwort f√ºhrt einen Typalias bzw. ein
Typsynonym ein.  Das ist einfach nur ein weiterer Name f√ºr einen
existierenden Datentyp.  Beispielsweise sind herk√∂mmliche Strings
in Haskell nichts weiter als verlinkte Listen von `Char` Werten.
Entsprechend ist der Datentyp `String` wie folgt definiert:

    -- Haskell
    type String = List Char

Das Beispiel [stimmt nicht
ganz](https://hackage.haskell.org/package/base-4.18.0.0/docs/src/GHC.Base.html#String):
der Datentyp `List Char` wird in idiomatischem Haskell als `[Char]`
geschrieben.  Darauf m√∂chte ich hier aber nicht n√§her eingehen.
Leider gibt es in Haskell ein paar Schrulligkeiten wie diese, die die
Sprache unn√∂tig und ohne substaniellen Mehrwert verkomplizieren.
Deswegen bin ich wirklich froh, dass es mittlerweile Alternativen
wie Purescript gibt.


## Typklassen

Typklassen werden unterst√ºtzt in Haskell und in Purescript.
Sie haben nichts zu tun mit Klassen in der OOP.  Ein Konzept
aus anderen Sprachen, das mit Typklassen vergleichbar ist, sind
Interfaces.  Jede Typklasse benennt eine Reihe von Funktionen.
Ein Datentyp kann zu einer Typklasse hinzugef√ºgt werden, wenn er
alle Funktionen der Typklasse implementiert.  Hier ein Beispiel
f√ºr eine Typklasse mit einer zu implementierenden Funktion:

    -- Purscript
    class Eq a where
        eq :: a -> a -> Boolean

Ein Datentyp `a` der Klasse `Eq` muss also die Funktion `eq`
implementieren, die zwei Werte vom Datentyp `a` aufnimmt und einen
`Boolean` Wert berechnet.  `Eq` (f√ºr equality) ist sowohl in
Purescript als auch in Haskell eine vordefinierte Typklasse f√ºr
die Datentypen, auf denen die Gleichheitsfunktion `eq` bzw. der
Gleichheitsoperator `==` gegeben sein soll.

Eine Funktion, die wie `eq` auf mehreren Datentypen
operieren kann, nennt man eine polymorphe Funktion.  Wenn der
Polymorphismus √ºber Typklassen hergestellt wird, spricht man
von Typklassenpolymorphismus.  *Generisch*, *parametrisch* und
*polymorph* sind hier eng verwandte Begriffe.  Wenn es um Datentypen
geht, spricht man von generischen oder parametrischen Datentypen.
Bei Funktionen spricht man von generischen oder polymorphen
Funktionen.

Den Code f√ºr die `Eq` Typklasse im Purescript Prelude k√∂nnen wir
hier nachlesen:

https://github.com/purescript/purescript-prelude/blob/v6.0.1/src/Data/Eq.purs#L35-L36

Er stimmt mit der oben angegebenen Definition √ºberein.  Direkt
darunter befindet sich die Definition f√ºr den Gleichheitsoperator:

    infix 4 eq as ==

Die Zeile legt fest, dass der Infix-Operator `==` ein Alias f√ºr
die Funktion `eq` ist und in der Operatorrangfolge an vierter
Stelle steht.  Wenn `==` ein Alias f√ºr `eq` ist und `eq` eine
Funktion der Typklasse `Eq` ist, dann muss ein Datentyp die Klasse
`Eq` implementieren, damit der Operator `==` f√ºr seine Werte
verf√ºgbar ist.  Probieren wir das aus:

    -- Purescript Repl
    
    > 123 == 123
    true
    
    > 123 == 124
    false
    
    > "abc" == "abc"
    true

    > "abc" == "bcd"
    false

    > false == false
    true

    > false == true
    false

Demnach implementieren die Datentypen `Int`, `String` und `Boolean`
die Typklasse `Eq`.  Unser selbst definierter Datentyp `Bool`
implementiert `Eq` noch nicht:

    -- Purescript Repl

    > data Bool = False | True

    > False == False
    ...
    No type class instance was found for

      Data.Eq.Eq Bool
    ...

Das k√∂nnen wir aber mit einer Instanzdeklaration nachholen.
Mit einer Instanzdeklaration f√ºgt man einen Datentyp zu einer
Typklasse hinzu.  Anschlie√üend kann man die Funktionen und
Operatoren der Typklasse auf Werte von diesem Datentyp anwenden:

    -- Purescript
    
    instance Eq Bool where
        eq a b = case [a,b] of
            [False,False] -> true
            [True,True] -> true
            _ ->false

    -- Purescript Repl
    
    > False == False
    true

Damit ist gekl√§rt, was Typklassen sind: ein Formalismus um
polymorphe Funktionen zu beschreiben.  Oft h√§ngt an den Funktionen
einer Typklasse eine bestimmte Erwartungshaltung hinsichtlich ihrer
Semantik, die vom Typsystem nicht erfasst wird.  Beispielsweise
h√§tten wir `eq` auch so angeben k√∂nnen:

    -- Purescript
    
    eq a b = case [a,b] of
        [False,False] -> False
        [True,True] -> False
        _ ->True

Damit w√ºrde `eq` nicht mehr auf Gleichheit pr√ºfen sondern
auf Ungleichheit.  Der Compiler w√ºrde die Definition trotzdem
akzeptieren, weil der Datentyp passt.  Aber der Gleichheitsoperator
`==` w√ºrde sich f√ºr diesen Datentyp anders verhalten als erwartet
und damit f√ºr reichlich Verwirrung sorgen.

Man kann zwischen Typklassen auch Abh√§ngigkeiten definieren:

    -- Purescript
    class (A T, B T, C T) <= D T ...

Das bedeutet, dass ein Datentyp `T` nur dann zur Typklasse `D`
geh√∂ren kann, wenn er auch zu den Typklassen `A`, `B` und `C`
geh√∂rt.  In Haskell sind solche Abh√§ngigkeiten auch m√∂glich.
Die Syntax ist fast identisch.  Nur der Doppelpfeil wird in Haskell
umgekehrt notiert: `=>`.  Wenn links vom Pfeil nur eine Typklasse
steht, k√∂nnen die Klammern entfallen.

Elm unterst√ºtzt keine Typklassen.  In Haskell und Purescript sind
zum Beispiel die arithmetischen Operatoren auf den verschiedenen
numerischen Datentypen √ºber Typklassen implementiert:

    -- Purescript Repl

    > :type (+)
    forall (a :: Type). Semiring a => a -> a -> a

    > :type (-)
    forall (a :: Type). Ring a => a -> a -> a

    > :type (*)
    forall (a :: Type). Semiring a => a -> a -> a

    > :type (/)
    forall (a :: Type). EuclideanRing a => a -> a -> a

Demnach ist der Operator `+` in Purescript auf den Datentypen
gegeben, die zur Typklasse `Semiring` geh√∂ren, der Operator
`-` auf den Datentypen, die zur Typklasse `Ring` geh√∂ren, usw.
Sowohl Haskell als auch Purescript haben eine mathematisch
interessante Typklassenhierarchie, aber wenn man sich f√ºr
Begriffe wie *Halbring*, *Ring* und *euklidischer Ring* nicht
interessiert, kann man sie ignorieren: sich mit diesen Begriffen
herumzuschlagen, ist **keine** Voraussetzung daf√ºr, in diesen
Sprachen zu programmieren!!!

Typische Idiome der funktionalen Programmierung, wie `map`, `foldr`,
`foldl`, `traverse`, oder der monadische *bind* Operator `>>=` sind
ebenfalls √ºber entsprechende Typklassen als polymorphe Funktionen
definiert.  Hier operiert `map` auf zwei verschiedenen Datentypen:

    -- Purescript Repl

    > map (_*2) [1,2,3]
    [2,4,6]

    > import Data.Maybe

    > map (_*2) (Just 3)
    (Just 6)

Es kommt selten vor, dass ich eigene Typklassen schreibe, weil es
mir produktiver erscheint, konkreten Code zu schreiben und dabei
nicht dar√ºber nachzudenken, wo sich strukturelle √úbereinstimmungen
verbergen k√∂nnten, aus denen sich vielleicht polymorphe Funktionen
ableiten lassen.  Probleme, bei denen ich Typklassen vielleicht
einsetzen w√ºrde, sind Serialisierung und Persistenz.  Beispielsweise
k√∂nnte die Serialisierung und Deserialisierung zwischen einem
Datentyp `a` und Json √ºber zwei polymorphe Funktionen ablaufen:

    -- Purescript
    class JsonSerializable a where
        toJson :: a -> String
        fromJson :: String -> Maybe a

Dazu w√ºrde ich noch fordern, dass f√ºr alle Instanzdeklarationen
gelten sollte:

    fromJson ( toJson value ) == Just value
    map toJson ( fromJson string ) == Just string

Diese Regeln kann man zwar nicht vom Compiler absichern lassen,
aber eine `JsonSerializable` Instanz, die sie nicht einh√§lt,
ist offensichtlich unbrauchbar.

Eine Typklasse f√ºr die Persistenz in einer Datenbank k√∂nnte
so aussehen:

    -- Haskell
    class Db a where
        insert :: a -> IO String
        update :: String -> a -> IO ()
        read :: String -> IO ( Maybe a )

Ich muss unbedingt dazusagen, dass ich mir dar√ºber maximal drei
Minuten Gedanken gemacht habe.  Es ist sehr wahrscheinlich, dass
ich hier irgendetwas entscheidendes vergessen oder √ºbersehen habe.
Als Beispiel sollte uns das an dieser Stelle trotzdem gen√ºgen.
Ich beschreibe kurz die Funktionen:

- `insert` persistiert einen Wert vom Datentyp `a` als neuen Record
  in der Datenbank und liefert einen String, den wir sp√§ter als
  Schl√ºssel verwenden k√∂nnen, um diesen Wert zu aktualisieren
  oder wieder auszulesen.
- `update` nimmt einen String als Schl√ºssel entgegen und
  aktualisiert den entsprechenden Record in der Datenbank mit einem
  Wert vom Datentyp `a`.
- `read` nimmt einen Schl√ºssel entgegen und liefert den
  entsprechenden Wert vom Datentyp `a` aus der Datenbank.  Weil wir
  nicht garantieren k√∂nnen, dass jeder Schl√ºssel auf einen
  g√ºltigen Record in der Datenbank verweist, ist dieser Wert in
  einen `Maybe` Kontext eingeschlossen.

Ich h√§tte wirklich Lust, herauszufinden, ob das ein gutes Design
oder zu naiv ist, aber erst muss ich diesen Text fertig schreiben.

Im n√§chsten Abschnitt gehe ich auf Multiparameter-Typklassen ein.
Vorher m√∂chte ich noch eine Bemerkung zu Typklassen im Allgemeinen
loswerden: Typklassenpolymorphie ist ein produktives Konzept,
aber es lohnt sich nicht immer, auf Typklassen und polymorphe
Funktionen zu setzen.  Wenn die Polymorphie einem formalen Kalk√ºl
folgt, so wie es bei der Typklasse `Eq` und bei den arithmetischen
Operationen der Fall ist, oder wenn es darum geht, Datentypen um
Funktionalit√§t zu erweitern wie bei der Typklasse `JsonSerialize`,
dann sind Typklassen sinnvoll.  Aber man sollte nicht versuchen,
Typklassenpolymorphie zu erzwingen: manchmal ist der Code besser
ohne Typklassen.  Elm kommt ganz ohne Typklassen aus.


## Multiparameter-Typklassen

*Eine Vorbemerkung: Man muss bei den Programmierkonzepten der
Typebene, die ich hier vorstelle, ein bisschen darauf achten, dass
man den Ball flach h√§lt.  Wenn man mit einem vordefinierten Datentyp
gut auskommt, muss man daf√ºr keinen ADT definieren.  Wenn es keinen
Grund daf√ºr gibt, einen parametrischen ADT zu definieren, sollte
man es bei einem parameterlosen ADT belassen.  Wenn man sich nicht
ganz sicher ist, ob man eine polymorphe oder mehrere monomorphe
Funktionen definieren sollte, ist es besser, auf Polymorphie zu
verzichten.  Dieser Appell gilt umso mehr f√ºr die Konzepte, die
jetzt folgen.  Mit einem guten Verst√§ndnis f√ºr ADTs, parametrische
ADTs und einfache Typklassen ist man schon sehr gut aufgestellt.
Solange man diese Konzepte nicht richtig verinnerlicht hat, muss
man sich mit den Konzepten, die jetzt noch folgen, nicht befassen.*

Typklassen k√∂nnen mehr als einen Typparameter haben.  Auf die Weise
k√∂nnen die polymorphen Funktionen einer Typklasse Beziehungen
zwischen Datentypen beschreiben.  Die Typklasse `Db` von gerade
eben bietet sich an, um zu zeigen, wof√ºr das n√ºtzlich sein kann.
Mich st√∂rt an dieser Typklasse ein bisschen, dass der Datentyp f√ºr
die Schl√ºssel auf `String` festgelegt ist.  Warum nicht `Int`? Oder
ein spezieller Datentyp `Uuid` f√ºr sogenannte *Universally Unique
Identifiers*?  Also erweitern wir diese einfache Typklasse zu einer
Typklasse mit zwei Typparametern:

    -- Haskell
    class Db key value where
        insert :: value -> IO key
        update :: key -> value -> IO ()
        read :: key -> IO ( Maybe value )

Auf diese Weise sind wir f√ºr die Schl√ºssel nicht auf den Datentyp
`String` festgelegt, sondern k√∂nnen daf√ºr einen Datentyp frei
w√§hlen.  Hier noch ein Beispiel f√ºr eine Multiparameter-Typklasse
aus dem Purescript-Buch:

    -- Purescript
    class Stream stream element where
        uncons :: stream -> Maybe { head :: element , tail :: stream }

Die Idee dabei ist, dass ein Wert vom Datentyp `stream` ein
Datenstrom aus Werten vom Datentyp `element` ist.  Die Funktion
`uncons` trennt diesen Datenstrom auf in den ersten Wert (`head`)
und den Rest des Datenstroms (`tail`).  Auf die Weise lassen sich die
Werte in einem Datenstrom durch wiederholtes Aufrufen von `uncons`
der Reihe nach verarbeiten.  Sobald der Datenstrom leer ist, liefert
`uncons` den Wert `Nothing`.  Wir f√ºgen die Datentypen `String`
und `Char` zur Typklasse `Stream` hinzu, indem wir eine passende
`uncons` Funktion angeben:

    -- Purescript
    instance Stream String Char where
        uncons = String.uncons

Dass die Funktion `String.uncons` hier genau passt, ist g√ºnstig
f√ºr uns.  Als n√§chstes f√ºgen wir den generischen Datentyp `Array
a` zusammen mit dem entsprechenden Datentyp `a` zur Typklasse
`Stream` hinzu.  Auch hier gibt es wieder eine passende `uncons`
Funktion f√ºr Arrays:

    -- Purescript
    instance Stream ( Array a ) a where
        uncons = Array.uncons

Jetzt k√∂nnen wir mit der polymorphen `uncons` Funktion der `Stream`
Typklasse sowohl `Char` Werte aus `String` Datenstr√∂men als auch
`a` Werte aus `Array a` Datenstr√∂men entnehmen.


## Funktionale Abh√§ngigkeiten

Es w√§re jetzt naheliegend, aus `uncons` eine `tail` Funktion
abzuleiten:

    -- Purescript
    tail :: String -> Maybe String
    tail stream = map _.tail ( uncons stream )

Wir wenden erst `uncons` auf das Argument an.  Dann wenden
wir die Feldfunktion `_.tail` auf das Zwischenergebnis an.
Das Zwischenergebnis ist in einen `Maybe` Kontext eingebettet.
Deswegen m√ºssen wir `map` einsetzen, um die Feldfunktion auf den
Wert im Kontext anzuwenden.  Das ist eine sinnvolle Definition.
Trotzdem ist der Compiler nicht mit ihr zufrieden:

    No type class instance was found for Main.Stream String t

Was funktioniert hier nicht?  Daf√ºr m√ºssen wir (ganz grob)
verstehen, wie der Compiler mit polymorphen Funktionen umgeht.  Die
beiden Instanzdeklarationen haben wir nicht ohne Grund hinzugef√ºgt.
Wenn wir die polymorphe Funktion `uncons` aufrufen, versucht der
Compiler, die passenden Datentypen zu ermitteln, um pr√ºfen zu
k√∂nnen, ob ihm f√ºr diese Datentypen eine Instanzdeklaration
bekannt ist.  Wir wollen hier nat√ºrlich auf die Instanz `Stream
String Char` hinaus.  Ein Blick in obige Fehlermeldung verr√§t,
dass die Typinferenz bei `Stream String t` h√§ngen bleibt.
Der Compiler ist offenbar nicht in der Lage, f√ºr den Typparameter
`t` zu inferieren, dass es sich um den Datentyp `Char` handeln muss.
Ich wei√ü nicht, wo genau es klemmt, aber es stimmt, dass wir bei der
Definition unserer neuen `tail` Funktion dem Compiler nirgendwo einen
Hinweis darauf geben, dass es sich bei `t` um `Char` handeln muss.

Wenn wir das polymorphe `uncons` durch `String.uncons` ersetzen,
ist der Compiler zufrieden, aber dann k√∂nnen wir uns die Typklasse
gleich sparen.  Wenn wir `uncons` um eine Typannotation erg√§nzen,
die ausdr√ºcklich auf `Char` hinweist, ist der Compiler ebenfalls
zufrieden:

    -- Purescript
    tail :: String -> Maybe String
    tail stream = do
        let f :: String -> Maybe { head :: Char , tail :: _ }
            f = uncons
        map _.tail ( f stream )

Aber sch√∂n oder sinnvoll ist das auch nicht.  Welchen Wert hat
die Typklassenpolymorphie, wenn wir sie erst einf√ºhren und sie
dann zur H√§lfte wieder zur√ºcknehmen?

Interessanterweise k√∂nnen wir den Compiler auch zufriedenstellen,
indem wir die Definition der Typklasse `Stream` wie folgt anpassen:

    -- Purescript
    class Stream stream element | stream -> element where
        uncons :: stream -> Maybe { head :: element , tail :: stream }

Hinzugekommen ist der Teil `| stream -> element` vor dem `where`
Schl√ºsselwort.  Man nennt das eine *funktionale Abh√§ngigkeit*.
Wir vereinbaren dadurch mit dem Compiler, dass sich aus dem Datentyp
f√ºr den Typparameter `stream` stets eindeutig ergeben muss,
welcher Datentyp f√ºr den Typparameter `element` einzusetzen ist.
Das hat bei mir zun√§chst f√ºr Kopfkratzen gesorgt.  Dann ist mir
aufgefallen, dass wir nur eine einzige Instanzdeklaration der Form
`Stream String ...` angegeben haben, n√§mlich `Stream String Char`.
Damit ist die funktionale Abh√§ngigkeit stets erf√ºllt wenn wir f√ºr
`stream` den Datentyp `String` einsetzen: f√ºr `element` kommt dann
nur der Datentyp `Char` in Frage.  Die andere Instanzdeklaration
`Stream ( Array a ) a` erf√ºllt ebenfalls die Forderung nach
funktionaler Abh√§ngigkeit, denn wenn `Array a` (und damit `stream`)
auf einen konkreten Datentyp festgelegt ist, dann ist auch `a`
selbst (und damit `element`) eindeutig auf einen Datentyp festgelegt.
Der Compiler ist damit zufriedengestellt solange wir keine weiteren
Instanzdeklarationen hinzuf√ºgen, die diese Eindeutigkeit verletzen.


## Verallgemeinerte algebraische Datentypen (GADTs)

Weiter oben haben wir schon eine Verallgemeinerung der einfachen ADTs
kenngenlernt: die parametrischen ADTs.  Verallgemeinerung bedeutet,
dass das Verallgemeinerte zum Spezialfall des Verallgemeinernden
wird.  Bei den parametrischen ADTs besteht der Spezialfall
eines einfachen, parameterlosen ADT darin, dass die Anzahl seiner
Typparameter 0 ist: jeder parameterlose ADT ist ein parametrischer
ADT mit 0 Typparametern!

Die Sprache wird bei solchen Dingen oft etwas ungenau.  Wenn wir
von einem parametrischen ADT sprechen, meinen wir nat√ºrlich
einen ADT mit mindestens einem Typparameter, sonst m√ºssten wir
den allgemeineren Begriff nicht bem√ºhen.  Aber wenn jemand √ºber
einen ADT sagt: *"das ist kein parametrischer sondern ein einfacher
ADT"*, dann ist das genaugenommen ein Widerspruch und damit falsch.
Im Gespr√§ch sollte man das nicht zum Anlass nehmen, gleich mit dem
Belehrfinger zu fuchteln, aber man sollte im Hinterkopf behalten,
dass genaugenommen der konkretere Begriff in dem allgemeineren
Begriff enthalten ist.

GADTs (*generalized algebraic data types*) sind wiederum eine
Verallgemeinerung der parametrischen ADTs.  Also ist jeder
parameterlose und jeder parametrische ADT stets auch ein GADT.
Aber auch √ºber ADTs und GADTs wird h√§ufig so gesprochen als
seien es disjunkte Konzepte.  Zum Beispiel enth√§lt der englische
Wikipedia-Artikel √ºber GADTs in seiner aktuellen Form (2023-06)
den folgenden Code-Kommentar:

    -- A parametric ADT that is not a GADT

Im Haskell-Wiki und in der GHC-Dokumentation gibt es √§hnliche
Formulierungen.  Das ist nicht schlimm, aber auch hier sollten
wir im Hinterkopf behalten, dass formal der konkretere Begriff im
allgemeineren Begriff enthalten ist.


**Neue Syntax**

GADTs bringen in Haskell neben der Verallgemeinerung auch eine
eigene Syntax mit.  Ich m√∂chte zun√§chst herk√∂mmliche ADTs in
dieser GADT-Syntax aufschreiben.  Dann schauen wir uns an, worin
genau die Verallgemeinerung besteht.  Hier noch mal `Bool` in der
herk√∂mmlichen ADT-Syntax:

    -- Haskell
    data Bool
        = False
        | True

So w√ºrde man `Bool` in der GADT-Syntax schreiben:

    -- Haskell
    data Bool where
        False :: Bool
        True :: Bool

Der `Ampel` Datentyp in herk√∂mmlicher ADT-Syntax:

    -- Haskell
    data Ampel
        = Gr√ºn
        | Gelb
        | Rot

Der `Ampel` Datentyp in GADT-Syntax:

    -- Ampel in GADT-Syntax
    data Ampel where
        Gr√ºn :: Ampel
        Gelb :: Ampel
        Rot :: Ampel

Herk√∂mmliche ADTs in GADT-Syntax aufzuschreiben, ist kein
Gedankenexperiment: die Beispiele sind g√ºltiger Haskell Code und
k√∂nnen genau so verwendet werden.  Bei der GADT-Syntax f√§llt gleich
auf, dass die Wertekonstruktoren mit Typannotationen versehen sind.
Bei parameterlosen ADTs in GADT-Syntax sind diese Typannotationen
√ºberfl√ºssig: selbstverst√§ndlich haben hier alle Wertekonstruktoren
den selben Datentyp.  Schauen wir uns als n√§chstes ein paar echte
parametrische ADTs in GADT-Syntax an.  Hier noch mal `Maybe a`
in der herk√∂mmlichen Syntax:

    -- Haskell
    data Maybe a
        = Nothing
        | Just a

Zum Vergleich, `Maybe a` in GADT-Syntax:

    -- Haskell
    data Maybe a where
        Nothing :: Maybe a
        Just :: a -> Maybe a

Der Wertekonstrukor `Just` ist interessant.  Er hat den Datentyp
`a -> Maybe a`.  Das ist immer der Fall, auch wenn wir den Datentyp
in der herk√∂mmlichen ADT-Syntax aufschreiben, aber hier schreiben
wir den Datentyp explizit hin.  Hier noch mal der Datentyp `List`,
diesmal in Haskell:

    -- Haskell
    List a
        = Nil
        | Cons a ( List a )

In GADT-Syntax:

    -- Haskell
    List a where
        Nil :: List a
        Cons :: a -> List a -> List a

Die neue Syntax f√ºr GADTs ist ein Wink mit dem Zaunspfahl bzgl. der
Verallgemeinerung, um die es geht.  Bei einem herk√∂mmlichen
parametrischen ADT kann jeder Typparameter stets nur f√ºr alle
Wertekontruktoren gemeinsam auf einen Datentyp festgelegt werden.
Bei einem GADT kann jeder  Typparameter f√ºr verschiedene
Wertekonstruktoren auf verschiedene Datentypen festgelegt werden.
Hier ein GADT mit drei Wertekonstruktoren:

    -- Haskell
    data MyGadt a where
        MyInt :: Int -> MyGadt Int
        MyBool :: Bool -> MyGadt Bool
        MyString :: String -> MyGadt String

Das besondere an einem GADT wie diesem ist, dass die
Wertekonstruktoren den Datentyp jeweils unterschiedlich
konkretisieren: der Wertekonstruktor `MyInt` erzeugt immer
einen `MyGadt Int`, der Wertekonstruktor `MyBool` erzeugt
immer einen `MyGadt Bool` und der Wertekonstruktor `MyString`
erzeugt immer einen `MyGadt String`.  Aber `MyGadt` hat nur diese
drei Wertekonstruktoren.  Daraus ergibt sich ein entscheidender
Sachverhalt: der Typparameter `a` kann hier konstruktionsbedingt
nur die Datentypen `Int`, `Bool` oder `MyString` annehmen.

Bei einem GADT k√∂nnen wir die Typparameter durch seine
Wertekonstruktoren so einschr√§nken, dass konstruktionsbedingt
nur noch ganz bestimme Datentypen auf die Typparameter passen.
Mehr noch: wir k√∂nnen die Wertekonstruktoren so entwerfen, dass
sie Beziehungen zwischen den verschiedenen Konkretisierungen eines
generischen Datentyps beschreiben.  Es ist ein bisschen so als
w√ºrden wir mit einem GADT nicht nur einen Datentyp beschreiben,
sondern eine ganze Gruppe von Datentypen und ihre Beziehungen
zueinander.  Wer schon mal eine kleine formale Sprache entworfen
und in eine Reihe von Datentypen gegossen hat oder einen Parser
f√ºr eine formale Sprache geschrieben hat, m√ºsste hier hellh√∂rig
werden.  Tats√§chlich eignen sich GADTs sehr gut daf√ºr, DSLs oder
ganze Programmiersprachen zu beschreiben.  Grunds√§tzlich geht
das auch mit herk√∂mmlichen ADTs, aber mit GADTs lassen sich
solche Beschreibungen kompakter formulieren und mehr Invarianten
auf der Typebene festhalten.  Als Beispiel daf√ºr schauen wir uns
die kleine arithmetische Sprache an, die der Wikipedia-Artikel zu
GADTs enth√§lt:

    -- Haskell
    data Expr a where
        EInt :: Int -> Expr Int
        EBool :: Bool -> Expr Bool
        EEqual :: Expr Int -> Expr Int -> Expr Bool

Der Wertekonsturktor `EInt` erzeugt immer einen `Expr Int` Wert.
Die Wertekonstruktoren `EBool` und `EEqual` erzeugen immer einen
`Expr Bool` Wert.  Deswegen kann der Typparameter `a` hier nur die
Typen `Int` und `Bool` annehmen.  Dazu geh√∂rt noch die `eval`
Funktion, die einen `Expr a` Ausdruck in einen Wert vom Typ `a`
√ºberf√ºhrt:

    -- Haskell
    eval :: Expr a -> a
    eval expr = case expr of
        EInt n -> n
        EBool b -> b
        EEqual a b -> eval a == eval b

Damit sollte das folgende Programm `False` ausgeben:

    -- Haskell
    main = do
        let v1 = EInt 123
        let v2 = EInt 124
        let result = EEqual v1 v2
        putStrLn ( show ( eval result ) )

Eine Sache, die mich ein bisschen daran st√∂rt, ist dass wir
`EEqual` nicht auf `Expr Bool` Werte anwenden k√∂nnen.  Das ist
aber leicht behoben:

    -- Haskell

    data Expr a where
        EInt :: Int -> Expr Int
        EBool :: Bool -> Expr Bool
        EEqual :: Eq a => Expr a -> Expr a -> Expr Bool

    eval :: Expr a -> a
    eval expr = case expr of
        EInt n -> n
        EBool b -> b
        EEqual a b -> eval a == eval b

Damit sollte auch das folgende Programm compilieren und `False`
ausgeben:

    -- Haskell
    main = do
        let v1 = EBool False
        let v2 = EBool True
        let result = EEqual v1 v2
        putStrLn ( show ( eval result ) )

Wie w√ºrde man das ohne GADTs modellieren?  Keine Ahnung!  Aber wir
k√∂nnen uns anschauen, was √ºbrigbleibt, wenn wir `Expr` auf einen
parametrischen ADT reduzieren:

    -- Haskell
    data Expr a
        = EInt Int
        | EBool Bool
        | EEqual ( Expr a ) ( Expr a )

Wenn wir den so angepassten Datentyp in der GADT-Syntax aufschreiben,
sehen wir besser, was sich ge√§ndert hat:

    -- Haskell
    data Expr a where
        EInt :: Int -> Expr a
        EBool :: Bool -> Expr a
        EEqual :: Expr a -> Expr a -> Expr a

Der Datentyp ist so v√∂llig unbrauchbar.  Es gibt jetzt keine
Beziehung mehr zwischen dem Typparameter `a` und den Feldtypen von
`EInt` und `EBool`:

    -- Haskell

    v1 :: Expr Int
    v1 = EBool True

    v2 :: Expr String
    v2 = EInt 123

Der Wertekonstruktor `EEqual` ist so auch unbrauchbar.  Wenn `EEqual`
einen `Expr Bool` Wert erzeugen soll, muss er auch auf zwei `Expr
Bool` Werten operieren.  Schauen wir uns trotzdem an, wie weit wir
bei der `eval` Funktion kommen:

    -- Haskell
    eval :: Expr a -> a
    eval expr = case expr of
        EInt n -> undefined
        EBool b -> undefined
        EEqual e1 e2 -> undefined

Was sollen wir z.B. f√ºr `EInt n` berechnen?  Der Wert `n` hat
hier den Datentyp `Int`, aber `eval` operiert auf einem `Expr a`
Wert und erzeugt einen `a` Wert.  Wir br√§uchten eine Funktion
`Int -> a` f√ºr beliebige Datentypen `a`.  Das w√§re zwar rein
formal m√∂glich (also typisierbar) aber wie sollen wir f√ºr jeden
m√∂glichen Datentyp ad hoc und aus dem Nichts einen Wert herzaubern?
Die gleiche Frage stellt sich f√ºr `EBool b`.  Bei `EEqual e1 e2` ist
das Problem noch gravierender, weil wir nur dann zu einem `Bool` Wert
auswerten k√∂nnen, wenn `e1` und `e2` vom Datentyp `Expr Bool` sind.
Die ganze Konstruktion ist also v√∂llig unbrauchbar.

Wenn wir `Expr` in einen parameterlosen ADT umbauen, kommt z.B. das
heraus:

    -- Haskell
    data Expr
        = EInt Int
        | EBool Bool
        | EEqual Expr Expr

Das erscheint mir auf den ersten Blick schon sinnvoller.  Schauen wir
uns an, wie `eval` aussehen k√∂nnte:

    -- Haskell
    eval :: Expr -> a
    eval expr = case expr of
        EInt n -> undefined
        EBool b -> undefined
        EEqual e1 e2 -> case ( e1 , e2 ) of
            ( EInt n1 , EInt n2 ) -> undefined
            ( EBool b1 , EBool b2 ) -> undefined
            _ -> undefined

Das ist wieder eine Sackgasse.  Wir k√∂nnen `eval` zwar von `Expr
-> a` konkretisieren auf `Expr -> Bool` oder auf `Expr -> Int`,
aber das findet immer f√ºr die gesamte Funktion inklusive aller
Case-Zweige statt.  Wir k√∂nnen nicht in einem Case-Zweig nach
`Bool` und im n√§chsten nach `Int` auswerten.  √úberhaupt m√ºssen
wir ja nach `a` auswerten, auch wenn f√ºr `a` weder `Bool` noch
`Int` eingesetzt worden ist.  Wenn wir f√ºr `a` einen konketen
Wert einsetzen, wird die Sache einfacher.  F√ºr einige Anwendungen
gen√ºgt sicherlich eine Funktion `eval :: Expr -> String`:

    -- Haskell
    eval :: Expr -> String
    eval expr = case expr of
        EInt n -> show n
        EBool b -> show b
        EEqual e1 e2 -> case ( e1 , e2 ) of
            ( EInt n1 , EInt n2 ) -> show ( n1 == n2 )
            ( EBool b1 , EBool b2 ) -> show ( b1 == b2 )
            _ -> show False

Andernfalls sehe ich nicht, wie man hier ohne GADTs auskommen
k√∂nnte.  Ich hoffe, ich konnte demonstrieren, was man mit GADTs
anstellen kann.  F√ºr mich ist das Konzept noch relativ neu.


## Epilog

Dieser Text ist f√ºr mich in erster Linie eine Art Selbsttest:
kann ich mein Verst√§ndnis der Konzepte, die ich hier vorstelle,
ausformulieren und aufschreiben, so dass ich hinterher damit
zufrieden bin, auch wenn ich den Text zwischenzeitlich f√ºr ein
paar Wochen beiseite gelegt habe?  Wenn nicht, werde ich weiter
daran arbeiten (sofern ich Zeit und Lust dazu habe).  Mein Bezug zu
diesem Thema ist ein praktischer.  Bisher bin ich noch nicht dazu
gekommen, mich ernsthaft mit B√ºchern √ºber Typentheorie zu befassen.
Insofern hoffe ich, dass sich hier kein Bl√∂dsinn eingeschlichen hat.
Das w√§re mir wirklich peinlich.  Wenn der Text noch jemandem au√üer
mir selbst nutzt, freut mich das umso mehr.
