[{"id":0,"href":"/docs/weblog/2023-02-17/","title":"Negation in Haskell Und Purescript","section":"Docs","content":"2023-02-17\nNegation in Haskell und Purescript # Haskell fetzt! Allerdings ist Haskell in seiner Nische (rein funktionale ML-Sprachen) längst nicht mehr allein. Die moderneren Abkömmlinge dieser Familie bringen hier und da interessante Verbesserungen mit. Ein schönes Beispiel dafür ist die not Funktion in Purescript.\nWerte negieren # In Haskell negiert not den Wert eines boolschen Ausdrucks:\n-- Haskell GHCi Session ​ \u0026gt; not True False ​ \u0026gt; not False True In Purescript gilt das gleiche:\n-- Purescript PSCi Session ​ \u0026gt; not true false ​ \u0026gt; not false true Das ist nicht weiter kompliziert.\nFunktionen negieren # Grundsätzlich müssten sich auf die gleiche Weise auch Funktionen negieren lassen, die nach Bool abbilden. Für eine Funktion f :: a -\u0026gt; Bool wäre not f dann ebenfalls eine Funktion a -\u0026gt; Bool, so dass ( not f ) x \u0026hellip;\nzu True auswertet wenn f x zu False auswertet, bzw. zu False auswertet wenn f x zu True auswertet. Haskells not kann das nicht leisten. Um das zu demonstrieren, definieren wir eine even Funktion, die entscheidet, ob eine ganze Zahl gerade ist:\n-- Haskell GHCi Session ​ \u0026gt; even n = modBy 2 n == 0 \u0026gt; even 0 True ​ \u0026gt; even 1 False ​ \u0026gt; even 2 True ​ \u0026gt; even 3 False Anmerkung: Mein Haskell ist nicht ganz idiomatisch. modBy ist selbstdefiniert.\nWir müssten also eine odd Funktion definieren können, die entscheidet, ob eine ganze Zahl ungerade ist, indem wir even mit not negieren. Wenn wir versuchen, das in Haskell umzusetzen, scheitern wir:\n-- Haskell GHCi Session ​ \u0026gt; odd = not even \u0026lt;interactive\u0026gt;: error: • Couldn\u0026#39;t match expected type ‘Bool’ with actual type ‘a0 -\u0026gt; Bool’ • ... In Purescript ist das gar kein Problem. Hier ist die even Funktion in Purescript:\n-- Purescript PSCi Session ​ \u0026gt; even n = mod n 2 == 0 ​ \u0026gt; even 0 true ​ \u0026gt; even 1 false ​ \u0026gt; even 2 true ​ \u0026gt; even 3 false Wenn wir even mit not negieren, erhalten wir ohne Probleme unsere odd Funktion:\n-- Purescript GHCi Session ​ \u0026gt; odd = not even ​ \u0026gt; odd 0 false ​ \u0026gt; odd 1 true ​ \u0026gt; odd 2 false ​ \u0026gt; odd 3 true Wie ist das umgesetzt? # In Haskell ist not eine Funktion Bool -\u0026gt; Bool. In Purescript ist not eine Funktion HeytingAlgebra a =\u0026gt; a -\u0026gt; a. Die Heyting-Algebra ist offenbar eine Verallgemeinerung der booleschen Algebra. Auf den ersten Blick spricht nichts dagegen, not auf die gleiche Weise auch in Haskell zu verallgemeinern. Vielleicht nehme ich das mal in Angriff und versuche not in meinem DIY Prelude entsprechend anzupassen.\nBonus # Dann ist mir noch ein schönes Beispiel dafür eingefallen, dass man manchmal in der Lage ist, zu erkennen, zu welchem Wert ein Ausdruck auswerten müsste, obwohl der Compiler auf dem Schlauch steht:\nfoldr (+) 0 ( repeat 0 ) Der Ausdruck terminiert weder in Haskell noch in Purescript, weil repeat eine unendliche Sequenz erzeugt. Anschaulich ist völlig klar, dass er zu 0 auswerten müsste, denn wir summieren einfach nur Nullen auf. Formal lässt sich das auch leicht rechtfertigen: wenn wir eine unendliche Summe über einem Monoid bilden, wobei alle Summanden das neutrale Element sind, dann ergibt die Summe schon per Definition ebenfalls das neutrale Element.\nEs gibt weitere Beispiele dieser Art. Der folgende Ausdruck terminiert auch nicht, müsste aber zum leeren String \u0026quot;\u0026quot; auswerten. Anschaulich ist das auch wieder völlig klar. Formal gilt das gleiche wie oben.\nfoldr (++) \u0026#34;\u0026#34; ( repeat \u0026#34;\u0026#34; ) Hinweis: (++) ist hier ein Alias für (\u0026lt;\u0026gt;).\nDer folgende Ausdruck terminiert auch nicht, müsste aber in Haskell zur leeren Liste [] auswerten.\nfoldr (++) [] ( repeat [] ) Spannend ist die Frage, wie man das umsetzen könnte. Alle Beispiele haben die Form:\nfoldr mappend mempty ( repeat mempty ) Wenn die Faltung in der Lage wäre, diese Form zu erkennen, könnte sie in diesem Fall zu mempty auswerten.\n"},{"id":1,"href":"/docs/weblog/2023-01-18/","title":"Closures","section":"Docs","content":"2023-01-18\nClosures # Ich spiele gerade ein bisschen mit Go herum, weil ich mich aus meiner funktionalen Ecke heraustrauen und etwas mehr mit imperativen, C-artigen Sprachen befassen möchte. Rust hätte mich auch interessiert, scheint aber ein Fass ohne Boden zu sein. Go ist modern, trotzdem stabil, recht kompakt und weitverbreitet. Die Liste der großen und populären Softwareprojekte, die auf Go setzen, ist beachtlich.\nIn der Go-Tour gibt es einen Abschnitt zu Closures. Ich nutze die Gelegenheit, um für mich zu klären was Closures sind. Ich hab den Begriff bisher nie wirklich verstanden.\nEine Closure (i.e. ein Funktionsabschluss) ist eine Funkion, die Referenzen auf ihren Erstellungskontext enthält, wobei dieser Kontext außerhalb der Funktion nicht mehr sichtbar und nicht mehr referenzierbar ist.\nEin Beisiel aus dem Haskell Wiki:\n\u0026gt; f x = \\ y -\u0026gt; x + y \u0026gt; g = f 3 \u0026gt; g 4 7 Wenn wir g definieren, wird der Wert 3 an den Parameter x gebunden, so dass g = \\ y -\u0026gt; 3 + y gilt. Auf den Kontext, in dem die Bindung x = 3 vorliegt, können wir aber nicht mehr zugreifen, obwohl er weiter existiert solange g existiert. Eine Closure liegt vor weil die Bindung x = 3 im Kontext des Lambda-Ausdrucks erfolgt aber innerhalb des Lambda-Ausdrucks verwendet wird. Dadurch lebt der Kontext über die Definition hinaus weiter, weil er für die Auswertung benötigt wird.\nIch verstehe das, aber was ich nicht verstehe ist, warum man dieser Sache einen gesonderten Namen gibt und sie als eine spezielle Programmiertechnik behandelt. Statt f x = \\ y -\u0026gt; x + y könnte man auch schreiben: f x y = x + y. Das ist die normalste Sache der Welt und ich verstehe überhaupt nicht, wie es anders sein könnte, also was es bedeuten soll, ohne Closures zu programmieren.\nBeim Schreiben kommt mir der Verdacht, dass es irgendwie damit zusammenhängen muss, dass Sprachen wie C keine First Class Functions haben. Wenn man es nicht gewohnt ist, kann das Herumreichen von Funktionen als Argumente und Rückgabewerte mit allen Möglichkeiten, die sich daraus ergeben, vielleicht wie ein besonderer Hokuspokus erscheinen, der erst mal in einen Begriff zu bringen ist: Closure — eine Funktion, die auf freien Variablen operiert.\nDas Gegenteil wäre ein Combinator — eine Funktion ohne freie Variable.\nUpdate\nOk, ich hab\u0026rsquo;s! Der eigentliche Effekt, an dem man offenbar bei der imperativen Programmierung mit Closures interessiert ist, tritt bei der rein funktionalen Programmierung gar nicht auf. Eine Closure ist in diesem Fall eine Prozedur mit einem inneren Zustand, der über mehrere Aufrufe hinweg fortbesteht und veränderbar ist. Hier ein angepasstes Beispiel aus der Go Tour:\nfunc adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { f := adder() fmt.Println(f(0)) // 0 fmt.Println(f(1)) // 1 fmt.Println(f(2)) // 3 fmt.Println(f(3)) // 6 fmt.Println(f(4)) // 10 fmt.Println(f(5)) // 15 } Was passiert hier? Die Prozedur f hat einen inneren Zustand, der mit sum := 0 initialisiert wird, bei jedem Aufruf von f verändert wird und nur indirekt über den Rückgabewert observierbar ist. Daraus könnte man ein Objektsystem stricken.\nNicht alle imperativen Sprachen unterstützen Closures. Wenn sie es nicht tun, wird f im obigen Beispiel zur Identitätsfunktion, weil f(n) stets zu 0 + n auswertet.\n"},{"id":2,"href":"/docs/weblog/2022-12-02/","title":"Trial Beim MC Post Leipzig","section":"Docs","content":"2022-12-02\nTrial Beim MC Post Leipzig # In meiner Jugend bin ich wettkampforientiert Fahrrad-Trial gefahren. Einige Jahre lang war dieser Sport gewissermaßen meine Raison d’être. Dann hat für mich das echte Leben begonnen: Abitur, Studium, Freundin, WG-Leben und eine chaotische Suche nach meinem Platz in dieser Welt. Jetzt ist es vielleicht achtzehn Jahre oder länger her, dass ich den Trial-Sport aufgegeben habe. Irgendwie war damals die Luft raus. Aber in den darauffolgenden Jahren habe ich etwas so körperlich intensives und viszeral sinnstiftendes wirklich sehr sehr vermisst in meinem Leben. Trial hat mir damals das gegeben, was Hartmut Rosa eine diagonale Resonanzbeziehung nennt.\nJetzt bin ich 38 Jahre alt und übergewichtig. Ich muss dringend mehr Sport machen, um meine zweite Lebenshälfte gesund über die Bühne zu bringen. Noch geht es mir gut, aber ich befürchte, dass ich in zehn Jahren endgültig ein dicker Stubenhocker sein werde, für den die sportlichen Highlights des Tages die Wege zum Kühlschrank, zum Briefkasten und zum Auto sind. Die Eitelkeit tritt für mich mit zunehmendem Alter als Triebfeder für den Wunsch nach körperlicher Fitness in den Hintergrund. Sie wird abgelöst von der Sorge um mein körperliches und geistiges Wohlbefinden.\nIm Frühling kam mir die Idee, Trial wieder auszupobieren und herauszufinden, ob das wieder Spaß macht und wieviel davon mein Körper noch erinnert. Ja, es macht einen Heidenspaß und zu meinem großen Erstaunen kann ich es noch.\nDie Bilder sind auf dem Trainingsgelände des MC Post Leipzig e.V. entstanden. Ich bin dort seit ein paar Wochen Mitglied und nutze jede Gelegenheit für ein Training. Nach fünf Minuten atme ich wie nach einem Sprint. Nach einer Stunde bin ich nassgeschwitzt und völlig erschöpft.\nDer Fotograf, der diese Aufnahmen geschossen hat, ist Jan Zwicker. Jan stand am Samstag früh um zehn (für einen anderen Anlass) mit seiner professionellen Fotoausrüstung auf dem Gelände und hat gefragt, ob er ein paar Fotos machen darf.\nhttps://wheels-and-vibes.com/\nIch wiege 25 kg mehr als damals. Das macht sich bemerkbar. Aber die grundsätzlichen Bewegungsabläufe und das Gefühl für das Fahrrad sind noch da. Es scheint zu stimmen: Fahrradfahren verlernt man nicht. Jetzt ist die große Frage, wie es für mich weitergeht. Bleibe ich beim Midlife-Cycling? Wird das dazu beitragen, dass ich wieder fit werde und mein Übergewicht loswerde? Oder mache ich mir damit auf Dauer nur die Knochen kaputt?\nDas Trainingsgelände des MC Post Leipzig ist das einzige seiner Art mitten in einer deutschen Großstadt. Es ist keinen ganzen Kilometer von meiner Wohnung entfernt und ich frage mich, warum ich nicht schon eher auf die Idee gekommen bin, dort mitzumachen. Im Moment bin ich der einzige Fahrrad-Trialer im Verein. Die anderen fahren Motorrad.\n"},{"id":3,"href":"/docs/weblog/2022-12-01/","title":"Nix Expression Language","section":"Docs","content":"2022-12-01\nNix Expression Language # Ich erkunde die Nix Expression Language. Mein Startpunkt ist https://learnxinyminutes.com/docs/nix/. Sehr hilfreich ist auch die Dokumentation, welche über die Nix Repl verfügbar ist.\nAuswertung # Die auszuwertenden Ausdrücke schreibe ich in eine Datei scratch.nix. Die Auswertung erfolgt so:\n$ nix-instantiate --eval scratch.nix Für mehr Komfort kann man inotifywait benutzen um die Auswertung jedesmal anzustoßen wenn die Datei scratch.nix gespeichert wird:\n$ while true inotifywait -q -e modify scratch.nix clear nix-instantiate --eval scratch.nix and echo \u0026#34;.\u0026#34; end Das ist eine Kommandozeile für die fish Shell. In sh usw. muss man das ein bisschen anders schreiben. Die fish Shell ist sehr komfortabel: man kann das einfach so mehrzeilig aufschreiben; die Shell weiß, wann die Eingabetaste die Zeile umbrechen soll und wann sie die Auswertung anstoßen soll.\nKurze Ausdrücke kann man auch direkt in der Nix Repl ausprobieren:\n$ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; \u0026#34;Das ist eine Zeichenkette\u0026#34; \u0026#34;Das ist eine Zeichenkette\u0026#34; nix-repl\u0026gt; 7 * 11 * 13 1001 Update: Am Ende habe ich die Methode mit der Scratch-Datei kaum verwendet und mich stattdessen fast ausschließlich auf die Nix Repl verlassen. Die Nix Repl bietet integrierte Dokumentation und kann auch mit mehrzeiligen Eingaben gut umgehen.\nEinfache Sprachbestandteile # Im Schnelldurchlauf.\nKommentare # # Einzeilige Kommentare (wie in Python). /* Mehrzeilige Kommentare (wie in C++). Python-Einzeiler und C++-Mehrzeiler sind schon mal eine seltsame Kombination. Wir haben noch nicht richtig begonnen und der Merkwürdigkeitsfaktor ist schon größer 1. */ Booleans # nix-repl\u0026gt; true \u0026amp;\u0026amp; false false nix-repl\u0026gt; true || false true Verzweigung # nix-repl\u0026gt; if 3 \u0026lt; 4 then \u0026#34;a\u0026#34; else \u0026#34;b\u0026#34; \u0026#34;a\u0026#34; Zahlen # Es scheint Integers und Floats zu geben. Man kann sie beim Rechnen mit einander kombinieren. Die arithmetischen Operatoren sind polymorph. Der Interpreter scheint selbständig nach gewissen Regeln zu enscheiden, wann das Ergebnis Integer und wann es Float ist. Daraus ergeben sich die üblichen Fallstricke:\nnix-repl\u0026gt; 7.0 / 2 3.5 nix-repl\u0026gt; 7 / 2 3 Für den Einsatzzweck der Nix Expression Language ist das bestimmt kein Problem.\nStrings # nix-repl\u0026gt; \u0026#34;Das ist ein String\u0026#34; \u0026#34;Das ist ein String\u0026#34; Strings können mehrzeilig sein:\nnix-repl\u0026gt; \u0026#34;asdf ... asdf ... asdf\u0026#34; \u0026#34;asdf\\nasdf\\nasdf\u0026#34; Die sogenannten Indented Strings sind ebenfalls mehrzeilig. Bei ihnen wird die Einrückung nicht mit ausgewertet. Das ist die kürzeste Folge von führenden Leerzeichen, in der alle nicht leeren Zeilen des Strings übereinstimmen. Ob und wie dabei Tabs berücksichtigt werden, habe ich nicht ausprobiert. Hier werden in jeder Zeile die vier führenden Leerzeichen entfernt:\nnix-repl\u0026gt; \u0026#39;\u0026#39; asdf ... asdf ... asdf\u0026#39;\u0026#39; \u0026#34;asdf\\nasdf\\nasdf\u0026#34; Mit leeren Zeilen sind hier auch Zeilen gemeint, die nur aus Leerraum bestehen. Leerzeilen am Rand des Strings werden verworfen.\nVerkettung von Strings mit +:\nnix-repl\u0026gt; \u0026#34;ab\u0026#34; + \u0026#34;cd\u0026#34; \u0026#34;abcd\u0026#34; Auswertung in Strings:\nnix-repl\u0026gt; \u0026#34;Home is ${builtins.getEnv \u0026#34;HOME\u0026#34;}.\u0026#34; \u0026#34;Home is /home/aramis.\u0026#34; Der Name builtins verweist auf eine Standardbibliothek (genauer: ein Set) von Funktionen und Prozeduren. Das builtins Set ist immer verfügbar wenn der Nix Interpreter startet. Die Prozedur builtins.getEnv liefert den Wert von Umgebungsvariablen.\nnix-repl\u0026gt; builtins.getEnv \u0026#34;HOME\u0026#34; \u0026#34;/home/aramis\u0026#34; Pfade # Für Pfade gibt es einen eigenen Basisdatentyp. Man notiert Pfade einfach so wie man sie auch sonst notieren würde:\nnix-repl\u0026gt; /home/aramis /home/aramis Das hat aber Einschränkungen. Zum Beispiel sind abschließende Schrägstriche aus irgendwelchen Gründen nicht gestattet:\nnix-repl\u0026gt; /home/aramis/ error: path has a trailing slash nix-repl\u0026gt; /home/aramis/. /home/aramis Pfade ganz ohne Schrägstriche wie z.B. . werden auch nicht erkannt:\nnix-repl\u0026gt; . error: syntax error, unexpected \u0026#39;.\u0026#39; nix-repl\u0026gt; ./ error: path has a trailing slash nix-repl\u0026gt; ./. /home/aramis Relative Pfade werden in absolute Pfade aufgelöst relativ zu dem Verzeichnis, in welchem sich die Datei befindet, die ausgewertet wird:\nnix-repl\u0026gt; ./. /home/aramis Pfade werden kanonisiert:\nnix-repl\u0026gt; /home/aramis/. /home/aramis Daraus, dass der Parser auch relative Pfade als Pfade erkennt, ergibt sich, dass der Schrägstrich, wenn er als Divisionszeichen gelesen werden soll, von Leerraum umgeben sein muss\nnix-repl\u0026gt; 0/0 /home/aramis/0/0 nix-repl\u0026gt; 0 / 0 error: division by zero Imports # Jedes Nix Skript enthält genau einen Top-Level-Ausdruck ohne freie Variable, der also vollständig ausgewertet werden kann. Wenn ein Skript importiert wird, entspricht der Wert des Import-Ausdrucks dem Wert des importierten Skripts:\n$ echo \u0026#34;1 + 2\u0026#34; \u0026gt; foo.nix $ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; import ./foo.nix 3 Das import Schlüsselwort kann auch Strings verarbeiten:\nnix-repl\u0026gt; import \u0026#34;/home/aramis/foo.nix\u0026#34; 3 Aber das scheint nur zu funktionieren wenn der String einen absoluten Pfad enthält:\nnix-repl\u0026gt; import \u0026#34;foo.nix\u0026#34; error: string \u0026#39;foo.nix\u0026#39; doesn\u0026#39;t represent an absolute path nix-repl\u0026gt; import \u0026#34;./foo.nix\u0026#34; error: string \u0026#39;./foo.nix\u0026#39; doesn\u0026#39;t represent an absolute path Let-In-Ausdrücke # Dafür gibt es eine let ... ; in ... Syntax:\nnix-repl\u0026gt; let x = \u0026#34;a\u0026#34; ; in x + x + x \u0026#34;aaa\u0026#34; Die Zuweisungen können sich auf einander beziehen, unabhängig von ihrer Reihenfolge:\nnix-repl\u0026gt; let y = x + \u0026#34;b\u0026#34; ; x = \u0026#34;a\u0026#34; ; in y + \u0026#34;c\u0026#34; \u0026#34;abc\u0026#34; Innere Zuweisungen überschatten weiter außen liegende Zuweisungen:\nnix-repl\u0026gt; let a = 1 ; in let a = 2 ; in a 2 Funktionen # Das ist erstaunlich rudimentär gelöst. Nix kennt eigentlich nur einfache Lambdas:\nnix-repl\u0026gt; (n : n + 1) 5 6 Lambdas mit mehr als einem Parameter ergeben sich aus der Syntax auf natürliche Weise:\nnix-repl\u0026gt; (a : b : a + b) 5 6 11 Wenn man Namen für Funktionen vergeben möchte, kann man auf die let ... ; in ... Syntax zurückgreifen:\nnix-repl\u0026gt; let plus = (a : b : a + b ) ; in plus 5 6 11 Listen # Listen sind von eckigen Klammern begrenzt. Die Elemente sind durch Lerraum getrennt.\nnix-repl\u0026gt;[ 1 2 3 ] [ 1 2 3 ] Es gibt viele Built-Ins für Listen:\nnix-repl\u0026gt; builtins.length [ 1 2 3 ] 3 nix-repl\u0026gt; builtins.concatLists [ [ 1 2 3 ] [ 4 5 6 ] ] [ 1 2 3 4 5 6 ] nix-repl\u0026gt; builtins.head [ 1 2 3 ] 1 nix-repl\u0026gt; builtins.filter (n : n \u0026lt; 3) [ 1 2 3 ] [ 1 2 ] Sets (Mengen) # In Nix Sets hat jedes Element einen String als Schlüssel also einen Namen. Demnach sind Nix Sets keine bloßen Mengen sondern eher Records bzw. Maps.\nnix-repl\u0026gt; { a = 1 ; b = 2 ; }.a 1 nix-repl\u0026gt; let s = { a = 1 ; b = 2 ; } ; in s.a 1 Der ? Operator prüft die Existenz eines Schlüssels:\nnix-repl\u0026gt; { a = 1 ; b = 2 ; } ? a true Der // Operator vereinigt zwei Sets:\nnix-repl\u0026gt; { a = 1 ; } // { b = 2 ; } { a = 1; b = 2; } Wenn dabei Schlüssel kollidieren, hat das rechte Set Vorrang:\nnix-repl\u0026gt; { a = 1 ; } // { a = 2 ; } { a = 2; } Mit dem rec Schlüsselwort können rekursive Sets deklariert werden. Darin können sich Werte auf andere Werte des selben Sets beziehen:\nnix-repl\u0026gt; rec { a = 1 ; b = a ; } { a = 1; b = 1; } nix-repl\u0026gt; rec { a = b ; b = a ; } error: infinite recursion encountered Für verschachtelte Sets gibt es eine Kurznotation:\nnix-repl\u0026gt; { a.b = 2 ; a.c = 3 ; } { a = { ... }; } Das entspricht:\nnix-repl\u0026gt; { a = { b = 2 ; c = 3 ; } ; } { a = { ... }; } Man kann die Kurznotation mit der ausführlicheren mischen:\nnix-repl\u0026gt; { a = { b = 2 ; } ; a.c = 3 ; } { a = { ... }; } Ich finde, das sieht widersprüchlich aus.\nDas with Schlüsselwort # Das with Schlüsselwort nimmt ein Set und einen Ausdruck. In dem Ausdruck gelten die Schlüssel-Wert-Paare des Sets als Bindungen:\nnix-repl\u0026gt; with { a = 1 ; b = 2 ; } ; a + b 3 Das ist also wie die let ... ; in ... Syntax:\nnix-repl\u0026gt; let a = 1 ; b = 2 ; in a + b 3 Der Unterschied ist, dass bei with die gesamte Menge von Bindungen in einem (Set-)Ausdruck zusammengefasst ist. Dadurch kann man sich die Bindungen sozusagen als ein ganzes Bündel aus dem Kontext holen. Man sieht das häufig in Nix-Expressions bspw. um die Built-Ins unqualifiziert verfügbar zu machen:\nnix-repl builtins.length [ 1 2 3 ] 3 nix-repl\u0026gt; with builtins ; length [ 1 2 3 ] 3 Das ist sinnvoll wenn man z.B. viele Built-Ins in einem Ausdruck verwenden möchte und sie nicht jedesmal mit builtins. qualifizieren möchte.\nOhne with:\nnix-repl\u0026gt; [ ( builtins.length [ 1 2 3 ] ) ... ( builtins.head [ 1 2 3 ] ) ... ( builtins.elem 2 [ 1 2 3 ] ) ... ] [ 3 1 true ] Mit with:\nnix-repl\u0026gt; with builtins ; ... [ ( length [ 1 2 3 ] ) ... ( head [ 1 2 3 ] ) ... ( elem 2 [ 1 2 3 ] ) ... ] [ 3 1 true ] Wenn man also qualifiziert importieren möchte, ganz grob ungefähr so wie man es in Haskell machen würde, könnte das so aussehen:\n$ echo \u0026#34;{ plus = a : b : a + b ; }\u0026#34; \u0026gt; foo.nix $ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; let foo = import ./foo.nix ; in with foo ; foo.plus 5 6 11 Das würde einem unqualifizierten Import entsprechen:\nnix-repl\u0026gt; with import ./foo.nix ; plus 5 6 11 Anstatt wie oben den Import in einem Let-Ausdruck an den Namen foo zu binden, kann man diesen Namen in der importierten Datei festlegen. Dann spart man sich den Let-Ausdruck:\n$ echo \u0026#34;{ foo = { plus = a : b : a + b ; } ; }\u0026#34; \u0026gt; foo.nix $ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; with import ./foo.nix ; foo.plus 5 6 11 Die Variante hat den großen Nachteil, dass die Festlegung des Qualifiers foo in der importierenden Datei nicht explizit ist.\nMit with lässt sich jeweils nur ein Set von Bindungen angeben aber, ähnlich wie bie den Lambdas, ergibt sich auch hier aus der Syntax eine natürliche Erweiterung auf mehrere Sets:\nnix-repl\u0026gt; with builtins ; ... with { myList = [ 1 2 3 ] ; } ; ... length myList 3 Set Patterns # Funktionen unterstützen per se keine benannten Parameter. Lambdas können aber selbstverständlich auch auf Sets operieren:\nnix-repl\u0026gt; (x : x.a + x.b) { a = 5 ; b = 6 ; } 11 Mit sogenannten Set Patterns kann man letztlich doch benannte Funktionsparameter aufschreiben:\nnix-repl\u0026gt; ({a,b} : a + b) { a = 5 ; b = 6 ; } 11 Dabei ist {a,b} ein sogenanntes Set Pattern.\nAchtung: Wenn das Argument ein Set ist, welches zusätzliche Werte enthält, die im Set Pattern nicht angegeben sind, ist das ein Fehler:\nnix-repl\u0026gt; ({a,b} : a + b) { a = 5 ; b = 6 ; c = 7 ; } error: anonymous function at (string):1:2 called with unexpected argument \u0026#39;c\u0026#39; Man kann den Fall aber im Set Pattern durch Auslassungspunkte ausdrücklich zulassen:\nnix-repl\u0026gt; ({a,b,...} : a + b) { a = 5 ; b = 6 ; c = 7 ; } 11 Fehler # Das throw Schlüsselwort bricht die Auswertung ab und gibt eine Fehlermeldung aus:\nnix-repl\u0026gt; 1 + 2 + throw \u0026#34;drei\u0026#34; error: drei Anscheinend werden Fehler innerhalb von Listen wie normale Elemente behandelt. Die Auswertung wird nicht abgebrochen:\nnix-repl\u0026gt; [ 1 (throw \u0026#34;zwei\u0026#34;) 3 ] [ 1 «error: error: zwei» 3 ] Das gleiche Verhalten tritt innerhalb von Sets auf:\nnix-repl\u0026gt; { eins = 1 ; zwei = throw \u0026#34;zwei\u0026#34; ; drei = 3 ; } { drei = 3; eins = 1; zwei = «error: error: zwei»; } Neben throw gibt es auch noch das Schlüsselwort abort, welches ebenfalls die Auswertung abbricht und eine Fehlermeldung ausgibt:\nnix-repl\u0026gt; 1 + 2 + abort \u0026#34;drei\u0026#34; error: evaluation aborted with the following error message: \u0026#39;drei\u0026#39; Im Unterschied zu throw führt abort auch innerhalb von Listen und Sets zum Abbruch der Auswertung:\nnix-repl\u0026gt; [ 1 (abort \u0026#34;zwei\u0026#34;) 3 ] error: evaluation aborted with the following error message: \u0026#39;zwei\u0026#39; nix-repl\u0026gt; { eins = 1 ; zwei = abort \u0026#34;zwei\u0026#34; ; drei = 3 ; } error: evaluation aborted with the following error message: \u0026#39;zwei\u0026#39; Der Unterschied zwischen throw und abort ist nützlich. In nix-env -qa und anderen Shell-Anweisungen, die Listen oder Sets von Nix Derivationen verarbeiten, wird throw verwendet, sofern bei einem Fehler in einer Derivation trotzdem alle nachfolgenden Derivationen verarbeitet werden sollen. Natürlich gibt es auch Fälle, in denen ein Fehler zum Abbruch der ganzen Auswertung führen soll. In solchen Fällen verwendet man abort.\nMit builtins.tryEval können Fehler aufgefangen werden, die mit throw ausgelöst worden sind:\nnix-repl\u0026gt; builtins.tryEval (1 + 2 + 3) { success = true; value = 6; } nix-repl\u0026gt; builtins.tryEval (1 + 2 + throw \u0026#34;drei\u0026#34;) { success = false; value = false; } Mit abort ausgelöste Fehler kann builtins.tryEval nicht auffangen:\nnix-repl\u0026gt; builtins.tryEval (1 + 2 + abort \u0026#34;drei\u0026#34;) error: evaluation aborted with the following error message: \u0026#39;drei\u0026#39; Das assert Schlüsselwort erwartet zwei Ausdrücke, getrennt durch ein Semikolon:\nassert \u0026lt;erster Ausdruck\u0026gt; ; \u0026lt;zweiter Ausdruck\u0026gt; Der erste Ausdruck muss boolsch sein. Der zweite Ausdruck kann beliebig sein. Wenn der erste Ausdruck zu true auswertet, wertet der gesamte assert Ausdruck zum zweiten Ausdruck aus:\nnix-repl\u0026gt; assert true ; \u0026#34;1199Panigale\u0026#34; \u0026#34;1199Panigale\u0026#34; nix-repl\u0026gt; assert 3 \u0026lt; 4 ; \u0026#34;1199\u0026#34; + \u0026#34;Panigale\u0026#34; \u0026#34;1199Panigale\u0026#34; Wenn der erste Ausdruck zu false auswertet, löst der assert Ausdruck einen Fehler aus:\nnix-repl\u0026gt; assert false ; \u0026#34;1199Panigale\u0026#34; error: assertion \u0026#39;false\u0026#39; failed nix-repl\u0026gt; assert 4 \u0026lt; 3 ; \u0026#34;1199\u0026#34; + \u0026#34;Panigale\u0026#34; error: assertion \u0026#39;(__lessThan 4 3)\u0026#39; failed Fehler, die von assert ausgelöst worden sind, können mit builtins.tryEval aufgefangen werden:\nnix-repl\u0026gt; builtins.tryEval (assert true ; \u0026#34;1199Panigale\u0026#34;) { success = true; value = \u0026#34;1199Panigale\u0026#34;; } nix-repl\u0026gt; builtins.tryEval (assert false ; \u0026#34;1199Panigale\u0026#34;) { success = false; value = false; } Impurity # Die Nix Expression Language ist keine pure funktionale Sprache. Sie folgt dem Anspruch, möglichst pur zu arbeiten, um die Reproduzierbarkeit von Builds sicherzustellen. Es gibt aber ein paar Ausnahmen.\nIch will kein Haskell Snob sein, bin aber geneigt, anzumerken, dass eine Programmiersprache entweder purely functional ist oder nicht, also ganz oder gar nicht. Es gibt dazwischen keinen Kompromiss, bzw. der Kompromiss wäre immer impure. Schließlich ist eine mathematische Relation entweder eine Abbildung oder eben nicht. Andererseits kann man sehr wohl auch in einer Programmiersprache, welche diese Eigenschaft nicht hat, purely functional programmieren; es obliegt dann nur dem Menschen, sicherzustellen dass der Code ausschließlich statische Werte aus dem Kontext liest und klar unterscheidet zwischen Prozeduren, die Nebeneffekte hervorrufen, und solchen die das nicht tun.\nEs folgen ein paar Ursachen dafür, dass die Nix Expression Language nicht pure ist. (Es gibt noch weitere.)\nbuiltins.getEnv # Die Prozedur builtins.getEnv liest Umgebungsvariable:\nnix-repl\u0026gt; builtins.getEnv \u0026#34;HOME\u0026#34; \u0026#34;/home/aramis\u0026#34; Das ist unter allen Prozeduren, die hier aufgeführt sind, der eine, von dem ich mir vorstellen könnte, dass er in die tolle Idee vom Purely Functional Package Management eine große Lücke reißt.\nbuiltins.trace # Die Prozedur builtins.trace nimmt zwei Werte entgegen, sendet den ersten Wert zur Standardfehlerausgabe und wertet selbst zum zweiten Wert aus:\nnix-repl\u0026gt; builtins.trace \u0026#34;err\u0026#34; \u0026#34;val\u0026#34; trace: err \u0026#34;val\u0026#34; Auf die Standardfehlerausgabe zu schreiben, ist strenggenommen ein Nebeneffekt, aber auch Sprachen, die sich rühmen, purely functional zu sein, brauchen und haben eine trace Prozedur.\nbuiltins.toFile # Die Prozedur builtins.toFile schreibt Dateien in den Nix Store:\nnix-repl\u0026gt; builtins.toFile \u0026#34;foo.txt\u0026#34; \u0026#34;hello!\u0026#34; \u0026#34;/nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt\u0026#34; nix-repl\u0026gt; :q $ cat /nix/store/ayh05aay2anx135prqp0cy34h891247x-foo.txt hello! In eine Datei zu schreiben ist natürlich ein Nebeneffekt. Zumindest wird hier sichergestellt, dass eine Datei, die einmal im Nix Store erzeugt worden ist, ihren Inhalt nicht mehr unbemerkt ändern kann, denn ein Hashwert ihres Inhalts wird dem Dateinamen als Präfix vorangestellt. Was Nix anschließend mit diesen Hashwerten macht \u0026ndash; insbesondere ob Nix wirklich jede Datei vor jeder Verarbeitung erneut hasht und mit dem Dateinamen abgleicht \u0026ndash; weiß ich nicht, aber das finde ich bestimmt noch heraus.\nAn der Stelle bin ich durch mit https://learnxinyminutes.com/docs/nix/. Aktuell ist mein Plan, mir als nächstes die Namen anzuschauen, die in der Nix Repl aufgelistet werden wenn man direkt nach dem Start die Tab-Taste drückt. Dann schaue ich mir den Inhalt des builtins Sets genauer an.\nTop-Level Namen # Es gibt ein paar Namen (für Funktionen, Prozeduren, \u0026hellip;), die nach dem Start der Nix Repl unqualifiziert im Top-Level zur Verfügung stehen:\nabort baseNameOf break builtins derivation derivationStrict dirOf false fetchGit fetchMercurial fetchTarball fetchTree fromTOML import isNull map null placeholder removeAttrs scopedImport throw toString true Daneben gibt es noch eine Menge von Namen, die mit einem Unterstrich beginnen, wie z.B. __typeOf. Das scheinen allesamt Aliase für die Namen im builtins Set zu sein. Diese Namen lasse ich hier aus, weil ich vorhabe, später auf den Inhalt von builtins einzugehen.\nDie folgenden Namen wurden schon weiter oben erläutert:\nabort builtins false import throw true Jetzt schaue ich mir den Rest an.\nmap # Damit kann man eine Funktion auf jedes Element in einer Liste anwenden:\nnix-repl\u0026gt; map (n : 2 * n) [ 1 2 3 ] [ 2 4 6 ] Wer schon funktional programmiert hat, dürfte map kennen.\nbaseNameOf # Liefert das letzte Segment in einem Pfad:\nnix-repl\u0026gt; baseNameOf /home/aramis \u0026#34;aramis\u0026#34; nix-repl\u0026gt; baseNameOf ./. \u0026#34;aramis\u0026#34; Das funktioniert auch mit Strings:\nnix-repl\u0026gt; baseNameOf \u0026#34;/home/aramis\u0026#34; \u0026#34;aramis\u0026#34; nix-repl\u0026gt; baseNameOf \u0026#34;/home/aramis/\u0026#34; \u0026#34;aramis\u0026#34; Pfade in einem String werden aber nicht kanonisiert:\nnix-repl\u0026gt; baseNameOf \u0026#34;../../..\u0026#34; \u0026#34;..\u0026#34; dirOf # Liefert den Pfad ohne das letzte Segment:\nnix-repl\u0026gt; dirOf /home/aramis /home nix-repl\u0026gt; dirOf \u0026#34;/home/aramis\u0026#34; \u0026#34;/home\u0026#34; nix-repl\u0026gt; dirOf \u0026#34;/home/aramis/\u0026#34; \u0026#34;/home/aramis\u0026#34; nix-repl\u0026gt; dirOf \u0026#34;../../..\u0026#34; \u0026#34;../..\u0026#34; null, isNull # Offenbar gibt es einen null Wert. Ich weiß nicht, welche Rolle null in der Nix Expression Language spielt. Hoffentlich keine allzu große. In anderen Sprachen repräsentiert der null Wert häufig die Abwesenheit eines \u0026ldquo;echten\u0026rdquo; Wertes.\nDer null Wert scheint seinen eigenen Datentyp zu haben. Ich greife an der Stelle vor auf builtins.typeOf. Damit kann man den Datentyp eines Ausdrucks finden:\nnix-repl\u0026gt; builtins.typeOf 0 \u0026#34;int\u0026#34; nix-repl\u0026gt; builtins.typeOf 0.0 \u0026#34;float\u0026#34; nix-repl\u0026gt; builtins.typeOf false \u0026#34;bool\u0026#34; nix-repl\u0026gt; builtins.typeOf \u0026#34;\u0026#34; \u0026#34;string\u0026#34; nix-repl\u0026gt; builtins.typeOf [] \u0026#34;list\u0026#34; nix-repl\u0026gt; builtins.typeOf {} \u0026#34;set\u0026#34; nix-repl\u0026gt; builtins.typeOf null \u0026#34;null\u0026#34; Die Funktion isNull ist markiert als deprecated. Man soll stattdessen ... == null verwenden:\nnix-repl\u0026gt; isNull null true nix-repl\u0026gt; isNull 0 false nix-repl\u0026gt; isNull \u0026#34;\u0026#34; false nix-repl\u0026gt; null == null true nix-repl\u0026gt; 0 == null false nix-repl\u0026gt; \u0026#34;\u0026#34; == null false toString # Damit können Ausdrücke in eine Stringdarstellung überführt werden:\nnix-repl\u0026gt; toString 123 \u0026#34;123\u0026#34; nix-repl\u0026gt; toString \u0026#34;Das ist schon ein String\u0026#34; \u0026#34;Das ist schon ein String\u0026#34; Pfade werden kanonisiert:\nnix-repl\u0026gt; toString ./. \u0026#34;/home/aramis\u0026#34; Für andere Datentypen liefert toString Ergebnisse, die ich so nicht erwartet hätte:\nnix-repl\u0026gt; toString 0.0 \u0026#34;0.000000\u0026#34; nix-repl\u0026gt; toString true \u0026#34;1\u0026#34; nix-repl\u0026gt; toString false \u0026#34;\u0026#34; nix-repl\u0026gt; toString [] \u0026#34;\u0026#34; nix-repl\u0026gt; toString [ 1 2 3 ] \u0026#34;1 2 3\u0026#34; nix-repl\u0026gt; toString [ 1 2 3 [ 4 5 6 ] ] \u0026#34;1 2 3 4 5 6\u0026#34; nix-repl\u0026gt; toString null \u0026#34;\u0026#34; Auf Sets kann toString nur operieren wenn darin ein spezieller Schlüssel __toString oder outPath vorhanden ist:\nnix-repl\u0026gt; toString { a = 1 ; b = 2 ; c = 3 ; } error: cannot coerce a set to a string nix-repl\u0026gt; toString { a = 1 ; b = 2 ; c = 3 ; outPath = \u0026#34;asdf\u0026#34; ; } \u0026#34;asdf\u0026#34; nix-repl\u0026gt; toString ... { a = 1 ; b = 2 ; c = 3 ; __toString = self : self.a } \u0026#34;1\u0026#34; break # Die Prozedur break hat hier nichts mit While-Schleifen oder ähnlichem zu tun. Man kann damit Breakpoints im Code setzen, an denen der Interpreter im Debug Modus die Auswertung pausiert und in die Repl wechselt. Um den Interpreter im Debug Modus zu starten, muss das Flag --debugger mit übergeben werden.\nDa wir hier nicht imperativ sondern deklarativ bzw. funktional programmieren, kann break nicht als Anweisung im Code platziert werden ohne selbst zu irgendetwas auszuwerten. Deswegen erwartet break ein Argument und wertet zu diesem Argument aus:\nnix-repl\u0026gt; break 1 1 removeAttrs # Die Funktion removeAttrs nimmt ein Set und eine Liste mit Schlüsseln entgegen. Die aufgeführten Schlüssel werden aus dem Set entfernt. Schlüssel, die in dem Set nicht vorkommen, werden ignoriert:\nnix-repl\u0026gt; removeAttrs { x = 1 ; y = 2 ; z = 3 ; } [ \u0026#34;a\u0026#34; \u0026#34;x\u0026#34; \u0026#34;z\u0026#34; ] { y = 2; } Ich glaube, diese Stelle markiert einen Übergang. Ich habe zunächst versucht, die Nix Expression Language ganz allgemein als Programmiersprache zu betrachten, ohne darauf Rücksicht zu nehmen, wofür sie tatsächlich eingesetzt werden soll. Ich denke, dass das ab hier immer weniger möglich sein wird.\nfromTOML # Ich bin mit TOML nicht besonders vertraut, aber ich glaube, es ist nicht viel mehr als eine Folge von zeilenweisen Schlüssel-Wert-Zuweisungen in der Form key=value. Die Funktion fromTOML scheint TOML Markup in ein Nix Set zu überführen:\nnix-repl\u0026gt; fromTOML \u0026#34;a=1\\nb=2\u0026#34; { a = 1; b = 2; } scopedImport # Das ist nirgendwo richtig dokumentiert und wird nicht einmal im Nix Manual erwähnt. Es gibt eine Issue auf Github dazu:\nhttps://github.com/NixOS/nix/issues/1450\nEin paar Auszüge:\n\u0026ldquo;scopedImport has nasty performance consequences since it disables the parser/evaluation cache\u0026rdquo; \u0026ldquo;It allows doing some pretty nasty/nifty things like overriding every primop (including import)\u0026rdquo; Ok, also die Finger davon lassen. Es hätte mich trotzdem ein bisschen interessiert, wie man das benutzt, aber nicht so sehr, dass ich an der Stelle weiterbuddeln möchte.\nfetchGit, fetchMercurial, fetchTarball, fetchTree # Mit den Fetch-Befehlen lassen sich Dateien herunterladen und in den Nix Store schreiben. fetchMercurial und fetchTree sind undokumentiert, also schaue ich mir zunächst die anderen beiden an.\nfetchGit holt einen Pfad aus einem Git Repository und schreibt ihn in den Nix Store. In der Nix Repl erhält man mit :doc fetchGit reichlich Dokumentation dazu, wie das genau zu benutzen ist. Ich möchte das hier nicht alles wiedergeben.\nfetchTarball lädt ein Tar-Archiv herunter und entpackt es in den Nix Sore. Das Tar-Archiv kann (oder muss?) zusätzlich mit gzip, bzip7 oder xv komprimiert sein. Die Dokumentation in der Repl dazu ist auch recht ausführlich.\nfetchMercurial ist in der Repl nicht dokumentiert. Ich nehme an, es ist wie fetchGit aber für Mercurial Repositories.\nfetchTree ist ebenfalls undokumentiert in der Repl. Das Nix Manual erwähnt, dass fetchTree die Funktionalität der anderen Fetch-Befehle in sich vereint und somit beliebige Quellen herunterladen kann. Möglicherweise ist das nur eine Fassade, die je nach Quelle das passende Backend wählt, ungefähr so wie aunpack das Entpacken von Archivdateien handhabt.\nderivation, derivationStrict # Beides hat in der Nix Repl keine Dokumentation. Was ist eine Derivation? Man kann das wörtlich mit Ableitung übersetzen. Im Kontext von Nix ist damit eine sogenannte Build Action gemeint. Ich nehme an, das ist ein Rezept für den Bau eines Softwarepaketes und seine \u0026ldquo;Installation\u0026rdquo; im Nix Store. Laut Handbuch ist derivation die wichtigste built-in Funktion: schließlich ist Nix genau dafür gedacht/gemacht, solche Derivationen zu beschreiben und auszuführen.\nderivation verarbeitet ein Set, das genau beschreibt, was gebaut wird, und zwar mit den folgenden Schlüsseln (Attributen):\nsystem Nix Systemtyp, z.B. \u0026quot;i686-linux\u0026quot; oder \u0026quot;x86_64-darwin\u0026quot; siehe nix -vv --version name der Name des Pakets builder das Programm, welches zum Bauen verwendet wird kann eine Derivation oder eine lokale Datei sein (ein Script) Die Attribute der Derivation werden als Umgebungsvariable übergeben: Strings und Zahlen werden unverändert übergeben. Pfade werden zunächst in den Nix Store kopiert und der Zielpfad landet in der Umgebungsvariable. Derivationen werden gebaut und der Pfad des Zielartefakts landet in der Umgebungsvariable. Listen werden leerzeichensepariert übergeben. true wird als 1 übergeben. false und null werden als \u0026quot;\u0026quot; übergeben. args optionale Liste von CLI-Argumenten für das bauende Programm outputs optionale Liste von Ausgabepfaden Normalerweise gibt es nur einen Outputpfad out, aber man kann diesen Schlüssel verwenden, um verschiedene Ausgabepfade zu deklarieren, bspw. [ \u0026quot;lib\u0026quot; \u0026quot;headers\u0026quot; \u0026quot;doc\u0026quot; ], dann stehen dem bauenden Programm drei Pfade statt nur einem zur Verfügung, die separat garbage-collected werden können. Damit habe ich eine erste, grobe Vorstlelung davon, wie Nix baut.\nFür derivationStrict habe ich nirgendwo Dokumentation gefunden.\nplaceholder # Nimmt einen Ausgabepfad entgegen (\u0026quot;out\u0026quot;, \u0026quot;bin\u0026quot;, \u0026quot;dev\u0026quot;, \u0026hellip;) und liefert einen Plazhalter, der beim Bauen durch den Ausgabepfad ersetzt wird. Es scheint wirklich eine Funktion zu sein:\nnix-repl\u0026gt; placeholder \u0026#34;out\u0026#34; \u0026#34;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9\u0026#34; nix-repl\u0026gt; placeholder \u0026#34;out\u0026#34; \u0026#34;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9\u0026#34; nix-repl\u0026gt; placeholder \u0026#34;out\u0026#34; \u0026#34;/1rz4g4znpzjwh1xymhjpm42vipw92pr73vdgl6xs1hycac8kf2n9\u0026#34; Keine Ahnung, wofür das gut ist.\nBuilt-ins # Im letzten Abschnitt habe ich mir die Namen angeschaut, die nach dem Start der Nix Repl unqualifiziert im Top-Level verfügbar sind. Unterhalb von builtins gibt es eine ganze Reihe weiterer Namen. Die schaue ich mir jetzt an. Einige davon sind nicht neu, weil sie auch im Top-Level verfügbar sind. Die lasse ich unerwähnt aus.\nbuiltins.add # Die Funktion hinter dem + Operator:\nnix-repl\u0026gt; builtins.add 3 4 7 builtins.addErrorContext # Dafür finde ich keine Dokumentation.\nbuiltins.all # Prüft ob ein Prädikat auf alle Elemente einer Liste zutrifft:\nnix-repl\u0026gt; builtins.all ( n : n \u0026gt; 3 ) [ 1 2 3 ] false nix-repl\u0026gt; builtins.all ( n : n \u0026gt; 3 ) [ 4 5 6 ] true builtins.any # Prüft ob ein Prädikat auf mindestens ein Element einer Liste zutrifft:\nnix-repl\u0026gt; builtins.any ( n : n \u0026lt; 3 ) [ 1 2 3 ] true nix-repl\u0026gt; builtins.any ( n : n \u0026lt; 3 ) [ 4 5 6 ] false builtins.appendContext # Dafür finde ich keine Dokumentation.\nbuiltins.attrNames # Liefert eine sortierte Liste der Schlüssel in einem Set:\nnix-repl\u0026gt; builtins.attrNames { a = 1 ; b = 2 ; c = 3 ; } [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] builtins.attrValues # Wie Sartres Autodidakt, gehe ich die Built-ins in alphabetischer Reihder sonderliche Autodidakt in Bouville, gehe ich die Built-ins in alphabetischer Reihenfolge durch. Immerhin sind es bei mir nicht die Bücher einer ganzen Bibliothek, sondern nur ein paar Nix-Funktionen. Jetzt wäre builtins.deepSeq\nnix-repl\u0026gt; builtins.attrValues { a = 3 ; b = 2 ; c = 1 ; } [ 3 2 1 ] builtins.bitAnd # Bitweise Konjunktion zweier Integers:\nnix-repl\u0026gt; builtins.bitAnd 123 456 72 Rechnen wir das spaßeshalber durch:\n123 = 64 + 32 + 16 + 8 + 2 + 1 = 2^6 + 2^5 + 2^4 + 2^3 + 2^1 + 2^0 = 1111011 456 = 256 + 128 + 64 + 8 = 2^8 + 2^7 + 2^6 + 2^3 = 111001000 001111011 + 111001000 = 001001000 = 2^3 + 2^6 = 72 builtins.bitOr # Bitweise Disjunktion zweier Integers:\nnix-repl\u0026gt; builtins.bitOr 123 456 507 builtins.bitXor # Bitweise Kontravalenz (\u0026ldquo;exklusive Disjunktion\u0026rdquo;) zweiter Integers:\nnix-repl\u0026gt; builtins.bitXor 123 456 435 builtins.builtins # Offenbar enthält das builtins Set eine Referenz auf sich selbst.\nnix-repl\u0026gt; builtins.builtins == builtins true nix-repl\u0026gt; builtins.builtins.builtins.builtins == builtins true Schrullig, aber was soll\u0026rsquo;s.\nbuiltins.catAttrs # Das nimmt einen Schlüssel (String) und sammelt aus einer Liste von Sets die Werte für diesen Schlüssel ein:\nnix-repl\u0026gt; builtins.catAttrs \u0026#34;a\u0026#34; ... [ { a = 1 ; } { b = 2 ; } { a = 3 ; } ] [ 1 3 ] builtins.ceil # Liefert für eine Zahl x die nächste Ganzzahl n sodass x \u0026lt;= n:\nnix-repl\u0026gt; builtins.ceil 1.5 2 nix-repl\u0026gt; builtins.ceil 2 2 builtins.compareVersions # Vergleicht zwei Strings anhand der typischen Ordnung von Versionsnummern. Das Ergebnis ist -1, 0 oder 1, je nachdem ob das erste Argument gegenüber dem zweiten kleiner, gleich oder größer ist.\nnix-repl\u0026gt; builtins.compareVersions \u0026#34;0.0.0\u0026#34; \u0026#34;0.0.1\u0026#34; -1 nix-repl\u0026gt; builtins.compareVersions \u0026#34;0.0.1\u0026#34; \u0026#34;0.0.1\u0026#34; 0 nix-repl\u0026gt; builtins.compareVersions \u0026#34;0.0.2\u0026#34; \u0026#34;0.0.1\u0026#34; 1 builtins.concatLists # Konkateniert Listen:\nnix-repl\u0026gt; builtins.concatLists [ [ 1 2 3 ] [ 4 5 6 ] ] [ 1 2 3 4 5 6 ] builtins.concatMap # Das ist eine Verkettung von map und concatLists. Das heißt, für eine Funktion f und eine Liste ls sind die folgenden beiden Ausdrücke äquivalent:\nbuiltins.concatLists (map f ls)\nbuiltins.concatMap f ls\nBeispielsweise:\nnix-repl\u0026gt; with ... { f = map ( n : 2 * n ) ; ... ls = [ [ 1 2 3 ] [ 4 5 6 ] ] ; ... } ; ... builtins.concatLists ( map f ls ) [ 2 4 6 8 10 12 ] nix-repl\u0026gt; with ... { f = map ( n : 2 * n ) ; ... ls = [ [ 1 2 3 ] [ 4 5 6 ] ] ; ... } ; ... builtins.concatMap f ls [ 2 4 6 8 10 12 ] builtins.concatStringsSep # Konkateniert Strings mit einem Trennzeichen:\nnix-repl\u0026gt; builtins.concatStringsSep \u0026#34;/\u0026#34; [ \u0026#34;usr\u0026#34; \u0026#34;local\u0026#34; \u0026#34;bin\u0026#34; ] \u0026#34;usr/local/bin\u0026#34; builtins.currentSystem # Liefert einen Namen für das System, auf dem Nix gerade läuft:\nnix-repl\u0026gt; builtins.currentSystem \u0026#34;x86_64-linux\u0026#34; builtins.currentTime # Liefert die aktuelle Posix-Zeit:\nnix-repl\u0026gt; builtins.currentTime 1661168166 builtins.seq # Wie der sonderliche Autodidakt in Bouville, gehe ich die Built-ins in alphabetischer Reihenfolge durch. Immerhin sind es bei mir nicht die Bücher einer ganzen Bibliothek, sondern nur ein paar Nix-Funktionen. Jetzt wäre builtins.deepSeq an der Reihe, aber das wäre Quatsch ohne vorher builtins.seq zu betrachten. Deswegen ziehe ich das vor.\nNix wertet verzögert aus (so wie Haskell). Das bedeutet, dass Ausdrücke erst dann ausgewertet werden wenn sie tatsächlich gebraucht werden und auch nur so weit wie es tatsächlich nötig ist. Ich möchte das kurz an einem Beispiel demonstrieren. Das geht vielleicht am besten mit einer Funktion, die viel Rechenzeit frisst. Ad hoc fällt mir die Fibonacci-Funktion ein. Das hier wäre eine einfache Implementierung dafür in Haskell:\n-- Haskell: fib n = if n \u0026lt; 1 then 0 else if n \u0026lt; 2 then 1 else fib ( n - 1 ) + fib ( n - 2 ) Das ist so rechenaufwändig, dass ich mit meinem Rechner auf fib 32 schon ein paar Sekunden warten muss, also ein guter Kandidat. Wir können das auch als Lambda-Ausdruck schreiben. Dann wandert der Parameter n nach rechts hinter das = Zeichen:\n-- Haskell: fib = \\ n -\u0026gt; if n \u0026lt; 1 then 0 else if n \u0026lt; 2 then 1 else fib ( n - 1 ) + fib ( n - 2 ) In Nix müssen Funktionen als Lambda-Ausdrücke notiert werden. Die konventionelle Notation mit dem Parameter auf der linken Seite wird nicht unterstützt. Mein erster Versuch, diese Funktion in Nix zu schreiben, sah so aus:\nnix-repl\u0026gt; fib = n : ... if n \u0026lt; 1 then 0 ... else if n \u0026lt; 2 then 1 ... else fib ( n - 1 ) + fib ( n - 2 ) error: undefined variable \u0026#39;fib\u0026#39; Nix unterstützt keine rekursiven Funktionen, jedenfalls nicht auf diese Weise. Damit das klappt, müssen wir die Funktion in ein rekursives Set stecken:\nnix-repl\u0026gt; funs = rec ... { fib = n : ... if n \u0026lt; 1 then 0 ... else if n \u0026lt; 2 then 1 ... else fib ( n - 1 ) + fib ( n - 2 ) ; ... } nix-repl\u0026gt; funs.fib 32 2178309 Nix rechnet funs.fib 32 schneller aus als Haskell aber es dauert mit meinem Rechner immer noch mehr als eine Sekunde, bis der Interpreter die Berechnung gestemmt hat und das Ergebnis ausdruckt. Damit haben wir alles beisammen um verzögerte Auswertung zu demonstrieren. Dafür ergänzen wir das Set um zwei weitere Schlüssel-Wert-Paare:\nnix-repl\u0026gt; funs = rec ... { fib = n : ... if n \u0026lt; 1 then 0 ... else if n \u0026lt; 2 then 1 ... else fib ( n - 1 ) + fib ( n - 2 ) ; ... ... fib35 = fib 35 ; ... x = 1 ; ... } nix-repl\u0026gt; Den Wert für den Schlüssel fib35 auszurechnen, sollte ein paar Sekunden dauern, aber die Nix Repl nimmt das Set ohne Zeitverzögerung entgegen. Das spricht dafür, dass der Wert für fib35 nicht sofort berechnet wird. Wir können uns auch den Wert für den Schlüssel x ohne Zeitverzögurung ausgeben lassen:\nnix-repl\u0026gt; funs.x 1 Erst wenn wir uns den Wert für fib35 ausgeben lassen, gibt es eine deutliche Verzögerung von mehreren Sekunden, die darauf hinweist, dass der Wert jetzt tatsächlich berechnet wird:\nnix-repl\u0026gt; funs.fib35 9227465 Wenn wir uns im Anschluss noch einmal das ganze Set ausgeben lassen, geschieht das wieder ohne Verzögerung:\nnix-repl\u0026gt; funs { fib = «lambda @ (string):1:14»; fib35 = 9227465; x = 1; } Der Wert für den Schlüssel fib35 wurde schon berechnet und wird hier einfach wiederverwendet anstatt ihn ein zweites Mal zu berechnen. Deswegen erfolgt die Ausgabe ohne zeitliche Verzögerung. Wenn wir vorher nicht funs.fib35 ausgewertet hätten, dann hätten wir an dieser Stelle ein paar Sekunden auf die Auswertung warten müssen.\nDas ist verzögerte Auswertung: die Ausdrücke und Teilausdrücke werden nicht sofort ausgewertet sondern erst dann wenn ihr Wert tatsächlich benötigt wird, bspw. um eine Ausgabe zu erzeuen.\nIm Allgemeinen ist das eine gute Sache, aber manchmal möchte man, dass die Auswertung nicht verzögert sondern sofort stattfindet. Das ist vor allem dann wichtig, wenn zwei Ausdrücke irgendwelche externen Effeke haben und diese Effekte in einer bestimmen Reihenfolge auftreten sollen. Dann muss man irgendwie sicherstellen, dass die Ausdrücke in der richtigen Reihenfolge ausgewertet werden. In Programmiersprachen, die standardmäßig strikt (i.e. unverzögert) auswerten, hat man dieses Problem nicht. Da ist die Auswertungsreihenfolge dadurch vorgegeben, in welcher Reihenfolge man Ausdrücke notiert. In Programmiersprachen, die standardmäßig verzögert auswerten, benötigt man dafür besondere Hilfsmittel, die eine strikte Auswertung sicherstellen.\nHier kommt builtins.seq ins Spiel. builtins.seq nimmt zwei Ausdrücke entgegen, wertet den ersten Ausdruck aus, verwirft das Resultat und wertet dann den zweiten Ausdruck aus:\nnix-repl\u0026gt; builtins.seq 1 2 2 So wird sichergestellt, dass der erste Ausdruck vor dem zweiten ausgewertet wird. Ich kann gerade kein leicht demonstrierbares Beispiel aus dem Ärmel schütteln, bei dem das eine Rolle spielen würde, aber wenn bspw. der erste Ausdruck eine Datei schreibt und der zweite diese Datei liest, stellt builtins.seq sicher, dass das Schreiben tatsächlich vor dem Lesen erfolgt. Ohne builtins.seq wäre diese Reihenfolge wegen der verzögerten Auswertung nicht sichergestellt.\nbuiltins.deepSeq # Die Auswertung von builtins.seq e1 e2 ist zwar strikt im Ausdruck e1, aber mit einem Haken: der Ausdruck e1 wird nur oberflächlich strikt ausgewertet. Ich erkläre kurz, was das bedeutet. Es gibt einfache Ausdrücke, die direkt ausgewertet werden können ohne dafür weiter vereinfacht werden zu müssen. Das sind bspw. einfache Zahlenausdrücke 123 oder Zeichenketten wie \u0026quot;asdf\u0026quot;. Daneben gibt es aber auch komplexe Ausdrücke, die bei der Auswertung zunächst auf einen einfachen Ausdruck reduziert werden müssen. Das ist der Fall wenn ein Ausdruck Funktionen (bzw. Operationen) enthält, die bei der Auswertung angewendet werden müssen. Diese Reduktion auf einen einfachen Ausdruck erfolgt schrittweise. Hier ist ein Ausdruck, der in mehreren Schritten ausgewertet werden muss:\nnix-repl\u0026gt; let ... f1 = n : 1 + n ; ... f2 = n : 2 + n ; ... f3 = n : 3 + n ; ... in ... f3 ( f2 ( f1 0 ) ) Hier ist eine mögliche Auswertung für diesen Ausdruck:\n=\u0026gt; f3 ( f2 ( f1 0 ) ) -----------------------------------^^^^^^^^^^^^^---------- =\u0026gt; f3 ( f2 ( ( n : 1 + n ) 0 ) ) -----------------------------------^^^^^^^^^^^^^^^-------- =\u0026gt; f3 ( f2 ( 1 + 0 ) ) ---------------------------------^^^^^^^^^^^^^^^^^^^------ =\u0026gt; f3 ( f2 1 ) -------------------^^^^^^^^^^^^^-------------------------- =\u0026gt; f3 ( ( n : 2 + n ) 1 ) -------------------^^^^^^^^^^^^^^^------------------------ =\u0026gt; f3 ( 2 + 1 ) -----------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---- =\u0026gt; f3 3 ---^^^^^^^^^^^^^------------------------------------------ =\u0026gt; ( n : 3 + n ) 3 ---^^^^^^^^^^^^^^^---------------------------------------- =\u0026gt; 3 + 3 ---^^^^^-------------------------------------------------- =\u0026gt; 6 Ob die Auswertung tatsächlich genau in dieser Reihenfolge stattfindet, weiß ich nicht. Es gibt da verschiedene Möglichkeiten. Relevant ist für uns nur, dass die Auswertung schrittweise erfolgt.\nWenn das nun der Teilausausdruck e1 im Ausdruck builtins.seq e1 e2 wäre, würde builtins.seq nicht garantieren, dass das ganze vor der Auswertung von e2 vollständig auf den Wert 6 reduziert wird. builtins.seq würde lediglich gewährleisten, dass e1 auf der ersten Ebene strikt ausgewertet wird, also vielleicht bis f3 ( f2 ( 1 + 0 ) ). Damit wäre die Funktion f1 schon vollständig abgefrühstückt, aber wenn sich in f2 oder f3 noch irgendwelche externen Nebeneffekte verbergen würden, wäre durch builtins.seq nicht sichergestellt, dass diese Effekte vor der Auswertung von e2 eintreten. Genau das war gemeint mit der Feststellung, builtins.seq würde e1 nur oberflächlich strikt auswerten.\nIch möchte hier anmerken, dass ich mich mit dieser Erläuterung recht weit aus dem Fenster lehne. Ich weiß nicht, wie der Nix Interpreter tatsächlich auswertet und ob meine Charakterisierung einer nur oberflächlich strikten Auswertung den Nagel auf den Kopf trifft. Ich hoffe, dass es hier kein fundamentales Missverständnis meinerseits gibt, das diese Erläuterung zu Stuss macht. In jedem Fall ist das gegenwärtig mein mentales Modell dieser Sache.\nWenn e1 eine Prozedur wie fetchGit ist, die direkt einen externen Nebeneffekt erzeugt, genügt die oberflächlich strikte Auswertung durch builtins.seq, aber wenn ein komplexer Ausdruck vollständig, also in voller Tiefe, strikt ausgewertet werden soll, muss dafür builtins.deepSeq verwendet werden.\nMeine Motivation, dafür ein gutes Beispiel zu finden, ist bei Null, denn ich habe noch reichlich Built-ins vor mir. Vielleicht ergänze ich später eins.\nbuiltins.div # Die Funktion hinter dem Divisionsoperator /, den wir schon weiter oben behandelt haben:\nnix-repl\u0026gt; builtins.div 7.0 2 3.5 nix-repl\u0026gt; builtins.div 7 2 3 builtins.elem # Prüft, ob ein Wert als Element in einer Liste enthalten ist:\nnix-repl\u0026gt; builtins.elem 3 [ 1 2 3 ] true nix-repl\u0026gt; builtins.elem 4 [ 1 2 3 ] false builtins.elemAt # Liefert das n-te Element einer Liste:\nnix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] 0 \u0026#34;a\u0026#34; nix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] 1 \u0026#34;b\u0026#34; nix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] 2 \u0026#34;c\u0026#34; nix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] 3 error: list index 3 is out of bounds Das hier ist aufschlussreich:\nnix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] -1 error: value is the partially applied built-in function \u0026#39;elemAt\u0026#39; while an integer was expected Die Fehlermeldung legt nahe, dass das Minuszeichen hier nicht als Vorzeichen sondern als Subtraktionsoperator interpretiert wird. Um das zu ändern, muss man Klammern setzen:\nnix-repl\u0026gt; builtins.elemAt [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] (-1) error: list index -1 is out of bounds Immer noch ein Fehler, aber ein besserer.\nbuiltins.fetchurl # Lädt etwas herunter, legt es im Nix Store ab und gibt den Pfad aus:\nnix-repl\u0026gt; builtins.fetchurl https://arxiv.org/pdf/2208.10524 [4.2 MiB DL]\u0026#34;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\u0026#34; Wenn man schon im Vorfeld den SHA-256 Hash der Datei kennt, kann man den Hash mit angeben und damit kryptografisch verifizieren, dass es die richtige Datei ist:\nnix-repl\u0026gt; builtins.fetchurl ... { url = https://arxiv.org/pdf/2208.10524 ; ... sha256 = \u0026#34;cbd791862a937ac2f823b81a771e63bdb5313d204e0011965c833ee3889fdc73\u0026#34; ; ... } \u0026#34;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\u0026#34; Wenn der Hash nicht passt, löst das einen Fehler aus:\nnix-repl\u0026gt; builtins.fetchurl ... { url = https://arxiv.org/pdf/2208.10524 ; ... sha256 = \u0026#34;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\u0026#34; ; ... } error: hash mismatch in file downloaded from \u0026#39;https://arxiv.org/pdf/2208.10524\u0026#39;: specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz got: sha256:0wywky4f6gl3bjb1202f40yk3ddxccg7f6mq4gwc4ylk5a393myb [4.2 MiB DL] Der Hash in der Fehlermeldung unterscheidet sich von dem Hash in der Anweisung:\nsha256 = \u0026#34;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\u0026#34; ; ... specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz Ich nehme an, dass Nix einfach nur eine andere Darstellung verwendet um die Hashes kompakter zu machen. Man sieht das auch daran, dass der Hash im Nix Store Pfad ein anderer ist. Es wäre gut, zu wissen, welcher Hash und welche Darstellung das genau ist, aber darum kümmere ich mich später.\nIch bin mir gar nich sicher, ob Nix die Datei jetzt noch einmal heruntergeladen hat oder einfach die bereits heruntergeladene Datei wiederverwendet hat. Also würde ich gern die Datei aus dem Store löschen und dann noch einmal herunterladen. Wie geht das? So:\n$ nix-store --delete /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524 Aber Achtung: Bevor man die Datei aus dem Store löschen kann, muss man die Nix Repl terminieren. Solange die Repl noch läuft, verweigert Nix das Löschen, weil die Datei noch in Verwendung ist.\nIch lade die Datei also noch einmal mit einem falschen Hash herunter:\nnix-repl\u0026gt; builtins.fetchurl ... { url = https://arxiv.org/pdf/2208.10524 ; ... sha256 = \u0026#34;ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\u0026#34; ; ... } error: hash mismatch in file downloaded from \u0026#39;https://arxiv.org/pdf/2208.10524\u0026#39;: specified: sha256:1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz got: sha256:0wywky4f6gl3bjb1202f40yk3ddxccg7f6mq4gwc4ylk5a393myb [4.2 MiB DL] n Die finale Ausgabe stimmt überein, aber die Ausführung hat deutlich länger gedauert, weil Nix die Datei wirklich ein weiteres Mal heruntergeladen hat.\nMit builtins.fetchurl haben wir also die Möglichkeit, beliebige Dateien aus dem Netz herunterzuladen und die Echtheit dieser Dateien durch Angabe eines SHA-256 Hashes abzusichern. Das bedeutet, dass wir Dateien, deren Hash wir bereits kennen, aus beliebigen Quellen herunterladen können, ohne uns Sorgen darüber machen zu müssen, dass vielleicht jemand diese Dateien ohne unser Wissen verändert haben könnte. Das ist großartig! Nix ist ein System für die Verwaltung von Softwarepaketen, aber auch jenseits davon fallen mir für so etwas viele Einsatzmöglichkeiten ein.\nbuiltins.filter # Bereinigt eine Liste um alle Elemente, denen ein bestimmtes Prädikat fehlt:\nnix-repl\u0026gt; isEven = n : n / 2 == n / 2.0 nix-repl\u0026gt; builtins.filter isEven ... [ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ] [ 2 4 6 8 10 12 14 16 ] builtins.filterSource # Damit kann man Quellen in den Nix Store übertragen und dabei gewisse Dateien herausfiltern. Näher will ich das hier nicht betrachten. Die Dokumentation enthält eine Warnung, die man vor dem Gebrauch lesen und verstehen sollte.\nbuiltins.findFile # Weder in der Nix Repl noch im Handbuch dokumentiert.\nbuiltins.floor # Liefert für eine Zahl x die nächste Ganzzahl n sodass x \u0026gt;= n:\nnix-repl\u0026gt; builtins.floor 1.5 1 nix-repl\u0026gt; builtins.floor 1 1 builtins.foldl' # Damit kann man eine Liste von Werten sozusagen \u0026ldquo;zusammenfalten\u0026rdquo; auf einen einzigen Wert, indem man sukzessive von links nach rechts eine Funktion darauf anwendet, die jeweils zwei Werte mit einander kombiniert. Man muss einen Startwert mit übergeben. Ausgehend von diesem Startwert werden sukzessive die Elemente der Liste eingesammelt und mit dem bisherigen Zwischenergebnis kombiniert.\nHier wird eine Liste von Zahlen via builtins.add mit dem Startwert 0 zusammengefaltet:\nnix-repl\u0026gt; builtins.foldl\u0026#39; builtins.add 0 [ 1 2 3 4 5 6 ] 21 Das entspricht einer Verallgemeinerung der zweiwertigen Addition auf beliebig viele Werte. Mit builtins.foldl' lassen sich viele zweiwertige Funktionen auf natürliche Weise verallgemeinern auf beliebig viele Werte. Das setzt natürlich voraus, dass es zu den Werten, auf denen man operiert einen neutralen Wert gibt, also eine Entsprechung zur Null bei den Zahlen. Mathematisch ist so eine Struktur artikuliert im algebraischen Begriff eines Monoiden. Damit muss man sich aber nicht unbedingt befassen: in der Praxis kann man auch einfach ein paar Werte mit builtins.foldl' zusammenstauchen, ohne sich vorher Gedanken darüber zu machen, ob man wirklich eine Null zur Verfügung hat.\nDas zweite l in foldl steht für left, weil von rechts nach links gefaltet wird. Nix stellt nur diese eine Funktion als Built-in zur Verfügung, aber im Allgemeinen gibt es auch Faltungsfunktionen die von links nach rechts falten. Die heißen dann typischerweise foldr. Bei der Addition macht das keinen Unterschied, aber bei Funktionen, die nicht kommutativ sind ,bei denen also das Ergebnis von der Reihenfolge der beiden Argumente abhängt, hängt auch das Ergebnis einer Faltung davon ab, in welche Richtung gefaltet wird.\nDas abschließende Hochkomma im Namen builtins.foldl' soll anzeigen, dass diese Funktion strikt ausgewertet wird. Ich bin weiter oben darauf eingegangen, dass Nix standardmäßig verzögert auswertet und dass man in manchen Fällen lieber eine strikte Auswertung haben möchte. Das hier ist ein solcher Fall. Das Hochkomma ist nur eine Namenskonvention, die warscheinlich daher rührt, dass man sich hier recht stark an Haskell orientiert. In Haskell wertet die foldl Funktion aus der Standardbibliothek verzögert aus. Daneben gibt es auch eine mit Hochkomma markierte foldl' Funktion, die strikt auswertet. In der Praxis will man eigentlich immer eine strikte Faltung nach links, also wäre es vielleicht besser gewesen, die strikte Variante foldl (ohne Hochkomma) zu nennen. Schade, dass Nix sich an dieser ungünstigen Konvention orientiert, zumal ohnehin nur diese eine Faltungsfunktion als Built-in mitgeliefert wird.\nbuiltins.fromJSON # Parst und überführt JSON-Werte in Nix-Werte:\nnix-repl\u0026gt; builtins.fromJSON \u0026#34;{ \\\u0026#34;a\\\u0026#34; : 1 , \\\u0026#34;b\\\u0026#34; : 2 , \\\u0026#34;c\\\u0026#34; : 3 }\u0026#34; { a = 1; b = 2; c = 3; } nix-repl\u0026gt; builtins.fromJSON \u0026#34;[ 1, 2, 3 ]\u0026#34; [ 1 2 3 ] nix-repl\u0026gt; builtins.fromJSON \u0026#34;123.456\u0026#34; 123.456 nix-repl\u0026gt; builtins.fromJSON \u0026#34;\\\u0026#34;asdf\\\u0026#34;\u0026#34; \u0026#34;asdf\u0026#34; builtins.functionArgs # Nimmt eine Funktion entgegen und liefert ein Set mit den Namen ihrer Parameter als Schlüssel. Die Werte geben für jeden Parameter Auskunft darüber, ob es zu ihm einen Standardwert gibt:\nnix-repl\u0026gt; builtins.functionArgs ( { x , y ? 123 } : x + y ) { x = false; y = true; } Das Fragezeichen ist neue Syntax für mich. Ziemlich weit am Anfang dieses Dokumentes hatte ich Set Patterns erwähnt, die man verwenden kann, um benannte Funktionsparameter aufzuschreiben:\nnix-repl\u0026gt; ({a,b} : a + b) { a = 5 ; b = 6 ; } 11 Offenbar kann man mit dem Fragezeichen Standardargumente festhalten:\nnix-repl\u0026gt; ({a?5,b?6} : a + b) {} 11 nix-repl\u0026gt; ({a?5,b?6} : a + b) { a = 11 ; } 17 nix-repl\u0026gt; ({a?5,b?6} : a + b) { b = 12 ; } 17 nix-repl\u0026gt; ({a?5,b?6} : a + b) { a = 11 ; b = 12 ; } 23 Die sinnvolle Verwendung von builtins.functionArgs setzt natürlich voraus, dass eine Funktion mit benannten Parametern via Set Patterns aufgeschrieben worden ist. Für reine Lambda-Funktionen liefert builtins.functionArgs immer ein leeres Set:\nnix-repl\u0026gt; builtins.functionArgs ( a : b : a + b ) { } builtins.genList # builtins.genlist f n erzeugt eine Liste der Länge n, wobei die Funktion f die jeweiligen Elemente aus den jeweiligen Indizes berechnet:\nnix-repl\u0026gt; builtins.genList ( x : -x ) 4 [ 0 -1 -2 -3 ] nix-repl\u0026gt; builtins.genList ( x : 1.0/(x+1) ) 4 [ 1 0.5 0.333333 0.25 ] builtins.genericClosure # Das ist eine eigenartig spezifische und zugleich eigenartig allgemeine Funktion! Sie erinnert mich ein bisschen an das Märchen vom süßen Brei. Ich würde wirklich gern wissen, wofür sie gedacht ist. Ich erkenne darin jedenfalls keine so klare und universell brauchbare Abstraktion wie map oder filter oder foldl.\nbuiltins.genericClosure nimmt ein Set mit den Schlüsseln startSet und operator entgegen. startSet ist eine Liste mit Sets. operator ist eine Funktion, die auf einem Set operiert und daraus eine Liste von weiteren Sets erzeugt. builtins.genericClosure verwendet ausgehend von der startSet Liste die operator Funktion um rekursiv aus den bestehenden Sets weitere Sets zu berechnen. Alle hier erwähnten Sets (abgesehen von dem äußeren) müssen einen Schlüssel key enthalten. Alle Sets, mit einem key Wert, der schon einmal aufgetaucht ist, werden verworfen. Sobald keine Sets mit neuen key Werten hinzukommen, endet die Rekursion.\nDas ist ziemlich kompliziert. Hier sind ein paar Beispiele. Zunächst der einfachste Fall:\nnix-repl\u0026gt; builtins.genericClosure ... { startSet = [] ; ... operator = s : [] ; ... } [ ] Wir füllen startSet mit ein paar Sets:\nnix-repl\u0026gt; builtins.genericClosure ... { startSet = ... [ { key = 5 ; } ... { key = 6 ; } ... { key = 7 ; } ... ] ; ... operator = s : [] ; ... } [ { ... } { ... } { ... } ] Die Auslassungpunkte kommen daher, dass die Nix Repl beim Auswerten und beim Ausgeben der Ergebnisse maximal eine Ebene in die Tiefe geht. Bisher bin ich darauf nicht eingegangen, aber das ist schon einmal vorgekommen, nämlich im Abschnitt Sets (Mengen) wo ich die Kurznotation für verschachtelte Sets einführe. Man erhält die Auslassungspunkte schon wenn man eine Liste in eine Liste steckt:\nnix-repl\u0026gt; [[]] [ [ ... ] ] Die innere Liste ist leer, aber der Interpreter schaut gar nicht erst hinein sondern gibt sie gleich mit den Auslassungspunkten aus.\nMan kann die Nix Repl veranlassen, einen Ausdruck in voller Tiefe auszuwerten und das Ergebnis in voller Tiefe auszugeben. Dafür muss man dem auszuwertenden Ausdruck die Repl-Anweisung :p voranstellen. Damit können wir uns wieder builtins.genericClosure zuwenden:\nnix-repl\u0026gt; :p builtins.genericClosure ... { startSet = ... [ { key = 5 ; } ... { key = 6 ; } ... { key = 7 ; } ... ] ; ... operator = s : [] ; ... } [ { key = 5; } { key = 6; } { key = 7; } ] Dass Sets, deren key schon einmal vorgekommen ist, verworfen werden, gilt schon für die Sets in der startSet Liste:\nnix-repl\u0026gt; :p builtins.genericClosure ... { startSet = ... [ { key = 5 ; } ... { key = 6 ; } ... { key = 7 ; } ... { key = 5 ; } ... ] ; ... operator = s : [] ; ... } [ { key = 5; } { key = 6; } { key = 7; } ] Um die Wirkung der operator Funktion zu demonstrieren, inkrementieren wir einfach die key Werte. Damit built.genericClosure trotzdem terminiert, müssen wir das irgendwo deckeln. Ich schlage vor, wir belassen es bei key \u0026lt; 10:\nnix-repl\u0026gt; :p builtins.genericClosure ... { startSet = ... [ { key = 5 ; } ... { key = 6 ; } ... { key = 7 ; } ... { key = 5 ; } ... ] ; ... operator = s : ... [ { key = ... if s.key \u0026lt; 9 ... then s.key + 1 ... else s.key ; ... } ... ] ; ... } [ { key = 5; } { key = 6; } { key = 7; } { key = 8; } { key = 9; } ] Das heißt, wir inkrementieren den key Wert so lange er kleiner als 9 ist. Das Set mit key = 9 wird noch erzeugt, aber darüber kommt nichts mehr. Die Ausgabe ist so wie ich es erwartet habe. Ich glaube, ich habe damit vollständig erfasst, was builtins.genericClosure macht. Einen guten Anwendungsfall dafür habe ich nicht, aber zumindest den vagen Eindruck, dass man damit etwas nützliches machen kann, vielleicht irgend etwas in Richtung transitiver Hüllen.\nbuiltins.getAttr # Liefert aus einem Set den Wert zu einem Schlüssel:\nnix-repl\u0026gt; builtins.getAttr \u0026#34;foo\u0026#34; { foo = 123 ; } 123 Wenn es den Schlüssel nicht gibt, löst das einen Fehler aus:\nnix-repl\u0026gt; builtins.getAttr \u0026#34;bar\u0026#34; { foo = 123 ; } error: attribute \u0026#39;bar\u0026#39; missing for call to \u0026#39;getAttr\u0026#39; Das selbe kann man natürlich schon mit dem . Operator machen:\nnix-repl\u0026gt; s = { foo = 123 ; } nix-repl\u0026gt; s.foo 123 Aber es gibt einen Unterschied: builtins.getAttr nimmt den Schlüssel als String. Dadurch kann man den Schlüssel dynamisch konstruieren:\nnix-repl\u0026gt; s = { foo = 123 ; } nix-repl\u0026gt; builtins.getAttr ( \u0026#34;f\u0026#34; + \u0026#34;o\u0026#34; + \u0026#34;o\u0026#34; ) s 123 Update: der . Operator akzeptiert auch Strings:\nnix-repl\u0026gt; { foo = 123 ; }.\u0026#34;foo\u0026#34; 123 Aber dynamisch konstruieren kann man den Schlüssel trotzdem nicht:\nnix-repl\u0026gt; { foo = 123 ; }.( \u0026#34;f\u0026#34; + \u0026#34;o\u0026#34; + \u0026#34;o\u0026#34; ) error: syntax error, unexpected \u0026#39;(\u0026#39;, ... nix-repl\u0026gt; { foo = 123 ; }.( \u0026#34;foo\u0026#34; ) error: syntax error, unexpected \u0026#39;(\u0026#39;, ... builtins.getContext # Weder in der Nix Repl noch im Handbuch dokumentiert.\nbuiltins.getEnv # Liefert den Wert einer Umgebungsvariable als String:\nnix-repl\u0026gt; builtins.getEnv \u0026#34;HOME\u0026#34; \u0026#34;/home/aramis\u0026#34; Für fehlende Umgebungsvariable wird der leere String wird der leere String gegeben:\nnix-repl\u0026gt; builtins.getEnv \u0026#34;sa0iboojav9ood5C\u0026#34; \u0026#34;\u0026#34; builtins.getFlake # Lädt eine Nix Flake herunter und gibt ihre Attribute zusammen mit ein paar Metadaten aus.\nFlakes sind ein alternativer Mechanismus um Abhängigkeiten zu beschreiben und Software in den Nix Store herunterzuladen. Nix Channels folgen in der Handhabung dem typischen Paketverwaltungsmodell von Linux Distros: Es gibt Kanäle, in denen versionierte Softwarepakete verfügbar sind, die man bei Bedarf herunterladen kann. Um seine Software auf dem neusten Stand zu halten, ruft man zunächst aus seinen Kanälen Informationen zu den aktuellen Versionen ab und installiert dann Updates für die Software, die nicht mehr auf dem neusten Stand ist.\nSo sieht das für die Debian/Ubuntu Paketverwaltung aus:\n$ apt update # Aktualisiere Kanäle $ apt upgrade # Aktualisiere Softwarepakete So sieht das für Nix aus:\n$ nix-channel --update # Aktualisiere Kanäle $ nix-env --upgrade # Aktualisiere Softwarepakete Mit Debian/Ubuntu verwendet man apt für beide Schritte. Mit Nix verwendet man im ersten Schritt nix-channel und im zweiten Schritt nix-env, aber an den Flags sieht man schon, mit wes Geistes Kind man es hier zu tun hat.\nIm Unterschied dazu, orientieren sich Flakes an Paketverwaltungen wie Cargo (Rust) oder NPM (JS). Es gibt keine Kanäle. Man deklariert die Abhängigkeiten einer Software als Git Repositories in einer flake.nix Datei. Während der Installation der Abhängigkeiten wird eine flake.lock Datei erzeugt, welche die Hashes der verwendeten Git Commits protokolliert und dadurch die Abhängigkeiten sozusagen einfriert.\nFlakes sind noch als experimentell markiert und müssen in einer Konfigurationsdatei aktiviert werden bevor sie verwendet werden können:\n$ echo experimental-features = nix-command flakes \u0026gt;\u0026gt; ~/.config/nix/nix.conf Ich habe mir, über das hier aufgeschriebene hinaus, Flakes noch nicht genauer angeschaut.\nbuiltins.groupBy # builtings.groupBy f ls gruppiert die Liste ls anhand der Funktion f:\nnix-repl\u0026gt; isEven = n : n / 2 == n / 2.0 nix-repl\u0026gt; :p builtins.groupBy ... ( n : toString ( isEven n ) ) [ 1 2 3 4 5 6 7 8 9 ] { \u0026#34;\u0026#34; = [ 1 3 5 7 9 ]; \u0026#34;1\u0026#34; = [ 2 4 6 8 ]; } Dabei muss f stets einen String zurückgeben. Sonst funktioniert das nicht:\nnix-repl\u0026gt; :p builtins.groupBy isEven [ 1 2 3 4 5 6 7 8 9 ] error: value is a Boolean while a string was expected builtins.hasAttr # Prüft ob ein Schlüssel in einem Set enthalten ist:\nnix-repl\u0026gt; builtins.hasAttr \u0026#34;foo\u0026#34; {} false nix-repl\u0026gt; builtins.hasAttr \u0026#34;foo\u0026#34; { foo = 123 ; } true Offenbar gibt es auch einen ? Operator, der dasselbe macht:\nnix-repl\u0026gt; {} ? \u0026#34;foo\u0026#34; false nix-repl\u0026gt; { foo = 123 ; } ? \u0026#34;foo\u0026#34; true Der ? Operator kann den zu prüfenden Schlüssel nicht nur als String sondern auch als einfachen Bezeichner verarbeiten:\nnix-repl\u0026gt; { foo = 123 ; } ? foo true nix-repl\u0026gt; {} ? foo false Der ? Operator hat die selbe Beschränkung wie der . Operator, nämlich dass der Schlüssel nicht dynamisch erzeugt werden kann:\nnix-repl\u0026gt; { foo = 123 ; } ? ( \u0026#34;f\u0026#34; + \u0026#34;o\u0026#34; + \u0026#34;o\u0026#34; ) error: syntax error, unexpected \u0026#39;(\u0026#39;, ... nix-repl\u0026gt; { foo = 123 ; } ? ( \u0026#34;foo\u0026#34; ) error: syntax error, unexpected \u0026#39;(\u0026#39;, ... builtins.hasContext # Weder in der Nix Repl noch im Handbuch dokumentiert.\nbuiltins.hashFile # Erzeugt einen Hash Wert aus einer Datei. Erwartet werden zwei Argumente. Das erste Argument ist der Hash-Algorithmus. Möglich sind \u0026quot;md5\u0026quot;, \u0026quot;sha1\u0026quot;, \u0026quot;sha256\u0026quot; und \u0026quot;sha512\u0026quot;. Das zweite Argument ist der Pfad zur Datei. Der Pfad kann als Nix Pfad oder als String übergeben werden.\nnix-repl\u0026gt; builtins.hashFile \u0026#34;md5\u0026#34; ... /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524 \u0026#34;ffab34ab46902e10183dc2a065e50ebd\u0026#34; nix-repl\u0026gt; builtins.hashFile \u0026#34;md5\u0026#34; ... \u0026#34;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\u0026#34; \u0026#34;ffab34ab46902e10183dc2a065e50ebd\u0026#34; nix-repl\u0026gt; builtins.hashFile \u0026#34;sha1\u0026#34; ... /nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524 \u0026#34;95936f2f3d784c7a90623acfbb9d093384f5a6a2\u0026#34; nix-repl\u0026gt; builtins.hashFile \u0026#34;sha1\u0026#34; ... \u0026#34;/nix/store/97ggi3ryxkvdljycw05nq82bgs6kdxcx-2208.10524\u0026#34; \u0026#34;95936f2f3d784c7a90623acfbb9d093384f5a6a2\u0026#34; Die Funktion verarbeitet beliebige Pfade, auch außerhalb des Nix Store. Leider weiß ich jetzt immer noch nicht, was es mit dem Hash 97ggi3ryxkvdljycw05nq82bgs6kdxcx im Store Path auf sich hat.\nbuiltins.hashString # Erzeugt einen Hash Wert aus einem String. Erwartet werden zwei Argumente. Das erste Argument ist der Hash-Algorithmus. Möglich sind \u0026quot;md5\u0026quot;, \u0026quot;sha1\u0026quot;, \u0026quot;sha256\u0026quot; und \u0026quot;sha512\u0026quot;. Das zweite ist der zu verarbeitende String:\nnix-repl\u0026gt; builtins.hashString \u0026#34;md5\u0026#34; \u0026#34;foobar\u0026#34; \u0026#34;3858f62230ac3c915f300c664312c63f\u0026#34; builtins.head # Liefert das erste Element einer Liste:\nnix-repl\u0026gt; builtins.head [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] \u0026#34;a\u0026#34; Wenn man sich das ganze im mathematichen Sinne als eine Abbildung von der Menge aller Listen auf die Menge aller möglichen Listenelemente vorzustellen versucht, stellt man fest, dass es in der Sprechweise der Schulmathematik eine mögliche Definitionslücke gibt: nämlich bei der leeren Liste:\nnix-repl\u0026gt; builtins.head [] error: list index 0 is out of bounds Die Fehlermeldung lässt vermuten, dass builtins.head ls intern in builtins.elemAt ls 0 übersetzt wird. Jedenfalls löst die Funktion für die leere Liste einen Fehler aus. Es ist strenggenommen nur eine partielle Funktion. Das ist schade, wobei ich hier noch mehr Verständnis dafür habe als bei der head Funktion aus der Haskell Standardbibliothek, die das gleiche Problem hat.\nbuiltins.intersectAttrs # Erwartet zwei Sets und liefert ein Set mit den Schlüssel-Wert-Paaren aus dem zweiten Set, deren Schlüssel auch im ersten Set vorkommen:\nnix-repl\u0026gt; builtins.intersectAttrs ... { a = 1 ; b = 2 ; } { b = 3 ; c = 4 ; } { b = 3; } builtins.isAttrs # Prüft, ob es sich bei einem Wert um ein Set handelt:\nnix-repl\u0026gt; builtins.isAttrs {} true nix-repl\u0026gt; builtins.isAttrs 123 false builtins.isBool # Prüft, ob es sich bei einem Wert um einen boolschen Wert handelt:\nnix-repl\u0026gt; builtins.isBool false true nix-repl\u0026gt; builtins.isBool 123 false builtins.isFloat # Prüft, ob es sich bei einem Wert um eine Fließkommazahl handelt:\nnix-repl\u0026gt; builtins.isFloat 123.456 true nix-repl\u0026gt; builtins.isFloat 123 false builtins.isFunction # Prüft, ob es sich bei einem Wert um eine Funktion handelt:\nnix-repl\u0026gt; builtins.isFunction ( x : x ) true nix-repl\u0026gt; builtins.isFunction 123 false builtins.isInt # Prüft, ob es sich bei einem Wert um eine Ganzzahl handelt:\nnix-repl\u0026gt; builtins.isInt 123 true nix-repl\u0026gt; builtins.isInt \u0026#34;123\u0026#34; false builtins.isList # Prüft, ob es sich bei einem Wert um eine Liste handelt:\nnix-repl\u0026gt; builtins.isList [] true nix-repl\u0026gt; builtins.isList 123 false builtins.isPath # Prüft, ob es sich bei einem Wert um einen Nix Pfad handelt:\nnix-repl\u0026gt; builtins.isPath ./. true nix-repl\u0026gt; builtins.isPath 123 false builtins.isString # Prüft, ob es sich bei einem Wert um eine Zeichenkette (String) handelt:\nnix-repl\u0026gt; builtins.isString \u0026#34;\u0026#34; true nix-repl\u0026gt; builtins.isString 123 false builtins.langVersion # Undokumentiert. Wahrscheinlich ist Nix (die Sprache) irgendwie versioniert:\nnix-repl\u0026gt; builtins.langVersion 6 builtins.length # Liefert die Länge einer Liste:\nnix-repl\u0026gt; builtins.length [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; ] 3 builtins.lessThan # Die Funktion hinter dem \u0026lt; Operator:\nnix-repl\u0026gt; builtins.lessThan 3 4 true nix-repl\u0026gt; builtins.lessThan 4 3 false builtins.listToAttrs # Verarbeitet eine Liste von Sets mit Schlüsseln name und value zu einem Set mit entsprechenden Schlüssel-Wert-Paaren:\nnix-repl\u0026gt; builtins.listToAttrs ... [ { name = \u0026#34;foo\u0026#34; ; value = 123 ; } ... { name = \u0026#34;bar\u0026#34; ; value = 456 ; } ... ] { bar = 456; foo = 123; } builtins.mapAttrs # Eine Map-Funktion für Sets, die auf den Werten operiert und dabei die Schlüssel berücksichtigen kann:\nnix-repl\u0026gt; builtins.mapAttrs ... ( k : v : k + \u0026#34;:\u0026#34; + builtins.toString v ) ... { a = 1 ; b = 2 ; c = 3 ; } { a = \u0026#34;a:1\u0026#34;; b = \u0026#34;b:2\u0026#34;; c = \u0026#34;c:3\u0026#34;; } builtins.match # Erwartet einen regulären Ausdruck und einen String. Der reguläre Ausdruck kann RegEx-Gruppen enthalten. Als Ergebnis liefert builtins.match eine Liste der Übereinstimmungen für diese RegEx-Gruppen. Ohne RegEx-Gruppen ist das Ergebnis natürlich die leere Liste (bei Übereinstimmung). Wenn der String nicht auf den regulären Ausdruck passt, ist das Ergebnis null:\nnix-repl\u0026gt; builtins.match \u0026#34;foo\u0026#34; \u0026#34;bar\u0026#34; null nix-repl\u0026gt; builtins.match \u0026#34;foo\u0026#34; \u0026#34;foo\u0026#34; [ ] nix-repl\u0026gt; builtins.match \u0026#34;a(b)c(d)e\u0026#34; \u0026#34;abcde\u0026#34; [ \u0026#34;b\u0026#34; \u0026#34;d\u0026#34; ] RegEx-Gruppen sind Teile eines regulären Ausdrucks, die durch Klammern hervorgehoben sind. Man verwendet sie, um nicht nur zu prüfen ob ein String auf einen regulären Ausdruck passt, sondern auch Teile aus dem String zu extrahieren. Beispielsweise könnte man einen regulären Ausdruck für postalische Adressen konstruieren, der die Straße, die Hausnummer, die Postleitzahl und die Stadt extrahiert.\nbuiltins.mul # Die Funktion hinter dem * Operator:\nnix-repl\u0026gt; builtins.mul 3 5 15 builtins.nixPath # Weder in der Nix Repl noch im Handbuch dokumentiert.\nnix-repl\u0026gt; :p builtins.nixPath [ { path = \u0026#34;/home/aramis/.nix-defexpr/channels\u0026#34;; prefix = \u0026#34;\u0026#34;; } ] builtins.nixVersion # Liefert die Nix Versionsnummer:\nnix-repl\u0026gt; builtins.nixVersion \u0026#34;2.10.3\u0026#34; Die Nix Versionsnummer wird auch ausgegeben wenn man die Repl startet:\n$ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; builtins.parseDrvName # Zerlegt einen Paketbezeichner der Form \u0026lt;Name\u0026gt;-\u0026lt;Version\u0026gt; in den Namen und die Version des Pakets auf. Das Ergebnis wird als Set mit den Schlüsseln name und version gegeben:\nnix-repl\u0026gt; builtins.parseDrvName \u0026#34;nix-0.12pre12876\u0026#34; { name = \u0026#34;nix\u0026#34;; version = \u0026#34;0.12pre12876\u0026#34;; } Die beiden Teile müssen durch einen Bindestrich getrennt sein. Die Version muss mit Ziffern beginnen. Sonst ist mindestens einer der beiden Werte der leere String:\nnix-repl\u0026gt; builtins.parseDrvName \u0026#34;\u0026#34; { name = \u0026#34;\u0026#34;; version = \u0026#34;\u0026#34;; } nix-repl\u0026gt; builtins.parseDrvName \u0026#34;foo123\u0026#34; { name = \u0026#34;foo123\u0026#34;; version = \u0026#34;\u0026#34;; } nix-repl\u0026gt; builtins.parseDrvName \u0026#34;foo-bar\u0026#34; { name = \u0026#34;foo-bar\u0026#34;; version = \u0026#34;\u0026#34;; } nix-repl\u0026gt; builtins.parseDrvName \u0026#34;foo-1bar\u0026#34; { name = \u0026#34;foo\u0026#34;; version = \u0026#34;1bar\u0026#34;; } builtins.partition # Trennt die Spreu vom Weizen:\nnix-repl\u0026gt; :p builtins.partition ( n : n \u0026gt; 3 ) [ 1 2 3 4 5 6 ] { right = [ 4 5 6 ]; wrong = [ 1 2 3 ]; } builtins.path # Fügt Daten zum Nix Store hinzu. Die funktion nimmt ein Set als Argument entgegen. Nur der Schlüssel path ist Pflicht. Hier sind alle Schlüssel:\npath: der Pfad zu den Daten name: der Pfadname im Nix Store filter: die Funktion; filtert unerwünschte Unterpfade heraus recursive: false: fügt den Pfad mit einem flachen Hash zum Store hinzu true: fügt den Pfad mit einem Hash der NAR Serialisierung zum Store hinzu sha256: der zu erwartende Hash für die Daten in path NAR steht für Nix Archive. Das ist ein Serialisierungsformat für Dateisystemobjekte (i.e. Dateien, Verzeichnisse, Symlinks). NAR ist vergleichbar mit Archivformaten wie TAR und ZIP. Allerdings kann es bei diesen Formaten für ein und dasselbe Objekt mehrere gültige Serialisierungen geben, zum Beispiel weil die Reihenfolge der Serialisierung von Verzeichnisinhalten nicht definiert ist oder weil eine variable Menge an Füllbytes zwischen Segmenten der Serialisierung zulässig ist oder weil auch Zeitstempel mit in die Serialisierung aufgenommen werden. Die Beziehung zwischen einem serialisierten Objekt und den Bytes seiner Serialisierung hat somit keinen Abbildungscharakter. Das macht diese Archivformate unbrauchbar wenn der Hash der Serialisierung als Hash für das serialisierte Objekt geeignet sein soll. NAR ist speziell dafür entwickelt worden, Dateisystemobjekte für das Hashing zu serialisieren und lässt keinen Implementierungsspielraum, der die Serialisierung eines Dateisystemobjektes in verschiedene Bytefolgen gestatten würde. (Quelle: https://edolstra.github.io/pubs/phd-thesis.pdf)\nFügt Daten zum Nix Store hinzu. Die funktion nimmt ein Set als Argument entgegen. Nur der Schlüssel path ist Pflicht. Hier sind alle Schlüssel:\npath: der Pfad zu den Daten name: der Pfadname im Nix Store filter: die Funktion; filtert unerwünschte Unterpfade heraus recursive: false: fügt den Pfad mit einem flachen Hash zum Store hinzu true: fügt den Pfad mit einem Hash der NAR Serialisierung zum Store hinzu sha256: der zu erwartende Hash für die Daten in path NAR steht für Nix Archive. Das ist ein Serialisierungsformat für Dateisystemobjekte (i.e. Dateien, Verzeichnisse, Symlinks). NAR ist vergleichbar mit Archivformaten wie TAR und ZIP. Allerdings kann es bei diesen Formaten für ein und dasselbe Objekt mehrere gültige Serialisierungen geben, zum Beispiel weil die Reihenfolge der Serialisierung von Verzeichnisinhalten nicht definiert ist oder weil eine variable Menge an Füllbytes zwischen Segmenten der Serialisierung zulässig ist oder weil auch Zeitstempel mit in die Serialisierung aufgenommen werden. Die Beziehung zwischen einem serialisierten Objekt und den Bytes seiner Serialisierung hat somit keinen Abbildungscharakter. Das macht diese Archivformate unbrauchbar wenn der Hash der Serialisierung als Hash für das serialisierte Objekt geeignet sein soll. NAR ist speziell dafür entwickelt worden, Dateisystemobjekte für das Hashing zu serialisieren und lässt keinen Implementierungsspielraum, der die Serialisierung eines Dateisystemobjektes in verschiedene Bytefolgen gestatten würde. (Quelle: https://edolstra.github.io/pubs/phd-thesis.pdf)\nbuiltins.pathExists # Prüft, ob ein Pfad im lokalen Dateisystem existiert:\nnix-repl\u0026gt; builtins.pathExists /home/aramis true nix-repl\u0026gt; builtins.pathExists /home/foo false Kann auch Strings verarbeiten:\nnix-repl\u0026gt; builtins.pathExists \u0026#34;/\u0026#34; true Oben hatte ich ein paar Prozeduren aufgelistet, die Nix impure machen. Diese hier (und die nachfolgenden) hätte man auch mit auflisten können.\nPrüft, ob ein Pfad im lokalen Dateisystem existiert:\nnix-repl\u0026gt; builtins.pathExists /home/aramis true nix-repl\u0026gt; builtins.pathExists /home/foo false Kann auch Strings verarbeiten:\nnix-repl\u0026gt; builtins.pathExists \u0026quot;/\u0026quot; true Oben hatte ich ein paar Prozeduren aufgelistet, die Nix impure machen. Diese hier (und die nachfolgenden) hätte man auch mit auflisten können.\nbuiltins.readDir # Liefert für einen Verzeichnispfad ein Set mit den Verzeichnisinhalten als Schlüssel und den jeweiligen Dateitypen als Werte:\nnix-repl\u0026gt; builtins.readDir /home { aramis = \u0026#34;directory\u0026#34;; } Die möglichen Werte für den Dateityp sind \u0026quot;regular\u0026quot;, \u0026quot;directory\u0026quot;, \u0026quot;symlink\u0026quot; und \u0026quot;unknown\u0026quot;.\nLiefert für einen Verzeichnispfad ein Set mit den Verzeichnisinhalten als Schlüssel und den jeweiligen Dateitypen als Werte:\nnix-repl\u0026gt; builtins.readDir /home { aramis = \u0026quot;directory\u0026quot;; } Die möglichen Werte für den Dateityp sind \u0026quot;regular\u0026quot;, \u0026quot;directory\u0026quot;, \u0026quot;symlink\u0026quot; und \u0026quot;unknown\u0026quot;.\nbuiltins.readFile # Liefert den Inhalt einer Datei als String:\n$ echo hallo \u0026gt; greeting.txt $ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; builtins.readFile ./greeting.txt \u0026#34;hallo\\n\u0026#34; Liefert den Inhalt einer Datei als String:\n$ echo hallo \u0026gt; greeting.txt $ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; builtins.readFile ./greeting.txt \u0026quot;hallo\\n\u0026quot; builtins.replaceStrings # Ersetzt alle Vorkommen eines Teilstrings:\nnix-repl\u0026gt; builtins.replaceStrings [ \u0026#34;o\u0026#34; ] [ \u0026#34;x\u0026#34; ] \u0026#34;foobar\u0026#34; \u0026#34;fxxbar\u0026#34; nix-repl\u0026gt; builtins.replaceStrings [ \u0026#34;o\u0026#34; \u0026#34;a\u0026#34; ] [ \u0026#34;x\u0026#34; \u0026#34;y\u0026#34; ] \u0026#34;foobar\u0026#34; \u0026#34;fxxbyr\u0026#34; Ersetzt alle Vorkommen eines Teilstrings:\nnix-repl\u0026gt; builtins.replaceStrings [ \u0026quot;o\u0026quot; ] [ \u0026quot;x\u0026quot; ] \u0026quot;foobar\u0026quot; \u0026quot;fxxbar\u0026quot; nix-repl\u0026gt; builtins.replaceStrings [ \u0026quot;o\u0026quot; \u0026quot;a\u0026quot; ] [ \u0026quot;x\u0026quot; \u0026quot;y\u0026quot; ] \u0026quot;foobar\u0026quot; \u0026quot;fxxbyr\u0026quot; builtins.sort # Sortiert eine Liste anhand einer Vergleichsfunktion:\nnix-repl\u0026gt; builtins.sort ... ( a : b : a \u0026lt; b ) ... [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ] [ 1 1 2 3 3 3 4 5 5 5 6 7 8 9 9 9 ] nix-repl\u0026gt; builtins.sort ... ( a : b : a \u0026gt; b ) ... [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ] [ 9 9 9 8 7 6 5 5 5 4 3 3 3 2 1 1 ] Sortiert eine Liste anhand einer Vergleichsfunktion:\nnix-repl\u0026gt; builtins.sort ( a : b : a \u0026lt; b ) [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ] [ 1 1 2 3 3 3 4 5 5 5 6 7 8 9 9 9 ] nix-repl\u0026gt; builtins.sort ( a : b : a \u0026gt; b ) [ 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 ] [ 9 9 9 8 7 6 5 5 5 4 3 3 3 2 1 1 ] builtins.split # Zerteilt einen String anhand eines regulären Ausdrucks in eine Liste. Alles, was auf den regulären Ausdruck passt, wird als Trennzeichen behandelt. Der reguläre Ausdruck kann RegEx-Gruppen enthalten. An jeder Trennstelle wird eine Liste mit den Übereinstimmungen für die RegEx-Gruppen an dieser Stelle in die Ergebnisliste aufgenommen. Ohne RegEx-Gruppen werden an den Trennstellen entsprechend leere Listen eingefügt:\nnix-repl\u0026gt; :p builtins.split \u0026#34;a\u0026#34; \u0026#34;bacadaeafagahai\u0026#34; [ \u0026#34;b\u0026#34; [ ] \u0026#34;c\u0026#34; [ ] \u0026#34;d\u0026#34; [ ] \u0026#34;e\u0026#34; [ ] \u0026#34;f\u0026#34; [ ] \u0026#34;g\u0026#34; [ ] \u0026#34;h\u0026#34; [ ] \u0026#34;i\u0026#34; ] nix-repl\u0026gt; builtins.split \u0026#34;a\u0026#34; \u0026#34;bcde\u0026#34; [ \u0026#34;bcde\u0026#34; ] Siehe builtins.match für mehr zu RegEx-Gruppen.\nZerteilt einen String anhand eines regulären Ausdrucks in eine Liste. Alles, was auf den regulären Ausdruck passt, wird als Trennzeichen behandelt. Der reguläre Ausdruck kann RegEx-Gruppen enthalten. An jeder Trennstelle wird eine Liste mit den Übereinstimmungen für die RegEx-Gruppen an dieser Stelle in die Ergebnisliste aufgenommen. Ohne RegEx-Gruppen werden an den Trennstellen entsprechend leere Listen eingefügt:\nnix-repl\u0026gt; :p builtins.split \u0026quot;a\u0026quot; \u0026quot;bacadaeafagahai\u0026quot; [ \u0026quot;b\u0026quot; [ ] \u0026quot;c\u0026quot; [ ] \u0026quot;d\u0026quot; [ ] \u0026quot;e\u0026quot; [ ] \u0026quot;f\u0026quot; [ ] \u0026quot;g\u0026quot; [ ] \u0026quot;h\u0026quot; [ ] \u0026quot;i\u0026quot; ] nix-repl\u0026gt; builtins.split \u0026quot;a\u0026quot; \u0026quot;bcde\u0026quot; [ \u0026quot;bcde\u0026quot; ] Siehe builtins.match für mehr zu RegEx-Gruppen.\nbuiltins.splitVersion # Teilt einen String, der eine (Software) Version darstellt, in seine Bestandteile auf. Ich bin mir nicht 100%ig sicher, aber ich denke, die Trennstellen sind Punkte ., Bindestriche - und Übergänge zwischen Ziffern und Buchstaben:\nnix-repl\u0026gt; builtins.splitVersion \u0026#34;a.b-c123e\u0026#34; [ \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; \u0026#34;123\u0026#34; \u0026#34;e\u0026#34; ] Teilt einen String, der eine (Software) Version darstellt, in seine Bestandteile auf. Ich bin mir nicht 100%ig sicher, aber ich denke, die Trennstellen sind Punkte ., Bindestriche - und Übergänge zwischen Ziffern und Buchstaben:\nnix-repl\u0026gt; builtins.splitVersion \u0026quot;a.b-c123e\u0026quot; [ \u0026quot;a\u0026quot; \u0026quot;b\u0026quot; \u0026quot;c\u0026quot; \u0026quot;123\u0026quot; \u0026quot;e\u0026quot; ] builtins.storeDir # Undokumentiert. Liefert den Pfad zum Nix Store als String:\nnix-repl\u0026gt; builtins.storeDir \u0026#34;/nix/store\u0026#34; Undokumentiert. Liefert den Pfad zum Nix Store als String:\nnix-repl\u0026gt; builtins.storeDir \u0026quot;/nix/store\u0026quot; builtins.storePath # Alles, was ein Programm benötigt, um gebaut zu werden, soll sich im Nix Store befinden. Entsprechend werden die Abhängigkeiten, die in Ableitungen (Derivations) deklariert sind, zunächst zum Nix Store hinzugefügt. Das geschieht normalerweise auch dann, wenn sich etwas schon im Nix Store befindet. Mit builtins.storePath kann man das vermeiden.\nAlles, was ein Programm benötigt, um gebaut zu werden, soll sich im Nix Store befinden. Entsprechend werden die Abhängigkeiten, die in Ableitungen (Derivations) deklariert sind, zunächst zum Nix Store hinzugefügt. Das geschieht normalerweise auch dann, wenn sich etwas schon im Nix Store befindet. Mit builtins.storePath kann man das vermeiden.\nbuiltins.stringLength # Liefert die Länge eines Strings:\nnix-repl\u0026gt; builtins.stringLength \u0026#34;asdf\u0026#34; 4 Liefert die Länge eines Strings:\nnix-repl\u0026gt; builtins.stringLength \u0026quot;asdf\u0026quot; 4 builtins.sub # Die Funktion hinter dem - Operator:\nnix-repl\u0026gt; builtins.sub 7 5 2 Die Funktion hinter dem - Operator:\nnix-repl\u0026gt; builtins.sub 7 5 2 builtins.substring # Selbsterklärend:\nnix-repl\u0026gt; builtins.substring 0 3 \u0026#34;nixos\u0026#34; \u0026#34;nix\u0026#34; Selbsterklärend:\nnix-repl\u0026gt; builtins.substring 0 3 \u0026quot;nixos\u0026quot; \u0026quot;nix\u0026quot; builtins.tail # Liefert eine Liste ohne das erste Element:\nnix-repl\u0026gt; builtins.tail [ 1 2 3 ] [ 2 3 ] nix-repl\u0026gt; builtins.tail [] error: \u0026#39;tail\u0026#39; called on an empty list Liefert eine Liste ohne das erste Element:\nnix-repl\u0026gt; builtins.tail [ 1 2 3 ] [ 2 3 ] nix-repl\u0026gt; builtins.tail [] error: 'tail' called on an empty list builtins.toFile # Schreibt einen String in eine Datei im Nix Store und gibt den Pfad dieser Datei zurück:\nnix-repl\u0026gt; builtins.toFile \u0026#34;greeting\u0026#34; \u0026#34;hallo\u0026#34; \u0026#34;/nix/store/8fday1j2s9rpc28yirwbjp59a1wr3rx3-greeting\u0026#34; Die Datei kann dann beispielsweise als Input für Derivationen verwendet werden. Damit lassen sich beispielsweise Build Skripte inline unterbringen.\nbuiltins.toJSON # Übersetzt einen Nix Ausdruck in sein Json Äquivalent, aber mit ein paar effektvollen Besonderheiten. Strings, Integers, Floats, Bools, null und Listen werden einfach in ihr Json Äquivalent übersetzt. Nix Sets werden zu Json Objekten. Davon ausgenommen sind Derivationen: die werden in den entsprechenden Ausgabepfad übersetzt (als Json String). Nix Paths werden in den Nix Store kopiert und zu ihrem Zielpfad evaluiert (als Json String).\nnix-repl\u0026gt; builtins.toJSON /home/aramis/todo.txt \u0026#34;\\\u0026#34;/nix/store/dmj65s7zfyzzypymaihy8yd1mrdz27pm-todo.txt\\\u0026#34;\u0026#34; nix-repl\u0026gt; builtins.toJSON 123 \u0026#34;123\u0026#34; nix-repl\u0026gt; builtins.toJSON \u0026#34;123\u0026#34; \u0026#34;\\\u0026#34;123\\\u0026#34;\u0026#34; nix-repl\u0026gt; builtins.toJSON [] \u0026#34;[]\u0026#34; nix-repl\u0026gt; builtins.toJSON {} \u0026#34;{}\u0026#34; Ich frage mich, wie hier unterschieden wird zwischen Derivationen und anderen Sets.\nbuiltins.toPath # DEPRECATED.\nMan soll stattdessen für absolute Pfade /. + \u0026quot;/path\u0026quot; und für relative Pfade ./. + \u0026quot;/path\u0026quot; verwenden.\nbuiltins.toXML # Übersetzt einen Nix Ausdruck in eine XML Darstellung:\nnix-repl\u0026gt; builtins.toXML 123 \u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39;?\u0026gt; \u0026lt;expr\u0026gt; \u0026lt;int value=\\\u0026#34;123\\\u0026#34; /\u0026gt; \u0026lt;/expr\u0026gt; \u0026#34;\u0026#34;\u0026#34; nix-repl\u0026gt; builtins.toXML \u0026#34;123\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39;?\u0026gt; \u0026lt;expr\u0026gt; \u0026lt;string value=\\\u0026#34;123\\\u0026#34; /\u0026gt; \u0026lt;/expr\u0026gt; \u0026#34;\u0026#34;\u0026#34; nix-repl\u0026gt; builtins.toXML [] \u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39;?\u0026gt; \u0026lt;expr\u0026gt; \u0026lt;list\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/expr\u0026gt; \u0026#34;\u0026#34;\u0026#34; nix-repl\u0026gt; builtins.toXML {} \u0026#34;\u0026#34;\u0026#34;\u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39;?\u0026gt; \u0026lt;expr\u0026gt; \u0026lt;attrs\u0026gt; \u0026lt;/attrs\u0026gt; \u0026lt;/expr\u0026gt; \u0026#34;\u0026#34;\u0026#34; Das ist dafür da, mit einem Build Script auf eine strukturiertere Weise Daten auszutauschen als es allein mit Umgebungsvariablen möglich ist.\nIrgendwie verursacht XML in mir so etwas wie PTSD.\nbuiltins.traceVerbose # Wenn die Flag --trace-verbose aktiv ist, entspricht ein Aufruf von builtins.trace einem Aufruf von builtins.trace:\n$ nix repl --trace-verbose Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; builtins.traceVerbose [ 1 2 3 ] \u0026#34;foo\u0026#34; trace: [ 1 2 3 ] \u0026#34;foo\u0026#34; Ohne die Flag wertet builtins.traceVerbose e1 e2 einfach nur zu e2 aus:\n$ nix repl Welcome to Nix 2.10.3. Type :? for help. nix-repl\u0026gt; builtins.traceVerbose [ 1 2 3 ] \u0026#34;foo\u0026#34; \u0026#34;foo\u0026#34; builtins.tryEval # Darauf gehe ich im Abschnitt Fehler ein.\nbuiltins.typeOf # Liefert einen String, der den Datentyp eines Ausdrucks bezeichnet. Die Datentypen sind \u0026quot;int\u0026quot;, \u0026quot;bool\u0026quot;, \u0026quot;string\u0026quot;, \u0026quot;path\u0026quot;, \u0026quot;null\u0026quot;, \u0026quot;set\u0026quot;, \u0026quot;list\u0026quot;, \u0026quot;lambda\u0026quot; und \u0026quot;float\u0026quot;:\nnix-repl\u0026gt; builtins.typeOf 0 \u0026#34;int\u0026#34; nix-repl\u0026gt; builtins.typeOf false \u0026#34;bool\u0026#34; nix-repl\u0026gt; builtins.typeOf \u0026#34;\u0026#34; \u0026#34;string\u0026#34; nix-repl\u0026gt; builtins.typeOf /. \u0026#34;path\u0026#34; nix-repl\u0026gt; builtins.typeOf null \u0026#34;null\u0026#34; nix-repl\u0026gt; builtins.typeOf {} \u0026#34;set\u0026#34; nix-repl\u0026gt; builtins.typeOf [] \u0026#34;list\u0026#34; nix-repl\u0026gt; builtins.typeOf ( x : x ) \u0026#34;lambda\u0026#34; nix-repl\u0026gt; builtins.typeOf 0.0 \u0026#34;float\u0026#34; builtins.unsafeDiscardOutputDependency # Undokumentiert.\nbuiltins.unsafeDiscardStringContext # Undokumentiert.\nbuiltins.unsafeGetAttrPos # Undokumentiert.\nbuiltins.zipAttrsWith # Das ist wieder so eine Funktion, die etwas ausführlicher beschrieben werden muss.\nSie nimmt eine zweiwertige Funktion f und eine Liste von Sets entgegen. Aus den Sets werden zunächst die Werte für die jeweiligen Schlüssel in Listen gesammelt. Aus den Schlüsseln und den zugehörigen Listen wird ein Set erstellt. Auf dieses Set wird builtins.mapAttrs f angewendet.\nSchauen wir uns das zunächst mit einer neutralen Funktion f an:\nnix-repl\u0026gt; :p builtins.zipAttrsWith ... ( k : v : v ) ... [ { x = 1 ; y = 2 ; } ... { x = 3 ; y = 4 ; z = 5 ; } ... ] { x = [ 1 3 ]; y = [ 2 4 ]; z = [ 5 ]; } Ich denke, hier sieht man ganz gut, was vor sich geht: alle Schlüssel werden eingesammelt und für jeden Schlüssel werden die zugehörigen Werte in Listen akkumuliert. Diese Listen sind naturgemäß nichtleer (sonst gäbe es keinen zugehörigen Schlüssel).\nWir können dann mit f auf diesen Listen operieren. Beispielsweise können wir zählen, wie oft jeder Schlüssel vorkommt:\nnix-repl\u0026gt; :p builtins.zipAttrsWith ... ( k : v : builtins.length v ) ... [ { x = 1 ; y = 2 ; } ... { x = 3 ; y = 4 ; z = 5 ; } ... ] { x = 2; y = 2; z = 1; } Oder wir finden den jeweils größten Wert für jeden Schlüssel. Dafür bauen wir uns zunächst eine max Funktion für nichtnegative Zahlen:\nnix-repl\u0026gt; max = ls : ... builtins.foldl\u0026#39; ... ( a : b : if a \u0026gt; b then a else b ) ... 0 ... ls nix-repl\u0026gt; max [ 1 2 3 4 5 4 3 2 1 ] 5 Damit können wir die größten Schlüssel finden:\nnix-repl\u0026gt; :p builtins.zipAttrsWith ... ( k : v : max v ) ... [ { x = 1 ; y = 2 ; } ... { x = 3 ; y = 4 ; z = 5 ; } ... ] { x = 3; y = 4; z = 5; } Damit ist meine erste Erkundung der Nix Expression Language abgeschlossen. Vielleicht gibt es hier und da noch einen unbeleuchteten Aspekt, aber im großen und ganzen habe ich einen guten Überblick und ein gutes Gefühl für die Sprache. Syntaktisch erinnert sie mich weniger an Haskell aber vielleicht ein bisschen an OCaml und an Coqs Gallina Sprache. Semantisch sind wir eher im Erlang/Ruby/JavaScript-Land: dynamische Typisierung, polymorphe Listen usw.\nDamit kann ich Nix (die Sprache) zunächst abhaken. Als nächstes arbeite ich G. Gonzalez\u0026rsquo; Vortrag Nix: under the hood durch, um den Nix Store und die Nix CLI-Befehle besser kennenzulernen.\n"},{"id":4,"href":"/docs/weblog/2022-11-30/","title":"Digital Gardening","section":"Docs","content":"2022-11-30\nDigital Gardening # Online kursierte vor einiger Zeit unter dem Schlagwort Digital Gardening eine alternative Vision für das Web jenseits des sequentiellen Publizierens à la Twitter, Instagram, Weblog und so weiter. Statt fertige, datierte Inhalte online zu stellen und Hot Takes in den Socials zu posten, können wir im Web Wissensammlungen anfertigen: allgemein oder thematisch, lose oder strukturiert, allein oder kollaborativ. Die Möglichkeiten sind zahlreich und es gibt dabei keinen Zwang zur Tagesaktualität und Reichweite.\nDie Idee ist genaugenommen keine neue. Solche Inhalte haben früher einen großen Teil des Web ausgemacht. Dann haben Google, Facebook usw. das Web übernommen und daraus eine Einkaufspromenade gemacht. Jetzt scheint eine neue Generation die alten Freiheitsgrade wiederentdeckt zu haben. Neben dem ursprünglichen World Wide Web müsste eine Genealogie des Digital Gardening mindestens auch die folgenden Wegsteine enthalten.\nNiklas Luhmanns Zettelkasten. Luhmann hat Hypertext handschritlich auf nummerierten Karteikarten so produktiv gemacht wie kein zweiter und auf dieser Basis eine umfassende Theorie der Gesellschaft erarbeitet. Luhmanns Lebenswerk zeigt, dass textvermitteltes Denken effektiv und effizient ist, wenn verfügbare und bewährte Werkzeuge mit Disziplin, Kontinuität und Geschick eingesetzt werden.\nToDo Apps und Note Taking Apps. Evernote, Org Mode, Roam Research, Obsidian, Logseq: beim Einsatz solcher Anwendungen muss man aufpassen: es bedarf einer echten Aufgabe, eines konkreten Ziels oder irgendeiner anderen Substanz, an der sich die ToDos und Notes ausrichten. Sonst bleibt das ganze Note Taking und ToDoing rein mastorbatorisch. Es ist nicht schwer, in diese Falle zu tappen, der Anwendung die Schuld dafür zu geben und die nächste auszuprobieren. So dreht man sich nur im Kreis ohne je sinnstiftende Arbeit zu verrichten.\nDigital Humanities. Dagegen sind die Wikis, digitalen Archive und Online-Editionen der Digitial Humanities echte Bemühungen, einen digitalen Bestand an Texten und anderen medialen Artefakten aufzubauen, hypertextuell zu verflechten und für die Wissenschaften produktiv zu machen oder der breiteren Öffentlichkeit zur Verfügung zu stellen.\nEngelbarts Dynamic Knowledge Repository. Neben der Computermaus geht auf Douglas Engelbart die Vorstellung zurück, dass der Computer \u0026ndash; wenn wir ihn richtig einsetzen \u0026ndash; unsere kollektive Intelligenz exponentiell steigern wird. Zentral ist dabei die Idee eines Wissensspeichers, der nicht nur einen statischen Wissensvorrat enthält, sondern durch eine dialoghafte Interaktion zwischen Mensch und Computer zu einem Katalysator für das Denken wird.\nFür die meisten von uns wird Digital Gardening bescheidener und persönlicher sein, so auch für mich: wenn ich etwas, lerne, lese, konstruiere, ein Problem bearbeite usw.: dann fertige ich dazu gern Notizen an und versuche, sie so zu verlinken, dass ich sie im passenden Arbeitskontext wiederfinden kann. Die Datenbasis dafür sind Textdateien in einem Git-versionierten Verzeichnis. In diesem Garten gedeihen vielfätige Gewächse: Stichwortlisten, Linksammlungen, Protokolle, HowTos, Zusammenfassungen, Taxonomien, und manchmal auch Texte wie dieser.\nLinks zum Thema\nA Brief History of Digital Gardens How the Blog Broke the Web The Garden and the Stream: a Technopastoral As We May Think "},{"id":5,"href":"/docs/","title":"Docs","section":"","content":""}]